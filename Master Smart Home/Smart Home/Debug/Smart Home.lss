
Smart Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000289e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001e4  00800060  0000289e  00002932  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000035  00800244  00800244  00002b16  2**0
                  ALLOC
  3 .stab         00002370  00000000  00000000  00002b18  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000770  00000000  00000000  00004e88  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000320  00000000  00000000  000055f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004352  00000000  00000000  00005918  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016c5  00000000  00000000  00009c6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000212d  00000000  00000000  0000b32f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b04  00000000  00000000  0000d45c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000019b9  00000000  00000000  0000df60  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000026dd  00000000  00000000  0000f919  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000048  00000000  00000000  00011ff6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 68 01 	jmp	0x2d0	; 0x2d0 <__vector_1>
       8:	0c 94 91 01 	jmp	0x322	; 0x322 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 ff 11 	jmp	0x23fe	; 0x23fe <__vector_10>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 22 02 	jmp	0x444	; 0x444 <__vector_12>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e9       	ldi	r30, 0x9E	; 158
      68:	f8 e2       	ldi	r31, 0x28	; 40
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a4 34       	cpi	r26, 0x44	; 68
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	12 e0       	ldi	r17, 0x02	; 2
      78:	a4 e4       	ldi	r26, 0x44	; 68
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 37       	cpi	r26, 0x79	; 121
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 1f 12 	call	0x243e	; 0x243e <main>
      8a:	0c 94 4d 14 	jmp	0x289a	; 0x289a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_INTIATE>:

#define LEVEL_NUM    (1024)


void ADC_INTIATE(ANALOG_DATATYPE ADC_signal)
{
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	cf 93       	push	r28
      98:	df 93       	push	r29
      9a:	00 d0       	rcall	.+0      	; 0x9c <ADC_INTIATE+0xa>
      9c:	00 d0       	rcall	.+0      	; 0x9e <ADC_INTIATE+0xc>
      9e:	00 d0       	rcall	.+0      	; 0xa0 <ADC_INTIATE+0xe>
      a0:	cd b7       	in	r28, 0x3d	; 61
      a2:	de b7       	in	r29, 0x3e	; 62
      a4:	14 2f       	mov	r17, r20
      a6:	49 83       	std	Y+1, r20	; 0x01
      a8:	5a 83       	std	Y+2, r21	; 0x02
      aa:	6b 83       	std	Y+3, r22	; 0x03
      ac:	7c 83       	std	Y+4, r23	; 0x04
      ae:	8d 83       	std	Y+5, r24	; 0x05
      b0:	9e 83       	std	Y+6, r25	; 0x06
	char ADCSRA_temp = 0x00;
	char ADCMUX_temp = 0x00;
	
	/* Set The Clock input Frequency */
	switch(ADC_signal.ADC_CLK_In)
      b2:	72 30       	cpi	r23, 0x02	; 2
      b4:	99 f0       	breq	.+38     	; 0xdc <ADC_INTIATE+0x4a>
      b6:	73 30       	cpi	r23, 0x03	; 3
      b8:	28 f4       	brcc	.+10     	; 0xc4 <ADC_INTIATE+0x32>
      ba:	77 23       	and	r23, r23
      bc:	99 f0       	breq	.+38     	; 0xe4 <ADC_INTIATE+0x52>
      be:	71 30       	cpi	r23, 0x01	; 1
      c0:	39 f4       	brne	.+14     	; 0xd0 <ADC_INTIATE+0x3e>
      c2:	0e c0       	rjmp	.+28     	; 0xe0 <ADC_INTIATE+0x4e>
      c4:	74 30       	cpi	r23, 0x04	; 4
      c6:	31 f0       	breq	.+12     	; 0xd4 <ADC_INTIATE+0x42>
      c8:	74 30       	cpi	r23, 0x04	; 4
      ca:	30 f0       	brcs	.+12     	; 0xd8 <ADC_INTIATE+0x46>
      cc:	75 30       	cpi	r23, 0x05	; 5
      ce:	61 f0       	breq	.+24     	; 0xe8 <ADC_INTIATE+0x56>
#define LEVEL_NUM    (1024)


void ADC_INTIATE(ANALOG_DATATYPE ADC_signal)
{
	char ADCSRA_temp = 0x00;
      d0:	00 e0       	ldi	r16, 0x00	; 0
      d2:	0b c0       	rjmp	.+22     	; 0xea <ADC_INTIATE+0x58>
		case FCPU_DIV4:
		     SET_Bit(ADCSRA_temp,ADPS1);
		break;
		case FCPU_DIV8:
		     SET_Bit(ADCSRA_temp,ADPS0);
			 SET_Bit(ADCSRA_temp,ADPS1);
      d4:	03 e0       	ldi	r16, 0x03	; 3
		break;
      d6:	09 c0       	rjmp	.+18     	; 0xea <ADC_INTIATE+0x58>
		case FCPU_DIV16:
			 SET_Bit(ADCSRA_temp,ADPS2);
      d8:	04 e0       	ldi	r16, 0x04	; 4
		break;
      da:	07 c0       	rjmp	.+14     	; 0xea <ADC_INTIATE+0x58>
		case FCPU_DIV32:
		     SET_Bit(ADCSRA_temp,ADPS0);
		     SET_Bit(ADCSRA_temp,ADPS2);
      dc:	05 e0       	ldi	r16, 0x05	; 5
		break;
      de:	05 c0       	rjmp	.+10     	; 0xea <ADC_INTIATE+0x58>
		case FCPU_DIV64:
		     SET_Bit(ADCSRA_temp,ADPS1);
		     SET_Bit(ADCSRA_temp,ADPS2);
      e0:	06 e0       	ldi	r16, 0x06	; 6
		break;
      e2:	03 c0       	rjmp	.+6      	; 0xea <ADC_INTIATE+0x58>
		case FCPU_DIV128:
		     SET_Bit(ADCSRA_temp,ADPS0);
			 SET_Bit(ADCSRA_temp,ADPS1);
		     SET_Bit(ADCSRA_temp,ADPS2);
      e4:	07 e0       	ldi	r16, 0x07	; 7
		break;
      e6:	01 c0       	rjmp	.+2      	; 0xea <ADC_INTIATE+0x58>
	{
		case FCPU_DIV2:
		     /* it the default case when all the bit became 0*/
		break;
		case FCPU_DIV4:
		     SET_Bit(ADCSRA_temp,ADPS1);
      e8:	02 e0       	ldi	r16, 0x02	; 2
		     SET_Bit(ADCSRA_temp,ADPS2);
		break;
	}
	
	/* Set The Configuration of The Pin As An Input Pin */
	DIO_pinConfiguration(GPIOA, ADC_signal.ADC_PIN, InputFloat);
      ea:	89 e3       	ldi	r24, 0x39	; 57
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	61 2f       	mov	r22, r17
      f0:	40 e0       	ldi	r20, 0x00	; 0
      f2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	
	/* Set the pin of the Multiplexer to make it sample */
	switch(ADC_signal.ADC_PIN)
      f6:	14 30       	cpi	r17, 0x04	; 4
      f8:	a9 f0       	breq	.+42     	; 0x124 <ADC_INTIATE+0x92>
      fa:	15 30       	cpi	r17, 0x05	; 5
      fc:	38 f4       	brcc	.+14     	; 0x10c <ADC_INTIATE+0x7a>
      fe:	12 30       	cpi	r17, 0x02	; 2
     100:	69 f0       	breq	.+26     	; 0x11c <ADC_INTIATE+0x8a>
     102:	13 30       	cpi	r17, 0x03	; 3
     104:	68 f4       	brcc	.+26     	; 0x120 <ADC_INTIATE+0x8e>
     106:	11 30       	cpi	r17, 0x01	; 1
     108:	39 f4       	brne	.+14     	; 0x118 <ADC_INTIATE+0x86>
     10a:	14 c0       	rjmp	.+40     	; 0x134 <ADC_INTIATE+0xa2>
     10c:	16 30       	cpi	r17, 0x06	; 6
     10e:	71 f0       	breq	.+28     	; 0x12c <ADC_INTIATE+0x9a>
     110:	16 30       	cpi	r17, 0x06	; 6
     112:	50 f0       	brcs	.+20     	; 0x128 <ADC_INTIATE+0x96>
     114:	17 30       	cpi	r17, 0x07	; 7
     116:	61 f0       	breq	.+24     	; 0x130 <ADC_INTIATE+0x9e>


void ADC_INTIATE(ANALOG_DATATYPE ADC_signal)
{
	char ADCSRA_temp = 0x00;
	char ADCMUX_temp = 0x00;
     118:	80 e0       	ldi	r24, 0x00	; 0
     11a:	0d c0       	rjmp	.+26     	; 0x136 <ADC_INTIATE+0xa4>
		break;
		case PIN1:
		     SET_Bit(ADCMUX_temp, MUX0);
		break;
		case PIN2:
		     SET_Bit(ADCMUX_temp, MUX1);
     11c:	82 e0       	ldi	r24, 0x02	; 2
		break;
     11e:	0b c0       	rjmp	.+22     	; 0x136 <ADC_INTIATE+0xa4>
		case PIN3:
		     SET_Bit(ADCMUX_temp, MUX0);
			 SET_Bit(ADCMUX_temp, MUX1);
     120:	83 e0       	ldi	r24, 0x03	; 3
		break;
     122:	09 c0       	rjmp	.+18     	; 0x136 <ADC_INTIATE+0xa4>
		case PIN4:
		     SET_Bit(ADCMUX_temp,MUX2);
     124:	84 e0       	ldi	r24, 0x04	; 4
		break;
     126:	07 c0       	rjmp	.+14     	; 0x136 <ADC_INTIATE+0xa4>
		case PIN5:
		     SET_Bit(ADCMUX_temp, MUX0);
			 SET_Bit(ADCMUX_temp,MUX2);
     128:	85 e0       	ldi	r24, 0x05	; 5
		break;
     12a:	05 c0       	rjmp	.+10     	; 0x136 <ADC_INTIATE+0xa4>
		case PIN6:
		     SET_Bit(ADCMUX_temp, MUX1);
			 SET_Bit(ADCMUX_temp,MUX2);
     12c:	86 e0       	ldi	r24, 0x06	; 6
		break;
     12e:	03 c0       	rjmp	.+6      	; 0x136 <ADC_INTIATE+0xa4>
		case PIN7:
		     SET_Bit(ADCMUX_temp, MUX0);
			 SET_Bit(ADCMUX_temp, MUX1);
			 SET_Bit(ADCMUX_temp,MUX2);
     130:	87 e0       	ldi	r24, 0x07	; 7
		break;
     132:	01 c0       	rjmp	.+2      	; 0x136 <ADC_INTIATE+0xa4>
	{
		case PIN0:
		     /* it The Default State */
		break;
		case PIN1:
		     SET_Bit(ADCMUX_temp, MUX0);
     134:	81 e0       	ldi	r24, 0x01	; 1
			 SET_Bit(ADCMUX_temp,MUX2);
		break;
	}
	
	/* Interrupt State */
	switch(ADC_signal.INT)
     136:	9b 81       	ldd	r25, Y+3	; 0x03
     138:	91 30       	cpi	r25, 0x01	; 1
     13a:	09 f4       	brne	.+2      	; 0x13e <ADC_INTIATE+0xac>
	{
	   case ADC_INT_DISABLE:
	        /* It The Default State */
	   break;
	   case ADC_INT_ENABLE:
	        SET_Bit(ADCSRA_temp, ADIE);
     13c:	08 60       	ori	r16, 0x08	; 8
	   break;
	}
	
	/* Set The Voltage Reference Of The ADC */
	switch(ADC_signal.REF_Voltage)
     13e:	9a 81       	ldd	r25, Y+2	; 0x02
     140:	99 23       	and	r25, r25
     142:	19 f0       	breq	.+6      	; 0x14a <ADC_INTIATE+0xb8>
     144:	92 30       	cpi	r25, 0x02	; 2
     146:	21 f4       	brne	.+8      	; 0x150 <ADC_INTIATE+0xbe>
     148:	02 c0       	rjmp	.+4      	; 0x14e <ADC_INTIATE+0xbc>
		case AREF:
		     /* it The Default State The 2 Bits Is 0 */
		break;
		case AVCC:
		/* Note at This Case the AREF Connect With a capacitor to Ground */
		     SET_Bit(ADCMUX_temp,REF0);
     14a:	80 64       	ori	r24, 0x40	; 64
		break;
     14c:	01 c0       	rjmp	.+2      	; 0x150 <ADC_INTIATE+0xbe>
		case INTERNV:
		/* The Value Of The iternal Voltage is 2.56 V */
		    SET_Bit(ADCMUX_temp,REF0);
			SET_Bit(ADCMUX_temp,REF1);
     14e:	80 6c       	ori	r24, 0xC0	; 192
		break;
	}
	
	/* The Data Sort In The ADCL , ADCH Register State */
	switch(ADC_signal.ADC_SORT)
     150:	9e 81       	ldd	r25, Y+6	; 0x06
     152:	91 30       	cpi	r25, 0x01	; 1
     154:	09 f4       	brne	.+2      	; 0x158 <ADC_INTIATE+0xc6>
	{
		case ADJUST_RIGHT:
		/* it The Default State The 2 Bits Is 0 */
		break;
		case ADJUST_LEFT:
		     SET_Bit(ADCMUX_temp,ADLAR);
     156:	80 62       	ori	r24, 0x20	; 32
		case TIMERCO0_CAPEVENT:
		break;
		/* it Will Handle When it Needed */
	}
	
	ADCMUX = ADCMUX_temp;
     158:	87 b9       	out	0x07, r24	; 7
	ADCSRA = ADCSRA_temp;
     15a:	06 b9       	out	0x06, r16	; 6
	/* Enable The ADC Bit */
	SET_Bit(ADCSRA, ADEN);
     15c:	37 9a       	sbi	0x06, 7	; 6
}
     15e:	26 96       	adiw	r28, 0x06	; 6
     160:	0f b6       	in	r0, 0x3f	; 63
     162:	f8 94       	cli
     164:	de bf       	out	0x3e, r29	; 62
     166:	0f be       	out	0x3f, r0	; 63
     168:	cd bf       	out	0x3d, r28	; 61
     16a:	df 91       	pop	r29
     16c:	cf 91       	pop	r28
     16e:	1f 91       	pop	r17
     170:	0f 91       	pop	r16
     172:	08 95       	ret

00000174 <analogRead>:




int analogRead(ANALOG_DATATYPE signal)
{
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <analogRead+0x6>
     17a:	00 d0       	rcall	.+0      	; 0x17c <analogRead+0x8>
     17c:	00 d0       	rcall	.+0      	; 0x17e <analogRead+0xa>
     17e:	cd b7       	in	r28, 0x3d	; 61
     180:	de b7       	in	r29, 0x3e	; 62
     182:	49 83       	std	Y+1, r20	; 0x01
     184:	5a 83       	std	Y+2, r21	; 0x02
     186:	6b 83       	std	Y+3, r22	; 0x03
     188:	7c 83       	std	Y+4, r23	; 0x04
     18a:	8d 83       	std	Y+5, r24	; 0x05
     18c:	9e 83       	std	Y+6, r25	; 0x06
	unsigned int DataRead = 0x00;
	/*  as A default We in the Single Conversion Mode */
	/* Set Bit ADSC to Start The Conversion */
	SET_Bit(ADCSRA, ADSC); 
     18e:	36 9a       	sbi	0x06, 6	; 6
	while (READ_Bit(ADCSRA,ADSC) == 0);
     190:	36 9b       	sbis	0x06, 6	; 6
     192:	fe cf       	rjmp	.-4      	; 0x190 <analogRead+0x1c>
	/* it Must in THe Right Adjust Mode Read The ADCL register Before The ADCH */
	DataRead = ADCL; 
     194:	84 b1       	in	r24, 0x04	; 4
     196:	90 e0       	ldi	r25, 0x00	; 0
	DataRead |= (ADCH << 8);
     198:	45 b1       	in	r20, 0x05	; 5
     19a:	34 2f       	mov	r19, r20
     19c:	20 e0       	ldi	r18, 0x00	; 0
     19e:	82 2b       	or	r24, r18
     1a0:	93 2b       	or	r25, r19
	
	return DataRead;
	
     1a2:	26 96       	adiw	r28, 0x06	; 6
     1a4:	0f b6       	in	r0, 0x3f	; 63
     1a6:	f8 94       	cli
     1a8:	de bf       	out	0x3e, r29	; 62
     1aa:	0f be       	out	0x3f, r0	; 63
     1ac:	cd bf       	out	0x3d, r28	; 61
     1ae:	df 91       	pop	r29
     1b0:	cf 91       	pop	r28
     1b2:	08 95       	ret

000001b4 <DIO_pinConfiguration>:




void DIO_pinConfiguration(GPIO * pinC, pinNumber pin_num, pinMode pin_M)
{
     1b4:	fc 01       	movw	r30, r24
	switch (pin_M)
     1b6:	41 30       	cpi	r20, 0x01	; 1
     1b8:	29 f0       	breq	.+10     	; 0x1c4 <DIO_pinConfiguration+0x10>
     1ba:	41 30       	cpi	r20, 0x01	; 1
     1bc:	a8 f0       	brcs	.+42     	; 0x1e8 <DIO_pinConfiguration+0x34>
     1be:	42 30       	cpi	r20, 0x02	; 2
     1c0:	b1 f5       	brne	.+108    	; 0x22e <DIO_pinConfiguration+0x7a>
     1c2:	24 c0       	rjmp	.+72     	; 0x20c <DIO_pinConfiguration+0x58>
	{
		case InputPullup:
		/* In This Case We Make The Pin Input By Get Low in The DDR And Make It Default State (idle) HIgh By Set The Port */
		RESET_Bit(pinC -> DDR, pin_num);
     1c4:	21 81       	ldd	r18, Z+1	; 0x01
     1c6:	81 e0       	ldi	r24, 0x01	; 1
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	ac 01       	movw	r20, r24
     1cc:	02 c0       	rjmp	.+4      	; 0x1d2 <DIO_pinConfiguration+0x1e>
     1ce:	44 0f       	add	r20, r20
     1d0:	55 1f       	adc	r21, r21
     1d2:	6a 95       	dec	r22
     1d4:	e2 f7       	brpl	.-8      	; 0x1ce <DIO_pinConfiguration+0x1a>
     1d6:	ba 01       	movw	r22, r20
     1d8:	84 2f       	mov	r24, r20
     1da:	80 95       	com	r24
     1dc:	82 23       	and	r24, r18
     1de:	81 83       	std	Z+1, r24	; 0x01
		SET_Bit(pinC -> PORT, pin_num);
     1e0:	82 81       	ldd	r24, Z+2	; 0x02
     1e2:	68 2b       	or	r22, r24
     1e4:	62 83       	std	Z+2, r22	; 0x02
		break;
     1e6:	08 95       	ret
		case InputFloat:
		/* In This Case We Make The Pin Input By Get Low in The DDR And Make It Default State (idle) LOW By RESET The Port And Make A Pull down Resistance  */
		RESET_Bit(pinC -> DDR,pin_num);
     1e8:	21 81       	ldd	r18, Z+1	; 0x01
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	ac 01       	movw	r20, r24
     1f0:	02 c0       	rjmp	.+4      	; 0x1f6 <DIO_pinConfiguration+0x42>
     1f2:	44 0f       	add	r20, r20
     1f4:	55 1f       	adc	r21, r21
     1f6:	6a 95       	dec	r22
     1f8:	e2 f7       	brpl	.-8      	; 0x1f2 <DIO_pinConfiguration+0x3e>
     1fa:	ba 01       	movw	r22, r20
     1fc:	60 95       	com	r22
     1fe:	86 2f       	mov	r24, r22
     200:	82 23       	and	r24, r18
     202:	81 83       	std	Z+1, r24	; 0x01
		RESET_Bit(pinC -> PORT,pin_num);
     204:	82 81       	ldd	r24, Z+2	; 0x02
     206:	68 23       	and	r22, r24
     208:	62 83       	std	Z+2, r22	; 0x02
		break;
     20a:	08 95       	ret
		case Output:
		/* In This Case We Make The Pin Output By  SET The DDR And Make It Default State (idle) LOW By Set The Port TO Make It reverse Connection Sink Source to Avoid Error Value When The Number Of The Output Increace */
		SET_Bit(pinC -> DDR, pin_num);
     20c:	21 81       	ldd	r18, Z+1	; 0x01
     20e:	81 e0       	ldi	r24, 0x01	; 1
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	ac 01       	movw	r20, r24
     214:	02 c0       	rjmp	.+4      	; 0x21a <DIO_pinConfiguration+0x66>
     216:	44 0f       	add	r20, r20
     218:	55 1f       	adc	r21, r21
     21a:	6a 95       	dec	r22
     21c:	e2 f7       	brpl	.-8      	; 0x216 <DIO_pinConfiguration+0x62>
     21e:	ba 01       	movw	r22, r20
     220:	82 2f       	mov	r24, r18
     222:	84 2b       	or	r24, r20
     224:	81 83       	std	Z+1, r24	; 0x01
		RESET_Bit(pinC -> PORT,pin_num);
     226:	82 81       	ldd	r24, Z+2	; 0x02
     228:	60 95       	com	r22
     22a:	68 23       	and	r22, r24
     22c:	62 83       	std	Z+2, r22	; 0x02
     22e:	08 95       	ret

00000230 <DIO_pinWrite>:




 void DIO_pinWrite(GPIO * pinC, pinNumber pin_num, DigitalValue state)
 {
     230:	fc 01       	movw	r30, r24
	 switch(state)
     232:	44 23       	and	r20, r20
     234:	79 f0       	breq	.+30     	; 0x254 <DIO_pinWrite+0x24>
     236:	41 30       	cpi	r20, 0x01	; 1
     238:	d1 f4       	brne	.+52     	; 0x26e <DIO_pinWrite+0x3e>
	 {
		 case HIGH:
		 /* The Pin Get Output High State */
		 SET_Bit(pinC -> PORT, pin_num);
     23a:	22 81       	ldd	r18, Z+2	; 0x02
     23c:	81 e0       	ldi	r24, 0x01	; 1
     23e:	90 e0       	ldi	r25, 0x00	; 0
     240:	ac 01       	movw	r20, r24
     242:	02 c0       	rjmp	.+4      	; 0x248 <DIO_pinWrite+0x18>
     244:	44 0f       	add	r20, r20
     246:	55 1f       	adc	r21, r21
     248:	6a 95       	dec	r22
     24a:	e2 f7       	brpl	.-8      	; 0x244 <DIO_pinWrite+0x14>
     24c:	ba 01       	movw	r22, r20
     24e:	62 2b       	or	r22, r18
     250:	62 83       	std	Z+2, r22	; 0x02
		 break;
     252:	08 95       	ret
		 case LOW:
		 /* The Pin Get Output Low State */
		 RESET_Bit(pinC -> PORT, pin_num);
     254:	22 81       	ldd	r18, Z+2	; 0x02
     256:	81 e0       	ldi	r24, 0x01	; 1
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	ac 01       	movw	r20, r24
     25c:	02 c0       	rjmp	.+4      	; 0x262 <DIO_pinWrite+0x32>
     25e:	44 0f       	add	r20, r20
     260:	55 1f       	adc	r21, r21
     262:	6a 95       	dec	r22
     264:	e2 f7       	brpl	.-8      	; 0x25e <DIO_pinWrite+0x2e>
     266:	ba 01       	movw	r22, r20
     268:	60 95       	com	r22
     26a:	62 23       	and	r22, r18
     26c:	62 83       	std	Z+2, r22	; 0x02
     26e:	08 95       	ret

00000270 <DIO_pinRead>:
 }
 
 
 
 DigitalValue DIO_pinRead(GPIO * pinC, pinNumber pin_num)
 {
     270:	fc 01       	movw	r30, r24
	 /* This Function Return The Current State Of The Pin by Use The READ_Bit Definition In The Macro Header */
	 return (READ_Bit(pinC -> PIN, pin_num));
     272:	20 81       	ld	r18, Z
     274:	41 e0       	ldi	r20, 0x01	; 1
     276:	50 e0       	ldi	r21, 0x00	; 0
     278:	ca 01       	movw	r24, r20
     27a:	06 2e       	mov	r0, r22
     27c:	02 c0       	rjmp	.+4      	; 0x282 <DIO_pinRead+0x12>
     27e:	88 0f       	add	r24, r24
     280:	99 1f       	adc	r25, r25
     282:	0a 94       	dec	r0
     284:	e2 f7       	brpl	.-8      	; 0x27e <DIO_pinRead+0xe>
     286:	30 e0       	ldi	r19, 0x00	; 0
     288:	82 23       	and	r24, r18
     28a:	93 23       	and	r25, r19
     28c:	02 c0       	rjmp	.+4      	; 0x292 <DIO_pinRead+0x22>
     28e:	95 95       	asr	r25
     290:	87 95       	ror	r24
     292:	6a 95       	dec	r22
     294:	e2 f7       	brpl	.-8      	; 0x28e <DIO_pinRead+0x1e>
 }
     296:	08 95       	ret

00000298 <DIO_portConfiguration>:
	  
	  if (portValue <= MAX_uint8_VALUE && portValue >= MIN_uint8_VALUE)
	  {
		  /* The Value On The 8 bit DDR To Define Each Pin From The 8 Pins Of The Port As input Or Output */
		  /* equal the port to the 0xFF to get the output */
		  portC->DDR = portValue;
     298:	fc 01       	movw	r30, r24
     29a:	61 83       	std	Z+1, r22	; 0x01
	  }
	  else
	  {
		  //DIO_ErrorIndication()
	  }
  } 
     29c:	08 95       	ret

0000029e <DIO_portWrite>:
 {
	  /* We Must Check That THe Value Of The configuration Of The Port Does Not exceed The 8 bit (0 <-> 255) */
	 if (portValue <= MAX_uint8_VALUE && portValue >= MIN_uint8_VALUE)
	 {
		 /* Get Out The 8bit Value On The * Pins Of The Port */
		 portC->PORT = portValue;
     29e:	fc 01       	movw	r30, r24
     2a0:	62 83       	std	Z+2, r22	; 0x02
	 }
	 else if (portValue < MIN_uint8_VALUE)
	 {
		 portC->PORT = 0x00;
	 }
 }
     2a2:	08 95       	ret

000002a4 <DIO_portRead>:
 
 
 uint8 DIO_portRead(GPIO * portC)
 {
	 /* we And THe Value Of The Port With 1111 1111 And return the result To Get Port State */
	 return (READ_Bit(portC->PORT,ANDINGV_to_readPORT));
     2a4:	fc 01       	movw	r30, r24
     2a6:	82 81       	ldd	r24, Z+2	; 0x02
	 
 }
     2a8:	80 e0       	ldi	r24, 0x00	; 0
     2aa:	08 95       	ret

000002ac <EEPROM_Write>:
 #include "Macro.h"

  void EEPROM_Write (unsigned short Address, unsigned char Data)
  {
	   /* Boole until make sure the  write operation is finish */
	  while (READ_Bit(EECR, EEWE)) {};
     2ac:	e1 99       	sbic	0x1c, 1	; 28
     2ae:	fe cf       	rjmp	.-4      	; 0x2ac <EEPROM_Write>
	 /* flash Program Complete */
	 while(READ_Bit(SPMCR,SPMIE));
     2b0:	07 b6       	in	r0, 0x37	; 55
     2b2:	00 fc       	sbrc	r0, 0
     2b4:	fd cf       	rjmp	.-6      	; 0x2b0 <EEPROM_Write+0x4>
	  /* Set the Address in the EEEPROM address Register */
	  EEAR = Address;
     2b6:	9f bb       	out	0x1f, r25	; 31
     2b8:	8e bb       	out	0x1e, r24	; 30
	  /* Set the Data in the EEPROM data Register */
	  EEDR = Data;
     2ba:	6d bb       	out	0x1d, r22	; 29
	  /* Set the EEPROM Master Write Enable (( Note it only will be set for 4 clock cycle and will reset automatically by HW ))*/
	  EECR |= (1 << EEMWE);
     2bc:	e2 9a       	sbi	0x1c, 2	; 28
	  /* start the Write Operation */
	  EECR |= (1 << EEWE);
     2be:	e1 9a       	sbi	0x1c, 1	; 28
	 
  }
     2c0:	08 95       	ret

000002c2 <EEPEOM_Read>:
  
  
  unsigned char EEPEOM_Read (unsigned short Address)
  {
	  /* Boole until make sure the last write operation is finish */
       while (READ_Bit(EECR, EEWE)) {};
     2c2:	e1 99       	sbic	0x1c, 1	; 28
     2c4:	fe cf       	rjmp	.-4      	; 0x2c2 <EEPEOM_Read>
	  /* Set the Address in the EEEPROM address Register */
	  EEAR = Address;
     2c6:	9f bb       	out	0x1f, r25	; 31
     2c8:	8e bb       	out	0x1e, r24	; 30
	  
	  /* start the Read Operation */
	  EECR |= (1 << EERE);
     2ca:	e0 9a       	sbi	0x1c, 0	; 28
	  /* return the data store in the EEPROM data Register */
	  return EEDR;
     2cc:	8d b3       	in	r24, 0x1d	; 29
     2ce:	08 95       	ret

000002d0 <__vector_1>:
  
  
  

  ISR (INT0_vect,ISR_NESTED_ENABLE)
     {
     2d0:	1f 92       	push	r1
     2d2:	0f 92       	push	r0
     2d4:	0f b6       	in	r0, 0x3f	; 63
     2d6:	0f 92       	push	r0
     2d8:	11 24       	eor	r1, r1
     2da:	2f 93       	push	r18
     2dc:	3f 93       	push	r19
     2de:	4f 93       	push	r20
     2e0:	5f 93       	push	r21
     2e2:	6f 93       	push	r22
     2e4:	7f 93       	push	r23
     2e6:	8f 93       	push	r24
     2e8:	9f 93       	push	r25
     2ea:	af 93       	push	r26
     2ec:	bf 93       	push	r27
     2ee:	ef 93       	push	r30
     2f0:	ff 93       	push	r31
		 if (EXTINT0_ISR != NULL)
     2f2:	e0 91 48 02 	lds	r30, 0x0248
     2f6:	f0 91 49 02 	lds	r31, 0x0249
     2fa:	30 97       	sbiw	r30, 0x00	; 0
     2fc:	09 f0       	breq	.+2      	; 0x300 <__vector_1+0x30>
		 {
			 EXTINT0_ISR();
     2fe:	09 95       	icall
		 }
	 }
     300:	ff 91       	pop	r31
     302:	ef 91       	pop	r30
     304:	bf 91       	pop	r27
     306:	af 91       	pop	r26
     308:	9f 91       	pop	r25
     30a:	8f 91       	pop	r24
     30c:	7f 91       	pop	r23
     30e:	6f 91       	pop	r22
     310:	5f 91       	pop	r21
     312:	4f 91       	pop	r20
     314:	3f 91       	pop	r19
     316:	2f 91       	pop	r18
     318:	0f 90       	pop	r0
     31a:	0f be       	out	0x3f, r0	; 63
     31c:	0f 90       	pop	r0
     31e:	1f 90       	pop	r1
     320:	18 95       	reti

00000322 <__vector_2>:
	 
	ISR (INT1_vect,ISR_NESTED_ENABLE)
	{
     322:	1f 92       	push	r1
     324:	0f 92       	push	r0
     326:	0f b6       	in	r0, 0x3f	; 63
     328:	0f 92       	push	r0
     32a:	11 24       	eor	r1, r1
     32c:	2f 93       	push	r18
     32e:	3f 93       	push	r19
     330:	4f 93       	push	r20
     332:	5f 93       	push	r21
     334:	6f 93       	push	r22
     336:	7f 93       	push	r23
     338:	8f 93       	push	r24
     33a:	9f 93       	push	r25
     33c:	af 93       	push	r26
     33e:	bf 93       	push	r27
     340:	ef 93       	push	r30
     342:	ff 93       	push	r31
		if (EXTINT1_ISR != NULL)
     344:	e0 91 46 02 	lds	r30, 0x0246
     348:	f0 91 47 02 	lds	r31, 0x0247
     34c:	30 97       	sbiw	r30, 0x00	; 0
     34e:	09 f0       	breq	.+2      	; 0x352 <__vector_2+0x30>
		{
			EXTINT1_ISR();
     350:	09 95       	icall
		}
	}
     352:	ff 91       	pop	r31
     354:	ef 91       	pop	r30
     356:	bf 91       	pop	r27
     358:	af 91       	pop	r26
     35a:	9f 91       	pop	r25
     35c:	8f 91       	pop	r24
     35e:	7f 91       	pop	r23
     360:	6f 91       	pop	r22
     362:	5f 91       	pop	r21
     364:	4f 91       	pop	r20
     366:	3f 91       	pop	r19
     368:	2f 91       	pop	r18
     36a:	0f 90       	pop	r0
     36c:	0f be       	out	0x3f, r0	; 63
     36e:	0f 90       	pop	r0
     370:	1f 90       	pop	r1
     372:	18 95       	reti

00000374 <EXTINT_InterruptInit>:



	void EXTINT_InterruptInit(EXInterrupt_Source source,ExInterrupt_Modes Mode)
	{
		switch (source)
     374:	81 30       	cpi	r24, 0x01	; 1
     376:	71 f1       	breq	.+92     	; 0x3d4 <EXTINT_InterruptInit+0x60>
     378:	81 30       	cpi	r24, 0x01	; 1
     37a:	20 f0       	brcs	.+8      	; 0x384 <EXTINT_InterruptInit+0x10>
     37c:	82 30       	cpi	r24, 0x02	; 2
     37e:	09 f0       	breq	.+2      	; 0x382 <EXTINT_InterruptInit+0xe>
     380:	60 c0       	rjmp	.+192    	; 0x442 <EXTINT_InterruptInit+0xce>
     382:	50 c0       	rjmp	.+160    	; 0x424 <EXTINT_InterruptInit+0xb0>
		{
			case EXINT_INT0 :
				 switch (Mode)
     384:	61 30       	cpi	r22, 0x01	; 1
     386:	71 f0       	breq	.+28     	; 0x3a4 <EXTINT_InterruptInit+0x30>
     388:	61 30       	cpi	r22, 0x01	; 1
     38a:	28 f0       	brcs	.+10     	; 0x396 <EXTINT_InterruptInit+0x22>
     38c:	62 30       	cpi	r22, 0x02	; 2
     38e:	89 f0       	breq	.+34     	; 0x3b2 <EXTINT_InterruptInit+0x3e>
     390:	63 30       	cpi	r22, 0x03	; 3
     392:	e1 f4       	brne	.+56     	; 0x3cc <EXTINT_InterruptInit+0x58>
     394:	15 c0       	rjmp	.+42     	; 0x3c0 <EXTINT_InterruptInit+0x4c>
				 {
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC00);
     396:	85 b7       	in	r24, 0x35	; 53
     398:	8e 7f       	andi	r24, 0xFE	; 254
     39a:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC01);
     39c:	85 b7       	in	r24, 0x35	; 53
     39e:	8d 7f       	andi	r24, 0xFD	; 253
     3a0:	85 bf       	out	0x35, r24	; 53
						  break;
     3a2:	14 c0       	rjmp	.+40     	; 0x3cc <EXTINT_InterruptInit+0x58>
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC00);
     3a4:	85 b7       	in	r24, 0x35	; 53
     3a6:	81 60       	ori	r24, 0x01	; 1
     3a8:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC01);
     3aa:	85 b7       	in	r24, 0x35	; 53
     3ac:	8d 7f       	andi	r24, 0xFD	; 253
     3ae:	85 bf       	out	0x35, r24	; 53
						  break;
     3b0:	0d c0       	rjmp	.+26     	; 0x3cc <EXTINT_InterruptInit+0x58>
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC00);
     3b2:	85 b7       	in	r24, 0x35	; 53
     3b4:	8e 7f       	andi	r24, 0xFE	; 254
     3b6:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC01);
     3b8:	85 b7       	in	r24, 0x35	; 53
     3ba:	82 60       	ori	r24, 0x02	; 2
     3bc:	85 bf       	out	0x35, r24	; 53
						  break;
     3be:	06 c0       	rjmp	.+12     	; 0x3cc <EXTINT_InterruptInit+0x58>
					 case EXINT_RisingEdge :
						  SET_Bit(MCUCR,ISC00);
     3c0:	85 b7       	in	r24, 0x35	; 53
     3c2:	81 60       	ori	r24, 0x01	; 1
     3c4:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC01);
     3c6:	85 b7       	in	r24, 0x35	; 53
     3c8:	82 60       	ori	r24, 0x02	; 2
     3ca:	85 bf       	out	0x35, r24	; 53
						  break;
				  }
				/* Enable THe InT 0 */
				SET_Bit(GICR,INT0);	
     3cc:	8b b7       	in	r24, 0x3b	; 59
     3ce:	80 64       	ori	r24, 0x40	; 64
     3d0:	8b bf       	out	0x3b, r24	; 59
				break;
     3d2:	08 95       	ret
		  case EXINT_INT1 :
				 switch (Mode)
     3d4:	61 30       	cpi	r22, 0x01	; 1
     3d6:	71 f0       	breq	.+28     	; 0x3f4 <EXTINT_InterruptInit+0x80>
     3d8:	61 30       	cpi	r22, 0x01	; 1
     3da:	28 f0       	brcs	.+10     	; 0x3e6 <EXTINT_InterruptInit+0x72>
     3dc:	62 30       	cpi	r22, 0x02	; 2
     3de:	89 f0       	breq	.+34     	; 0x402 <EXTINT_InterruptInit+0x8e>
     3e0:	63 30       	cpi	r22, 0x03	; 3
     3e2:	e1 f4       	brne	.+56     	; 0x41c <EXTINT_InterruptInit+0xa8>
     3e4:	15 c0       	rjmp	.+42     	; 0x410 <EXTINT_InterruptInit+0x9c>
				 {
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC10);
     3e6:	85 b7       	in	r24, 0x35	; 53
     3e8:	8b 7f       	andi	r24, 0xFB	; 251
     3ea:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC11);
     3ec:	85 b7       	in	r24, 0x35	; 53
     3ee:	87 7f       	andi	r24, 0xF7	; 247
     3f0:	85 bf       	out	0x35, r24	; 53
						  break;
     3f2:	14 c0       	rjmp	.+40     	; 0x41c <EXTINT_InterruptInit+0xa8>
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC11);
     3f4:	85 b7       	in	r24, 0x35	; 53
     3f6:	88 60       	ori	r24, 0x08	; 8
     3f8:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC10);
     3fa:	85 b7       	in	r24, 0x35	; 53
     3fc:	8b 7f       	andi	r24, 0xFB	; 251
     3fe:	85 bf       	out	0x35, r24	; 53
						  break;
     400:	0d c0       	rjmp	.+26     	; 0x41c <EXTINT_InterruptInit+0xa8>
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC11);
     402:	85 b7       	in	r24, 0x35	; 53
     404:	87 7f       	andi	r24, 0xF7	; 247
     406:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC10);
     408:	85 b7       	in	r24, 0x35	; 53
     40a:	84 60       	ori	r24, 0x04	; 4
     40c:	85 bf       	out	0x35, r24	; 53
						  break;
     40e:	06 c0       	rjmp	.+12     	; 0x41c <EXTINT_InterruptInit+0xa8>
					 case EXINT_RisingEdge :
						  SET_Bit(MCUCR,ISC11);
     410:	85 b7       	in	r24, 0x35	; 53
     412:	88 60       	ori	r24, 0x08	; 8
     414:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC10);
     416:	85 b7       	in	r24, 0x35	; 53
     418:	84 60       	ori	r24, 0x04	; 4
     41a:	85 bf       	out	0x35, r24	; 53
					break;
				 }
				 /* Enable THe InT 0 */
				 SET_Bit(GICR,INT1);
     41c:	8b b7       	in	r24, 0x3b	; 59
     41e:	80 68       	ori	r24, 0x80	; 128
     420:	8b bf       	out	0x3b, r24	; 59
				 break;
     422:	08 95       	ret
		  case EXINT_INT2 :
			   switch (Mode)
     424:	62 30       	cpi	r22, 0x02	; 2
     426:	19 f0       	breq	.+6      	; 0x42e <EXTINT_InterruptInit+0xba>
     428:	63 30       	cpi	r22, 0x03	; 3
     42a:	41 f4       	brne	.+16     	; 0x43c <EXTINT_InterruptInit+0xc8>
     42c:	04 c0       	rjmp	.+8      	; 0x436 <EXTINT_InterruptInit+0xc2>
			   {
				   case EXINT_FallingEdge :
						RESET_Bit(MCUCSR,ISC2);
     42e:	84 b7       	in	r24, 0x34	; 52
     430:	8f 7b       	andi	r24, 0xBF	; 191
     432:	84 bf       	out	0x34, r24	; 52
						break;
     434:	03 c0       	rjmp	.+6      	; 0x43c <EXTINT_InterruptInit+0xc8>
				   case EXINT_RisingEdge :
						SET_Bit(MCUCSR,ISC2);
     436:	84 b7       	in	r24, 0x34	; 52
     438:	80 64       	ori	r24, 0x40	; 64
     43a:	84 bf       	out	0x34, r24	; 52
				  case EXINT_LowLevel :
				  case EXINT_Toggle :
				  break;
			   }
			   /* Enable THe InT 0 */
			   SET_Bit(GICR,INT2);
     43c:	8b b7       	in	r24, 0x3b	; 59
     43e:	80 62       	ori	r24, 0x20	; 32
     440:	8b bf       	out	0x3b, r24	; 59
     442:	08 95       	ret

00000444 <__vector_12>:

SPI_Configuration SPI0 = {.SPI_TransferInterrupCall = NULL};


ISR (SPI_STC_vect)
{
     444:	1f 92       	push	r1
     446:	0f 92       	push	r0
     448:	0f b6       	in	r0, 0x3f	; 63
     44a:	0f 92       	push	r0
     44c:	11 24       	eor	r1, r1
     44e:	2f 93       	push	r18
     450:	3f 93       	push	r19
     452:	4f 93       	push	r20
     454:	5f 93       	push	r21
     456:	6f 93       	push	r22
     458:	7f 93       	push	r23
     45a:	8f 93       	push	r24
     45c:	9f 93       	push	r25
     45e:	af 93       	push	r26
     460:	bf 93       	push	r27
     462:	ef 93       	push	r30
     464:	ff 93       	push	r31
	if (SPI0.SPI_TransferInterrupCall != NULL)
     466:	e0 91 4f 02 	lds	r30, 0x024F
     46a:	f0 91 50 02 	lds	r31, 0x0250
     46e:	30 97       	sbiw	r30, 0x00	; 0
     470:	09 f0       	breq	.+2      	; 0x474 <__vector_12+0x30>
	{
		SPI0.SPI_TransferInterrupCall();
     472:	09 95       	icall
	}
}
     474:	ff 91       	pop	r31
     476:	ef 91       	pop	r30
     478:	bf 91       	pop	r27
     47a:	af 91       	pop	r26
     47c:	9f 91       	pop	r25
     47e:	8f 91       	pop	r24
     480:	7f 91       	pop	r23
     482:	6f 91       	pop	r22
     484:	5f 91       	pop	r21
     486:	4f 91       	pop	r20
     488:	3f 91       	pop	r19
     48a:	2f 91       	pop	r18
     48c:	0f 90       	pop	r0
     48e:	0f be       	out	0x3f, r0	; 63
     490:	0f 90       	pop	r0
     492:	1f 90       	pop	r1
     494:	18 95       	reti

00000496 <SPI_Intiat>:


void SPI_Intiat(void)
{
	/* at the First We Make The 2 Reg Of The SPI All 0 */
	SPCR = 0;
     496:	1d b8       	out	0x0d, r1	; 13
	SPSR = 0;
     498:	1e b8       	out	0x0e, r1	; 14
	switch (SPI0.EnableControl)
     49a:	80 91 4a 02 	lds	r24, 0x024A
     49e:	81 30       	cpi	r24, 0x01	; 1
     4a0:	09 f0       	breq	.+2      	; 0x4a4 <SPI_Intiat+0xe>
     4a2:	72 c0       	rjmp	.+228    	; 0x588 <SPI_Intiat+0xf2>
		case SPI_Disable :
		/* In this Case We Should Put Bit Of the SPE In SPCR 0 And We Already Make All the Reg By 0 */
		break;
		case SPI_Enable :
		/* Configure The SPI Communication Setting */
		switch (SPI0.ModeSelect)
     4a4:	80 91 4b 02 	lds	r24, 0x024B
     4a8:	88 23       	and	r24, r24
     4aa:	19 f0       	breq	.+6      	; 0x4b2 <SPI_Intiat+0x1c>
     4ac:	81 30       	cpi	r24, 0x01	; 1
     4ae:	39 f5       	brne	.+78     	; 0x4fe <SPI_Intiat+0x68>
     4b0:	07 c0       	rjmp	.+14     	; 0x4c0 <SPI_Intiat+0x2a>
		{
			case SPI_SLAVE :
			/* Make The Pin MISO As Output */
			//DDRB |= (1<<MISO);
			DIO_pinConfiguration(GPIOB, MISO, Output);
     4b2:	86 e3       	ldi	r24, 0x36	; 54
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	66 e0       	ldi	r22, 0x06	; 6
     4b8:	42 e0       	ldi	r20, 0x02	; 2
     4ba:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
			break;
     4be:	1f c0       	rjmp	.+62     	; 0x4fe <SPI_Intiat+0x68>
			case SPI_MASTER :
			/* Set the Bit MSTR In The Reg SPCR */
			//SPCR |= (1<<MSTR);
			SET_Bit(SPCR,MSTR);
     4c0:	6c 9a       	sbi	0x0d, 4	; 13
			/* Make The Default Pin SCK , SS , MOSI an Output */
			//DDRB |= (1<<MOSI) | (1<<SS) | (1<<SCK);
			DIO_pinConfiguration(GPIOB, MOSI, Output);
     4c2:	86 e3       	ldi	r24, 0x36	; 54
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	65 e0       	ldi	r22, 0x05	; 5
     4c8:	42 e0       	ldi	r20, 0x02	; 2
     4ca:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
			DIO_pinConfiguration(GPIOB, SS, Output);
     4ce:	86 e3       	ldi	r24, 0x36	; 54
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	64 e0       	ldi	r22, 0x04	; 4
     4d4:	42 e0       	ldi	r20, 0x02	; 2
     4d6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
			DIO_pinConfiguration(GPIOB, SCK, Output);
     4da:	86 e3       	ldi	r24, 0x36	; 54
     4dc:	90 e0       	ldi	r25, 0x00	; 0
     4de:	67 e0       	ldi	r22, 0x07	; 7
     4e0:	42 e0       	ldi	r20, 0x02	; 2
     4e2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
			/* Make The Pins MOSI, SS  As Default State HIGH */
			//PORTB |= (1<<SS) | (1<<MOSI); 
			DIO_pinWrite(GPIOB, MOSI, HIGH);
     4e6:	86 e3       	ldi	r24, 0x36	; 54
     4e8:	90 e0       	ldi	r25, 0x00	; 0
     4ea:	65 e0       	ldi	r22, 0x05	; 5
     4ec:	41 e0       	ldi	r20, 0x01	; 1
     4ee:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
			DIO_pinWrite(GPIOB, SS, HIGH);
     4f2:	86 e3       	ldi	r24, 0x36	; 54
     4f4:	90 e0       	ldi	r25, 0x00	; 0
     4f6:	64 e0       	ldi	r22, 0x04	; 4
     4f8:	41 e0       	ldi	r20, 0x01	; 1
     4fa:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
			break;
		}
		switch (SPI0.DataOreder)
     4fe:	80 91 4d 02 	lds	r24, 0x024D
     502:	81 30       	cpi	r24, 0x01	; 1
     504:	09 f4       	brne	.+2      	; 0x508 <SPI_Intiat+0x72>
			case SPI_MSB :
			/* In this Case We Should Put Bit Of the DORD In SPCR 0 And We Already Make All the Reg By 0 */
			break;
			case SPI_LSB :
			//SPCR |= (1<<DORD);
			SET_Bit(SPCR, DORD);
     506:	6d 9a       	sbi	0x0d, 5	; 13
			break;
		}
		switch (SPI0.InterruptState)
     508:	80 91 4c 02 	lds	r24, 0x024C
     50c:	81 30       	cpi	r24, 0x01	; 1
     50e:	09 f4       	brne	.+2      	; 0x512 <SPI_Intiat+0x7c>
			case SPI_InterruptDisable:
			/* In this Case We Should Put Bit Of the SPIE In SPCR 0 And We Already Make All the Reg By 0 */
			break;
			case SPI_InterruptEnable:
			//SPCR |= (1<<SPIE);
			SET_Bit(SPCR, SPIE);
     510:	6f 9a       	sbi	0x0d, 7	; 13
			break;
		}
		switch (SPI0.ClkMode)
     512:	80 91 4e 02 	lds	r24, 0x024E
     516:	82 30       	cpi	r24, 0x02	; 2
     518:	31 f0       	breq	.+12     	; 0x526 <SPI_Intiat+0x90>
     51a:	83 30       	cpi	r24, 0x03	; 3
     51c:	61 f0       	breq	.+24     	; 0x536 <SPI_Intiat+0xa0>
     51e:	81 30       	cpi	r24, 0x01	; 1
     520:	91 f4       	brne	.+36     	; 0x546 <SPI_Intiat+0xb0>
			/* In this Case We Should Put Bit Of the CPOL,CPHA In SPCR 0 And We Already Make All the Reg By 0 */
			break;
			/* Setup(L) On Rising Sample On The Falling(T) */
			case SPI_ClkMode1:
			//SPCR |= (1<<CPHA);
			SET_Bit(SPCR, CPHA);
     522:	6a 9a       	sbi	0x0d, 2	; 13
			break;
     524:	10 c0       	rjmp	.+32     	; 0x546 <SPI_Intiat+0xb0>
			/* Sample(T) On Rising Setup(L) On the Falling */
			case SPI_ClkMode2:
			//SPCR |= (1<<CPOL);
			SET_Bit(SPCR, CPOL);
     526:	6b 9a       	sbi	0x0d, 3	; 13
			 * Note : if Used SPI Mode 3 or Mode 2 (CLK IDLE STATE = HIGH)
			 * in Some MicroControllers we must Explicitly State that The Default clk pin state is High 
			 * By Setting the pin to Output with a High Value 
			 */
			//PORTB |= (1<<SCK);
			DIO_pinWrite(GPIOB, SCK, HIGH);
     528:	86 e3       	ldi	r24, 0x36	; 54
     52a:	90 e0       	ldi	r25, 0x00	; 0
     52c:	67 e0       	ldi	r22, 0x07	; 7
     52e:	41 e0       	ldi	r20, 0x01	; 1
     530:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
			break;
     534:	08 c0       	rjmp	.+16     	; 0x546 <SPI_Intiat+0xb0>
			/* Setup(T) On Rising Sample On The Falling(L) */
			case SPI_ClkMode3:
			//SPCR |= (1<<CPHA) | (1<<CPOL);
			SET_Bit(SPCR, CPHA);
     536:	6a 9a       	sbi	0x0d, 2	; 13
			SET_Bit(SPCR, CPOL);
     538:	6b 9a       	sbi	0x0d, 3	; 13
			//PORTB |= (1<<SCK);
			DIO_pinWrite(GPIOB, SCK, HIGH);
     53a:	86 e3       	ldi	r24, 0x36	; 54
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	67 e0       	ldi	r22, 0x07	; 7
     540:	41 e0       	ldi	r20, 0x01	; 1
     542:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
			break;
		}
		switch (SPI0.SCKFreq)
     546:	80 91 51 02 	lds	r24, 0x0251
     54a:	83 30       	cpi	r24, 0x03	; 3
     54c:	99 f0       	breq	.+38     	; 0x574 <SPI_Intiat+0xde>
     54e:	84 30       	cpi	r24, 0x04	; 4
     550:	28 f4       	brcc	.+10     	; 0x55c <SPI_Intiat+0xc6>
     552:	88 23       	and	r24, r24
     554:	51 f0       	breq	.+20     	; 0x56a <SPI_Intiat+0xd4>
     556:	82 30       	cpi	r24, 0x02	; 2
     558:	b1 f4       	brne	.+44     	; 0x586 <SPI_Intiat+0xf0>
     55a:	09 c0       	rjmp	.+18     	; 0x56e <SPI_Intiat+0xd8>
     55c:	85 30       	cpi	r24, 0x05	; 5
     55e:	79 f0       	breq	.+30     	; 0x57e <SPI_Intiat+0xe8>
     560:	85 30       	cpi	r24, 0x05	; 5
     562:	50 f0       	brcs	.+20     	; 0x578 <SPI_Intiat+0xe2>
     564:	86 30       	cpi	r24, 0x06	; 6
     566:	79 f4       	brne	.+30     	; 0x586 <SPI_Intiat+0xf0>
     568:	0c c0       	rjmp	.+24     	; 0x582 <SPI_Intiat+0xec>
		{
			/* Get From The Table 58 In Page 137 In Data sheet */
			case SPI_FCPU_By_2:
			//SPSR |= (1<<SPI2X);
			SET_Bit(SPSR, SPI2X);
     56a:	70 9a       	sbi	0x0e, 0	; 14
			break;
     56c:	0c c0       	rjmp	.+24     	; 0x586 <SPI_Intiat+0xf0>
			/* In this Case We Should Put Bit Of the SPR0,SPR1,SPI2X In SPCR 0 And We Already Make All the Reg By 0 */
			break;
			case SPI_FCPU_By_8:
			//SPSR |= (1<<SPI2X);
			//SPCR |= (1<<SPR0);
			SET_Bit(SPSR, SPI2X);
     56e:	70 9a       	sbi	0x0e, 0	; 14
			SET_Bit(SPCR, SPR0);
     570:	68 9a       	sbi	0x0d, 0	; 13
			break;
     572:	09 c0       	rjmp	.+18     	; 0x586 <SPI_Intiat+0xf0>
			case SPI_FCPU_By_16:
			//SPCR |= (1<<SPR0);
			SET_Bit(SPCR, SPR0);
     574:	68 9a       	sbi	0x0d, 0	; 13
			break;
     576:	07 c0       	rjmp	.+14     	; 0x586 <SPI_Intiat+0xf0>
			case SPI_FCPU_By_32:
			//SPSR |= (1<<SPI2X);
			//SPCR |= (1<<SPR1);
			SET_Bit(SPSR, SPI2X);
     578:	70 9a       	sbi	0x0e, 0	; 14
			SET_Bit(SPCR, SPR1);
     57a:	69 9a       	sbi	0x0d, 1	; 13
			break;
     57c:	04 c0       	rjmp	.+8      	; 0x586 <SPI_Intiat+0xf0>
			case SPI_FCPU_By_64:
			//SPCR |= (1<<SPR1);
			SET_Bit(SPCR, SPR1);
     57e:	69 9a       	sbi	0x0d, 1	; 13
			break;
     580:	02 c0       	rjmp	.+4      	; 0x586 <SPI_Intiat+0xf0>
			case SPI_FCPU_By_128:
			//SPCR |= (1<<SPR0) | (1<<SPR1);
			SET_Bit(SPCR, SPR0);
     582:	68 9a       	sbi	0x0d, 0	; 13
			SET_Bit(SPCR, SPR1);
     584:	69 9a       	sbi	0x0d, 1	; 13
			break;
		}
		/* Enable SPI Communication */
		SPCR |= (1<<SPE);		
     586:	6e 9a       	sbi	0x0d, 6	; 13
     588:	08 95       	ret

0000058a <Exchange_Byte_Blocking>:


unsigned char Exchange_Byte_Blocking(unsigned char Data)
{
	/* Transmit Data Using SPI */
	SPDR = Data;
     58a:	8f b9       	out	0x0f, r24	; 15
	
	/* Chick If The Write Collision Error Occurred */
	if ((READ_Bit(SPSR, WCOL)) != 0)
     58c:	76 9b       	sbis	0x0e, 6	; 14
     58e:	03 c0       	rjmp	.+6      	; 0x596 <Exchange_Byte_Blocking+0xc>
	{
		SPI0.ErrorType = SPI_WriteColisionError;
     590:	81 e0       	ldi	r24, 0x01	; 1
     592:	80 93 52 02 	sts	0x0252, r24
	}
	
	/* Stuck Until The Transmission Is End */
	while ((READ_Bit(SPSR,SPIF)) == 0) {};
     596:	77 9b       	sbis	0x0e, 7	; 14
     598:	fe cf       	rjmp	.-4      	; 0x596 <Exchange_Byte_Blocking+0xc>
	
	/* Return Rx Data */
	return SPDR ;
     59a:	8f b1       	in	r24, 0x0f	; 15
}	
     59c:	08 95       	ret

0000059e <Exchange_Byte_NoneBlocking>:
unsigned char Exchange_Byte_NoneBlocking(unsigned char Data)
{
	/* Transmit Data Using SPI */
	SPDR = Data;
     59e:	8f b9       	out	0x0f, r24	; 15
	
	/* Chick If The Write Collision Error Occurred */
	if ((READ_Bit(SPSR, WCOL)) != 0)
     5a0:	76 9b       	sbis	0x0e, 6	; 14
     5a2:	03 c0       	rjmp	.+6      	; 0x5aa <Exchange_Byte_NoneBlocking+0xc>
	{
		SPI0.ErrorType = SPI_WriteColisionError;
     5a4:	81 e0       	ldi	r24, 0x01	; 1
     5a6:	80 93 52 02 	sts	0x0252, r24
	}
	
	/* Return Rx Data */
	return SPDR ;
     5aa:	8f b1       	in	r24, 0x0f	; 15
}
     5ac:	08 95       	ret

000005ae <TIMER_INTIATE>:
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
		unsigned char TIMASK_Temp = 0x00;
		
		/* Set up the Timer The User Select */
		switch(T.timer_Number)
     5ae:	66 23       	and	r22, r22
     5b0:	21 f0       	breq	.+8      	; 0x5ba <TIMER_INTIATE+0xc>
     5b2:	61 30       	cpi	r22, 0x01	; 1
     5b4:	09 f0       	breq	.+2      	; 0x5b8 <TIMER_INTIATE+0xa>
     5b6:	87 c0       	rjmp	.+270    	; 0x6c6 <TIMER_INTIATE+0x118>
     5b8:	40 c0       	rjmp	.+128    	; 0x63a <TIMER_INTIATE+0x8c>
		{
			case Timer0:
				/* Set Up The Timer Mode By bit WGM01 WGM00 In The TCCR */
				switch (T.timer_mode)
     5ba:	73 30       	cpi	r23, 0x03	; 3
     5bc:	31 f0       	breq	.+12     	; 0x5ca <TIMER_INTIATE+0x1c>
     5be:	74 30       	cpi	r23, 0x04	; 4
     5c0:	31 f0       	breq	.+12     	; 0x5ce <TIMER_INTIATE+0x20>
     5c2:	71 30       	cpi	r23, 0x01	; 1
     5c4:	31 f0       	breq	.+12     	; 0x5d2 <TIMER_INTIATE+0x24>
 
 
    void TIMER_INTIATE(TIMER_DATATYPE T)
	{
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
     5c6:	20 e0       	ldi	r18, 0x00	; 0
     5c8:	05 c0       	rjmp	.+10     	; 0x5d4 <TIMER_INTIATE+0x26>
						 SET_Bit(TCCR_Temp,WGM01);
						 RESET_Bit(TCCR_Temp, WGM00);
					break;
					case Timer_Fast_PWM_Mode:
						 SET_Bit(TCCR_Temp,WGM00);
						 SET_Bit(TCCR_Temp,WGM01);
     5ca:	28 e4       	ldi	r18, 0x48	; 72
					break;
     5cc:	03 c0       	rjmp	.+6      	; 0x5d4 <TIMER_INTIATE+0x26>
					case Timer_PhaceCorrect_PWM_Mode:
						 SET_Bit(TCCR_Temp,WGM00);
						 RESET_Bit(TCCR_Temp, WGM01);
     5ce:	20 e4       	ldi	r18, 0x40	; 64
					break;
     5d0:	01 c0       	rjmp	.+2      	; 0x5d4 <TIMER_INTIATE+0x26>
						 /* It Is The Normal Mode So No Change Will happened On The Bit */
				 
					break;
					case Timer_CTC_Mode:
						 SET_Bit(TCCR_Temp,WGM01);
						 RESET_Bit(TCCR_Temp, WGM00);
     5d2:	28 e0       	ldi	r18, 0x08	; 8
					default:
					break;
				}
		
				/* Set Up The Timer Clock Frequency By The Bit CS00, CS01 , CS02 In The TCCR */
				switch(T.timer_CLK)
     5d4:	87 30       	cpi	r24, 0x07	; 7
     5d6:	c9 f0       	breq	.+50     	; 0x60a <TIMER_INTIATE+0x5c>
     5d8:	88 30       	cpi	r24, 0x08	; 8
     5da:	38 f4       	brcc	.+14     	; 0x5ea <TIMER_INTIATE+0x3c>
     5dc:	83 30       	cpi	r24, 0x03	; 3
     5de:	79 f0       	breq	.+30     	; 0x5fe <TIMER_INTIATE+0x50>
     5e0:	84 30       	cpi	r24, 0x04	; 4
     5e2:	81 f0       	breq	.+32     	; 0x604 <TIMER_INTIATE+0x56>
     5e4:	81 30       	cpi	r24, 0x01	; 1
     5e6:	d9 f4       	brne	.+54     	; 0x61e <TIMER_INTIATE+0x70>
     5e8:	07 c0       	rjmp	.+14     	; 0x5f8 <TIMER_INTIATE+0x4a>
     5ea:	89 30       	cpi	r24, 0x09	; 9
     5ec:	a1 f0       	breq	.+40     	; 0x616 <TIMER_INTIATE+0x68>
     5ee:	89 30       	cpi	r24, 0x09	; 9
     5f0:	78 f0       	brcs	.+30     	; 0x610 <TIMER_INTIATE+0x62>
     5f2:	8a 30       	cpi	r24, 0x0A	; 10
     5f4:	a1 f4       	brne	.+40     	; 0x61e <TIMER_INTIATE+0x70>
     5f6:	12 c0       	rjmp	.+36     	; 0x61c <TIMER_INTIATE+0x6e>
					case Timer_NoCLK_Source:
						/* It SI The Default State At All Bit Equal 0 */
						/* In This Case The Timer Gets Its Clock From External Device */
					break;
					case Timer_Fcpu:
						 SET_Bit(TCCR_Temp,CS00);
     5f8:	21 60       	ori	r18, 0x01	; 1
						 RESET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
     5fa:	29 7f       	andi	r18, 0xF9	; 249
					break;
     5fc:	10 c0       	rjmp	.+32     	; 0x61e <TIMER_INTIATE+0x70>
					case Timer_Fcpu_Div8:
						 RESET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
     5fe:	28 7f       	andi	r18, 0xF8	; 248
						 RESET_Bit(TCCR_Temp,CS02);
     600:	22 60       	ori	r18, 0x02	; 2
					break;
     602:	0d c0       	rjmp	.+26     	; 0x61e <TIMER_INTIATE+0x70>
					case Timer_Fcpu_Div64:
						 SET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
     604:	23 60       	ori	r18, 0x03	; 3
						 RESET_Bit(TCCR_Temp,CS02);
     606:	2b 7f       	andi	r18, 0xFB	; 251
					break;
     608:	0a c0       	rjmp	.+20     	; 0x61e <TIMER_INTIATE+0x70>
					case Timer_Fcpu_Div256:
						 RESET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
     60a:	2c 7f       	andi	r18, 0xFC	; 252
						 SET_Bit(TCCR_Temp,CS02);
     60c:	24 60       	ori	r18, 0x04	; 4
					break;
     60e:	07 c0       	rjmp	.+14     	; 0x61e <TIMER_INTIATE+0x70>
					case Timer_Fcpu_Div1024:
						 SET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
     610:	28 7f       	andi	r18, 0xF8	; 248
						 SET_Bit(TCCR_Temp,CS02);
     612:	25 60       	ori	r18, 0x05	; 5
					break;
     614:	04 c0       	rjmp	.+8      	; 0x61e <TIMER_INTIATE+0x70>
					case Timer_FallingEdge:
						 RESET_Bit(TCCR_Temp,CS00);
     616:	2e 7f       	andi	r18, 0xFE	; 254
						 SET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
     618:	26 60       	ori	r18, 0x06	; 6
					break;
     61a:	01 c0       	rjmp	.+2      	; 0x61e <TIMER_INTIATE+0x70>
					case Timer_RisingEdge:
						 SET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
     61c:	27 60       	ori	r18, 0x07	; 7
				   default:
				   break;
				}
		
				/* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
				switch(T.TimerINT_Source)
     61e:	91 30       	cpi	r25, 0x01	; 1
     620:	19 f0       	breq	.+6      	; 0x628 <TIMER_INTIATE+0x7a>
     622:	92 30       	cpi	r25, 0x02	; 2
     624:	41 f4       	brne	.+16     	; 0x636 <TIMER_INTIATE+0x88>
     626:	04 c0       	rjmp	.+8      	; 0x630 <TIMER_INTIATE+0x82>
				{
					case Timer_Overflow_Interrupt:
						 /* This Interrupt happened when the TCNT reach its Max then return to zero again */ 
						 SET_Bit(TIMSK,TOIE0);
     628:	89 b7       	in	r24, 0x39	; 57
     62a:	81 60       	ori	r24, 0x01	; 1
     62c:	89 bf       	out	0x39, r24	; 57
					break;
     62e:	03 c0       	rjmp	.+6      	; 0x636 <TIMER_INTIATE+0x88>
					case Timer_TopCTC_Interrupt:
						 /* This Interrupt happened When The TCNT Reach The Value Equal The Value OnThe OCR and Return To Zero */
						 SET_Bit(TIMSK,OCIE0);
     630:	89 b7       	in	r24, 0x39	; 57
     632:	82 60       	ori	r24, 0x02	; 2
     634:	89 bf       	out	0x39, r24	; 57
					break;
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
     636:	23 bf       	out	0x33, r18	; 51
		break;
     638:	46 c0       	rjmp	.+140    	; 0x6c6 <TIMER_INTIATE+0x118>
		case Timer2:
		     /* Set Up The Timer Mode By bit WGM21 WGM20 In The TCCR */
		     switch (T.timer_mode)
     63a:	73 30       	cpi	r23, 0x03	; 3
     63c:	31 f0       	breq	.+12     	; 0x64a <TIMER_INTIATE+0x9c>
     63e:	74 30       	cpi	r23, 0x04	; 4
     640:	31 f0       	breq	.+12     	; 0x64e <TIMER_INTIATE+0xa0>
     642:	71 30       	cpi	r23, 0x01	; 1
     644:	31 f0       	breq	.+12     	; 0x652 <TIMER_INTIATE+0xa4>
 
 
    void TIMER_INTIATE(TIMER_DATATYPE T)
	{
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
     646:	20 e0       	ldi	r18, 0x00	; 0
     648:	05 c0       	rjmp	.+10     	; 0x654 <TIMER_INTIATE+0xa6>
			     SET_Bit(TCCR_Temp,WGM21);
			     RESET_Bit(TCCR_Temp, WGM20);
			     break;
			     case Timer_Fast_PWM_Mode:
			     SET_Bit(TCCR_Temp,WGM20);
			     SET_Bit(TCCR_Temp,WGM21);
     64a:	28 e4       	ldi	r18, 0x48	; 72
			     break;
     64c:	03 c0       	rjmp	.+6      	; 0x654 <TIMER_INTIATE+0xa6>
			     case Timer_PhaceCorrect_PWM_Mode:
			     SET_Bit(TCCR_Temp,WGM20);
			     RESET_Bit(TCCR_Temp, WGM21);
     64e:	20 e4       	ldi	r18, 0x40	; 64
			     break;
     650:	01 c0       	rjmp	.+2      	; 0x654 <TIMER_INTIATE+0xa6>
			     /* It Is The Normal Mode So No Change Will happened On The Bit */
			     
			     break;
			     case Timer_CTC_Mode:
			     SET_Bit(TCCR_Temp,WGM21);
			     RESET_Bit(TCCR_Temp, WGM20);
     652:	28 e0       	ldi	r18, 0x08	; 8
			     default:
			     break;
		     }
		     
		     /* Set Up The Timer Clock Frequency By The Bit CS20, CS21 , CS22 In The TCCR2 */
		     switch(T.timer_CLK)
     654:	84 30       	cpi	r24, 0x04	; 4
     656:	01 f1       	breq	.+64     	; 0x698 <TIMER_INTIATE+0xea>
     658:	85 30       	cpi	r24, 0x05	; 5
     65a:	38 f4       	brcc	.+14     	; 0x66a <TIMER_INTIATE+0xbc>
     65c:	82 30       	cpi	r24, 0x02	; 2
     65e:	89 f0       	breq	.+34     	; 0x682 <TIMER_INTIATE+0xd4>
     660:	83 30       	cpi	r24, 0x03	; 3
     662:	a0 f4       	brcc	.+40     	; 0x68c <TIMER_INTIATE+0xde>
     664:	81 30       	cpi	r24, 0x01	; 1
     666:	11 f5       	brne	.+68     	; 0x6ac <TIMER_INTIATE+0xfe>
     668:	09 c0       	rjmp	.+18     	; 0x67c <TIMER_INTIATE+0xce>
     66a:	86 30       	cpi	r24, 0x06	; 6
     66c:	c1 f0       	breq	.+48     	; 0x69e <TIMER_INTIATE+0xf0>
     66e:	86 30       	cpi	r24, 0x06	; 6
     670:	80 f0       	brcs	.+32     	; 0x692 <TIMER_INTIATE+0xe4>
     672:	87 30       	cpi	r24, 0x07	; 7
     674:	b9 f0       	breq	.+46     	; 0x6a4 <TIMER_INTIATE+0xf6>
     676:	88 30       	cpi	r24, 0x08	; 8
     678:	c9 f4       	brne	.+50     	; 0x6ac <TIMER_INTIATE+0xfe>
     67a:	17 c0       	rjmp	.+46     	; 0x6aa <TIMER_INTIATE+0xfc>
		     {
			     case Timer_NoCLK_Source:
			     /* It SI The Default State At All Bit Equal 0 */
			     break;
			     case Timer_Fcpu:
			     SET_Bit(TCCR_Temp,CS20);
     67c:	21 60       	ori	r18, 0x01	; 1
			     RESET_Bit(TCCR_Temp,CS21);
			     RESET_Bit(TCCR_Temp,CS22);
     67e:	29 7f       	andi	r18, 0xF9	; 249
			     break;
     680:	15 c0       	rjmp	.+42     	; 0x6ac <TIMER_INTIATE+0xfe>
				 case Timer2_OneSec_CLK:
				      /* In This Case To Get The Clock Exactly At One Sec We Used An External Clock With Value 32768Hz At Timer 2 Only Connect To the Pin 6 & 7 at Port C 
					   * Set the Pin AS2 At The Register ASSR To Make The Clock Source From The External Crystal 
					   *  Prescaler Value Will Used is 128 So 
					   */
					  ASSR = 0x08;
     682:	88 e0       	ldi	r24, 0x08	; 8
     684:	82 bd       	out	0x22, r24	; 34
					  SET_Bit(TCCR_Temp,CS20);
					  RESET_Bit(TCCR_Temp,CS21);
     686:	28 7f       	andi	r18, 0xF8	; 248
					  SET_Bit(TCCR_Temp,CS22);
     688:	25 60       	ori	r18, 0x05	; 5
				 break;
     68a:	10 c0       	rjmp	.+32     	; 0x6ac <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div8:
			     RESET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
     68c:	28 7f       	andi	r18, 0xF8	; 248
			     RESET_Bit(TCCR_Temp,CS22);
     68e:	22 60       	ori	r18, 0x02	; 2
			     break;
     690:	0d c0       	rjmp	.+26     	; 0x6ac <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div32:
			     SET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
     692:	23 60       	ori	r18, 0x03	; 3
			     RESET_Bit(TCCR_Temp,CS22);
     694:	2b 7f       	andi	r18, 0xFB	; 251
			     break;
     696:	0a c0       	rjmp	.+20     	; 0x6ac <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div64:
			     RESET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
     698:	2c 7f       	andi	r18, 0xFC	; 252
			     SET_Bit(TCCR_Temp,CS22);
     69a:	24 60       	ori	r18, 0x04	; 4
			     break;
     69c:	07 c0       	rjmp	.+14     	; 0x6ac <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div128:
			     SET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
     69e:	28 7f       	andi	r18, 0xF8	; 248
			     SET_Bit(TCCR_Temp,CS22);
     6a0:	25 60       	ori	r18, 0x05	; 5
			     break;
     6a2:	04 c0       	rjmp	.+8      	; 0x6ac <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div256:
			     RESET_Bit(TCCR_Temp,CS20);
     6a4:	2e 7f       	andi	r18, 0xFE	; 254
			     SET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
     6a6:	26 60       	ori	r18, 0x06	; 6
			     break;
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div1024:
			     SET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
     6aa:	27 60       	ori	r18, 0x07	; 7
				 /* If The User Select Else This Cases Handle An Error Massage */
			     break;
		     }
		     
		     /* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
		     switch(T.TimerINT_Source)
     6ac:	91 30       	cpi	r25, 0x01	; 1
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <TIMER_INTIATE+0x108>
     6b0:	92 30       	cpi	r25, 0x02	; 2
     6b2:	41 f4       	brne	.+16     	; 0x6c4 <TIMER_INTIATE+0x116>
     6b4:	04 c0       	rjmp	.+8      	; 0x6be <TIMER_INTIATE+0x110>
		     {
			     case Timer_Overflow_Interrupt:
			     /* This Interrupt happened when the TCNT reach its Max then return to zero again */
			     SET_Bit(TIMSK,TOIE2);
     6b6:	89 b7       	in	r24, 0x39	; 57
     6b8:	80 64       	ori	r24, 0x40	; 64
     6ba:	89 bf       	out	0x39, r24	; 57
			     break;
     6bc:	03 c0       	rjmp	.+6      	; 0x6c4 <TIMER_INTIATE+0x116>
			     case Timer_TopCTC_Interrupt:
			     /* This Interrupt happened When The TCNT Reach The Value Equal The Value OnThe OCR and Return To Zero */
			     SET_Bit(TIMSK,OCIE2);
     6be:	89 b7       	in	r24, 0x39	; 57
     6c0:	80 68       	ori	r24, 0x80	; 128
     6c2:	89 bf       	out	0x39, r24	; 57
			     break;
			     default:
			     break;
			     
		     }
			 TCCR2 = TCCR_Temp;
     6c4:	25 bd       	out	0x25, r18	; 37
			 break;
		}
			
		
		/* Set The I Bit In The Statues Register To Enable The General Interrupt */
		SET_Bit(SREG, 7);
     6c6:	8f b7       	in	r24, 0x3f	; 63
     6c8:	80 68       	ori	r24, 0x80	; 128
     6ca:	8f bf       	out	0x3f, r24	; 63
	}					 
     6cc:	08 95       	ret

000006ce <TIMER_DELAY>:

	
		
    void TIMER_DELAY(TIMER_DATATYPE t, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     6ce:	66 23       	and	r22, r22
     6d0:	19 f0       	breq	.+6      	; 0x6d8 <TIMER_DELAY+0xa>
     6d2:	61 30       	cpi	r22, 0x01	; 1
     6d4:	21 f4       	brne	.+8      	; 0x6de <TIMER_DELAY+0x10>
     6d6:	02 c0       	rjmp	.+4      	; 0x6dc <TIMER_DELAY+0xe>
		{
			case Timer0: 
			     OCR0 = Top_Value;
     6d8:	4c bf       	out	0x3c, r20	; 60
			break;
     6da:	08 95       	ret
			case Timer2:
			     OCR2 = Top_Value;
     6dc:	43 bd       	out	0x23, r20	; 35
     6de:	08 95       	ret

000006e0 <TIMER_WAVEGEN_NPWM>:
		}
	}
	
	
	void TIMER_WAVEGEN_NPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     6e0:	cf 93       	push	r28
     6e2:	c4 2f       	mov	r28, r20
		switch (t.timer_Number)
     6e4:	66 23       	and	r22, r22
     6e6:	21 f0       	breq	.+8      	; 0x6f0 <TIMER_WAVEGEN_NPWM+0x10>
     6e8:	61 30       	cpi	r22, 0x01	; 1
     6ea:	09 f0       	breq	.+2      	; 0x6ee <TIMER_WAVEGEN_NPWM+0xe>
     6ec:	44 c0       	rjmp	.+136    	; 0x776 <TIMER_WAVEGEN_NPWM+0x96>
     6ee:	22 c0       	rjmp	.+68     	; 0x734 <TIMER_WAVEGEN_NPWM+0x54>
		{
			case Timer0 :
				/* Set The Value Of OCR0 That will Wave Change after it */
				OCR0 = Top_Value;
     6f0:	2c bf       	out	0x3c, r18	; 60
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     6f2:	86 e3       	ldi	r24, 0x36	; 54
     6f4:	90 e0       	ldi	r25, 0x00	; 0
     6f6:	63 e0       	ldi	r22, 0x03	; 3
     6f8:	42 e0       	ldi	r20, 0x02	; 2
     6fa:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
				/* Switch on the form we want the signal get out after each compare match */
				switch(wave)
     6fe:	c2 30       	cpi	r28, 0x02	; 2
     700:	59 f0       	breq	.+22     	; 0x718 <TIMER_WAVEGEN_NPWM+0x38>
     702:	c3 30       	cpi	r28, 0x03	; 3
     704:	81 f0       	breq	.+32     	; 0x726 <TIMER_WAVEGEN_NPWM+0x46>
     706:	c1 30       	cpi	r28, 0x01	; 1
     708:	b1 f5       	brne	.+108    	; 0x776 <TIMER_WAVEGEN_NPWM+0x96>
				{
					case NON:
					/* This is The Normal State when the COM00 and COM01 is cleared */
					break;
					case Toggle_PB_InCM:
						 RESET_Bit(TCCR0, COM01);
     70a:	83 b7       	in	r24, 0x33	; 51
     70c:	8f 7d       	andi	r24, 0xDF	; 223
     70e:	83 bf       	out	0x33, r24	; 51
						 SET_Bit(TCCR0, COM00);
     710:	83 b7       	in	r24, 0x33	; 51
     712:	80 61       	ori	r24, 0x10	; 16
     714:	83 bf       	out	0x33, r24	; 51
					break;
     716:	2f c0       	rjmp	.+94     	; 0x776 <TIMER_WAVEGEN_NPWM+0x96>
					case Clear_PB_InCM:
						 SET_Bit(TCCR0, COM01);
     718:	83 b7       	in	r24, 0x33	; 51
     71a:	80 62       	ori	r24, 0x20	; 32
     71c:	83 bf       	out	0x33, r24	; 51
						 RESET_Bit(TCCR0, COM00);
     71e:	83 b7       	in	r24, 0x33	; 51
     720:	8f 7e       	andi	r24, 0xEF	; 239
     722:	83 bf       	out	0x33, r24	; 51
					break;
     724:	28 c0       	rjmp	.+80     	; 0x776 <TIMER_WAVEGEN_NPWM+0x96>
					case Set_PB_InCM:
						SET_Bit(TCCR0, COM01);
     726:	83 b7       	in	r24, 0x33	; 51
     728:	80 62       	ori	r24, 0x20	; 32
     72a:	83 bf       	out	0x33, r24	; 51
						SET_Bit(TCCR0, COM00);
     72c:	83 b7       	in	r24, 0x33	; 51
     72e:	80 61       	ori	r24, 0x10	; 16
     730:	83 bf       	out	0x33, r24	; 51
						break;
     732:	21 c0       	rjmp	.+66     	; 0x776 <TIMER_WAVEGEN_NPWM+0x96>
					break;
				}
			break;
			case Timer2: 
				    /* Set The Value Of OCR2 That will Wave Change after it */
					OCR2 = Top_Value;
     734:	23 bd       	out	0x23, r18	; 35
					/* at the first we set up the pin of the wave output in the Mc as output state OC2 pin */
					DIO_pinConfiguration(GPIOD,PIN7, Output);
     736:	80 e3       	ldi	r24, 0x30	; 48
     738:	90 e0       	ldi	r25, 0x00	; 0
     73a:	67 e0       	ldi	r22, 0x07	; 7
     73c:	42 e0       	ldi	r20, 0x02	; 2
     73e:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
					/* Switch on the form we want the signal get out after each compare match */
					switch(wave)
     742:	c2 30       	cpi	r28, 0x02	; 2
     744:	59 f0       	breq	.+22     	; 0x75c <TIMER_WAVEGEN_NPWM+0x7c>
     746:	c3 30       	cpi	r28, 0x03	; 3
     748:	81 f0       	breq	.+32     	; 0x76a <TIMER_WAVEGEN_NPWM+0x8a>
     74a:	c1 30       	cpi	r28, 0x01	; 1
     74c:	a1 f4       	brne	.+40     	; 0x776 <TIMER_WAVEGEN_NPWM+0x96>
					{
						case NON:
						/* This is The Normal State when the COM00 and COM01 is cleared */
						break;
						case Toggle_PB_InCM:
							 RESET_Bit(TCCR2, COM21);
     74e:	85 b5       	in	r24, 0x25	; 37
     750:	8f 7d       	andi	r24, 0xDF	; 223
     752:	85 bd       	out	0x25, r24	; 37
							 SET_Bit(TCCR2, COM20);
     754:	85 b5       	in	r24, 0x25	; 37
     756:	80 61       	ori	r24, 0x10	; 16
     758:	85 bd       	out	0x25, r24	; 37
						break;
     75a:	0d c0       	rjmp	.+26     	; 0x776 <TIMER_WAVEGEN_NPWM+0x96>
						case Clear_PB_InCM:
							 SET_Bit(TCCR2, COM21);
     75c:	85 b5       	in	r24, 0x25	; 37
     75e:	80 62       	ori	r24, 0x20	; 32
     760:	85 bd       	out	0x25, r24	; 37
							 RESET_Bit(TCCR2, COM20);
     762:	85 b5       	in	r24, 0x25	; 37
     764:	8f 7e       	andi	r24, 0xEF	; 239
     766:	85 bd       	out	0x25, r24	; 37
						break;
     768:	06 c0       	rjmp	.+12     	; 0x776 <TIMER_WAVEGEN_NPWM+0x96>
						case Set_PB_InCM:
							SET_Bit(TCCR2, COM21);
     76a:	85 b5       	in	r24, 0x25	; 37
     76c:	80 62       	ori	r24, 0x20	; 32
     76e:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM20);
     770:	85 b5       	in	r24, 0x25	; 37
     772:	80 61       	ori	r24, 0x10	; 16
     774:	85 bd       	out	0x25, r24	; 37
			break;
			default:
			break;
		}
	
	}	
     776:	cf 91       	pop	r28
     778:	08 95       	ret

0000077a <TIMER_WAVEGEN_FASTPWM>:
	void TIMER_WAVEGEN_FASTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     77a:	cf 93       	push	r28
     77c:	c4 2f       	mov	r28, r20
		switch(t.timer_Number)
     77e:	66 23       	and	r22, r22
     780:	19 f0       	breq	.+6      	; 0x788 <TIMER_WAVEGEN_FASTPWM+0xe>
     782:	61 30       	cpi	r22, 0x01	; 1
     784:	b1 f5       	brne	.+108    	; 0x7f2 <TIMER_WAVEGEN_FASTPWM+0x78>
     786:	1b c0       	rjmp	.+54     	; 0x7be <TIMER_WAVEGEN_FASTPWM+0x44>
				  *
				  * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				  * if the user choose the inverting mode this result become the OFF time ratio 
				  * and if decide non inverting mode this ratio become the ON time ratio 
				  */
				OCR0 = Top_Value;
     788:	2c bf       	out	0x3c, r18	; 60
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     78a:	86 e3       	ldi	r24, 0x36	; 54
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	63 e0       	ldi	r22, 0x03	; 3
     790:	42 e0       	ldi	r20, 0x02	; 2
     792:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
		
				/* Note 
					* the case of COM00 , COM01 is decimal 1 is reserved ( Not use ) 
					*/
				switch(wave)
     796:	c4 30       	cpi	r28, 0x04	; 4
     798:	59 f0       	breq	.+22     	; 0x7b0 <TIMER_WAVEGEN_FASTPWM+0x36>
     79a:	c5 30       	cpi	r28, 0x05	; 5
     79c:	11 f0       	breq	.+4      	; 0x7a2 <TIMER_WAVEGEN_FASTPWM+0x28>
     79e:	cc 23       	and	r28, r28
     7a0:	41 f5       	brne	.+80     	; 0x7f2 <TIMER_WAVEGEN_FASTPWM+0x78>
					case NON:
							/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
				 
					case NonInverting_FPWM:
							/* This mode when the signal on the OC0 is cleared when happen Compare match with the value on OCR0 and Set when TCCR0  reach bottom (Overflow) */
							RESET_Bit(TCCR0, COM00);
     7a2:	83 b7       	in	r24, 0x33	; 51
     7a4:	8f 7e       	andi	r24, 0xEF	; 239
     7a6:	83 bf       	out	0x33, r24	; 51
							SET_Bit(TCCR0, COM01);
     7a8:	83 b7       	in	r24, 0x33	; 51
     7aa:	80 62       	ori	r24, 0x20	; 32
     7ac:	83 bf       	out	0x33, r24	; 51
					break;
     7ae:	21 c0       	rjmp	.+66     	; 0x7f2 <TIMER_WAVEGEN_FASTPWM+0x78>
					case Inverting_FPWM:
							/* This mode when the signal on the OC0 is set when happen Compare match with the value on OCR0 and Cleared when TCCR0  reach bottom (Overflow) */
							SET_Bit(TCCR0, COM00);
     7b0:	83 b7       	in	r24, 0x33	; 51
     7b2:	80 61       	ori	r24, 0x10	; 16
     7b4:	83 bf       	out	0x33, r24	; 51
							SET_Bit(TCCR0, COM01);
     7b6:	83 b7       	in	r24, 0x33	; 51
     7b8:	80 62       	ori	r24, 0x20	; 32
     7ba:	83 bf       	out	0x33, r24	; 51
					break;
     7bc:	1a c0       	rjmp	.+52     	; 0x7f2 <TIMER_WAVEGEN_FASTPWM+0x78>
				  *
				  * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				  * if the user choose the inverting mode this result become the OFF time ratio 
				  * and if decide non inverting mode this ratio become the ON time ratio 
				  */
				OCR2 = Top_Value;
     7be:	23 bd       	out	0x23, r18	; 35
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOD,PIN7, Output);
     7c0:	80 e3       	ldi	r24, 0x30	; 48
     7c2:	90 e0       	ldi	r25, 0x00	; 0
     7c4:	67 e0       	ldi	r22, 0x07	; 7
     7c6:	42 e0       	ldi	r20, 0x02	; 2
     7c8:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
		
				/* Note 
					* the case of COM20 , COM21 is decimal 1 is reserved ( Not use ) 
					*/
				switch(wave)
     7cc:	c4 30       	cpi	r28, 0x04	; 4
     7ce:	59 f0       	breq	.+22     	; 0x7e6 <TIMER_WAVEGEN_FASTPWM+0x6c>
     7d0:	c5 30       	cpi	r28, 0x05	; 5
     7d2:	11 f0       	breq	.+4      	; 0x7d8 <TIMER_WAVEGEN_FASTPWM+0x5e>
     7d4:	cc 23       	and	r28, r28
     7d6:	69 f4       	brne	.+26     	; 0x7f2 <TIMER_WAVEGEN_FASTPWM+0x78>
					case NON:
							/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
				 
					case NonInverting_FPWM:
							/* This mode when the signal on the OC0 is cleared when happen Compare match with the value on OCR0 and Set when TCCR0  reach bottom (Overflow) */
							RESET_Bit(TCCR2, COM20);
     7d8:	85 b5       	in	r24, 0x25	; 37
     7da:	8f 7e       	andi	r24, 0xEF	; 239
     7dc:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM21);
     7de:	85 b5       	in	r24, 0x25	; 37
     7e0:	80 62       	ori	r24, 0x20	; 32
     7e2:	85 bd       	out	0x25, r24	; 37
					break;
     7e4:	06 c0       	rjmp	.+12     	; 0x7f2 <TIMER_WAVEGEN_FASTPWM+0x78>
					case Inverting_FPWM:
							/* This mode when the signal on the OC0 is set when happen Compare match with the value on OCR0 and Cleared when TCCR0  reach bottom (Overflow) */
							SET_Bit(TCCR2, COM20);
     7e6:	85 b5       	in	r24, 0x25	; 37
     7e8:	80 61       	ori	r24, 0x10	; 16
     7ea:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM21);
     7ec:	85 b5       	in	r24, 0x25	; 37
     7ee:	80 62       	ori	r24, 0x20	; 32
     7f0:	85 bd       	out	0x25, r24	; 37
			default :
			break;
		}
		
		
	}	
     7f2:	cf 91       	pop	r28
     7f4:	08 95       	ret

000007f6 <TIMER_WAVEGEN_PHACECORRECTPWM>:
	
	
	void TIMER_WAVEGEN_PHACECORRECTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     7f6:	cf 93       	push	r28
     7f8:	c4 2f       	mov	r28, r20
		switch(t.timer_Number)
     7fa:	66 23       	and	r22, r22
     7fc:	19 f0       	breq	.+6      	; 0x804 <TIMER_WAVEGEN_PHACECORRECTPWM+0xe>
     7fe:	61 30       	cpi	r22, 0x01	; 1
     800:	b1 f5       	brne	.+108    	; 0x86e <__stack+0xf>
     802:	1b c0       	rjmp	.+54     	; 0x83a <TIMER_WAVEGEN_PHACECORRECTPWM+0x44>
				 *
				 * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				 * if the user choose Set OC0 at up counting and Clear at down counting  mode this result become the OFF time ratio 
				 * and if decide Clear OC0 at up counting and Set at down counting  mode this ratio become the ON time ratio 
				 */
				OCR0 = Top_Value;
     804:	2c bf       	out	0x3c, r18	; 60
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     806:	86 e3       	ldi	r24, 0x36	; 54
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	63 e0       	ldi	r22, 0x03	; 3
     80c:	42 e0       	ldi	r20, 0x02	; 2
     80e:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
		
				/* Note 
				 * the case of COM00 , COM01 is decimal 1 is reserved ( Not use ) 
				 */
				switch(wave)
     812:	c6 30       	cpi	r28, 0x06	; 6
     814:	21 f0       	breq	.+8      	; 0x81e <TIMER_WAVEGEN_PHACECORRECTPWM+0x28>
     816:	c7 30       	cpi	r28, 0x07	; 7
     818:	49 f0       	breq	.+18     	; 0x82c <TIMER_WAVEGEN_PHACECORRECTPWM+0x36>
     81a:	cc 23       	and	r28, r28
     81c:	41 f5       	brne	.+80     	; 0x86e <__stack+0xf>
					case NON:
					/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
			
					case ClearUp_SetDowen_PCPWM:
					/* This mode operation is the signal on the OC0 is clear when happen Compare match with the value on OCR0 at the up counting of the TCNT0 and Set when happen compare match at the down counting of the TCNT0 */
					RESET_Bit(TCCR0, COM00);
     81e:	83 b7       	in	r24, 0x33	; 51
     820:	8f 7e       	andi	r24, 0xEF	; 239
     822:	83 bf       	out	0x33, r24	; 51
					SET_Bit(TCCR0, COM01);
     824:	83 b7       	in	r24, 0x33	; 51
     826:	80 62       	ori	r24, 0x20	; 32
     828:	83 bf       	out	0x33, r24	; 51
					break;
     82a:	21 c0       	rjmp	.+66     	; 0x86e <__stack+0xf>
					case SetUp_ClearDowen_PCPWM:
					/* This mode operation is the signal on the OC0 is set when happen Compare match with the value on OCR0 at the up counting of the TCNT0 and clear when happen compare match at the down counting of the TCNT0 */
					SET_Bit(TCCR0, COM00);
     82c:	83 b7       	in	r24, 0x33	; 51
     82e:	80 61       	ori	r24, 0x10	; 16
     830:	83 bf       	out	0x33, r24	; 51
					SET_Bit(TCCR0, COM01);
     832:	83 b7       	in	r24, 0x33	; 51
     834:	80 62       	ori	r24, 0x20	; 32
     836:	83 bf       	out	0x33, r24	; 51
					break;
     838:	1a c0       	rjmp	.+52     	; 0x86e <__stack+0xf>
				 *
				 * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				 * if the user choose Set OC2 at up counting and Clear at down counting  mode this result become the OFF time ratio 
				 * and if decide Clear OC2 at up counting and Set at down counting  mode this ratio become the ON time ratio 
				 */
				OCR2 = Top_Value;
     83a:	23 bd       	out	0x23, r18	; 35
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOD,PIN7, Output);
     83c:	80 e3       	ldi	r24, 0x30	; 48
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	67 e0       	ldi	r22, 0x07	; 7
     842:	42 e0       	ldi	r20, 0x02	; 2
     844:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
		
				/* Note 
				 * the case of COM20 , COM21 is decimal 1 is reserved ( Not use ) 
				 */
				switch(wave)
     848:	c6 30       	cpi	r28, 0x06	; 6
     84a:	21 f0       	breq	.+8      	; 0x854 <TIMER_WAVEGEN_PHACECORRECTPWM+0x5e>
     84c:	c7 30       	cpi	r28, 0x07	; 7
     84e:	49 f0       	breq	.+18     	; 0x862 <__stack+0x3>
     850:	cc 23       	and	r28, r28
     852:	69 f4       	brne	.+26     	; 0x86e <__stack+0xf>
					case NON:
					/* This IS the normal mode OC2 IS disconnected when the COM20 and COM21 is cleared  */
			
					case ClearUp_SetDowen_PCPWM:
					/* This mode operation is the signal on the OC2 is clear when happen Compare match with the value on OCR2 at the up counting of the TCNT0 and Set when happen compare match at the down counting of the TCNT0 */
					RESET_Bit(TCCR2, COM20);
     854:	85 b5       	in	r24, 0x25	; 37
     856:	8f 7e       	andi	r24, 0xEF	; 239
     858:	85 bd       	out	0x25, r24	; 37
					SET_Bit(TCCR2, COM21);
     85a:	85 b5       	in	r24, 0x25	; 37
     85c:	80 62       	ori	r24, 0x20	; 32
     85e:	85 bd       	out	0x25, r24	; 37
					break;
     860:	06 c0       	rjmp	.+12     	; 0x86e <__stack+0xf>
					case SetUp_ClearDowen_PCPWM:
					/* This mode operation is the signal on the OC2 is set when happen Compare match with the value on OCR2 at the up counting of the TCNT0 and clear when happen compare match at the down counting of the TCNT0 */
					SET_Bit(TCCR2, COM20);
     862:	85 b5       	in	r24, 0x25	; 37
     864:	80 61       	ori	r24, 0x10	; 16
     866:	85 bd       	out	0x25, r24	; 37
					SET_Bit(TCCR2, COM21);
     868:	85 b5       	in	r24, 0x25	; 37
     86a:	80 62       	ori	r24, 0x20	; 32
     86c:	85 bd       	out	0x25, r24	; 37
			break;
			default: 
			
			break;
		}		
	}	
     86e:	cf 91       	pop	r28
     870:	08 95       	ret

00000872 <USART_RXC_vect>:
		 * so it should write as ISR(_vector(13)) but this is define in the AVR/Interrupt 
		*/ 					 
							 
	/* interrupt function by the RXC */						 
	 ISR (USART_RXC_vect)
	 {
     872:	1f 92       	push	r1
     874:	0f 92       	push	r0
     876:	0f b6       	in	r0, 0x3f	; 63
     878:	0f 92       	push	r0
     87a:	11 24       	eor	r1, r1
     87c:	2f 93       	push	r18
     87e:	3f 93       	push	r19
     880:	4f 93       	push	r20
     882:	5f 93       	push	r21
     884:	6f 93       	push	r22
     886:	7f 93       	push	r23
     888:	8f 93       	push	r24
     88a:	9f 93       	push	r25
     88c:	af 93       	push	r26
     88e:	bf 93       	push	r27
     890:	ef 93       	push	r30
     892:	ff 93       	push	r31
		 if (USART0.RXC_InterruptCall != NULL)
     894:	e0 91 5f 02 	lds	r30, 0x025F
     898:	f0 91 60 02 	lds	r31, 0x0260
     89c:	30 97       	sbiw	r30, 0x00	; 0
     89e:	09 f0       	breq	.+2      	; 0x8a2 <USART_RXC_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.RXC_InterruptCall();
     8a0:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     8a2:	ff 91       	pop	r31
     8a4:	ef 91       	pop	r30
     8a6:	bf 91       	pop	r27
     8a8:	af 91       	pop	r26
     8aa:	9f 91       	pop	r25
     8ac:	8f 91       	pop	r24
     8ae:	7f 91       	pop	r23
     8b0:	6f 91       	pop	r22
     8b2:	5f 91       	pop	r21
     8b4:	4f 91       	pop	r20
     8b6:	3f 91       	pop	r19
     8b8:	2f 91       	pop	r18
     8ba:	0f 90       	pop	r0
     8bc:	0f be       	out	0x3f, r0	; 63
     8be:	0f 90       	pop	r0
     8c0:	1f 90       	pop	r1
     8c2:	18 95       	reti

000008c4 <USART_TXC_vect>:
	 
	 
	 /* interrupt function by the RXC */						 
	 ISR (USART_TXC_vect)
	 {
     8c4:	1f 92       	push	r1
     8c6:	0f 92       	push	r0
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	0f 92       	push	r0
     8cc:	11 24       	eor	r1, r1
     8ce:	2f 93       	push	r18
     8d0:	3f 93       	push	r19
     8d2:	4f 93       	push	r20
     8d4:	5f 93       	push	r21
     8d6:	6f 93       	push	r22
     8d8:	7f 93       	push	r23
     8da:	8f 93       	push	r24
     8dc:	9f 93       	push	r25
     8de:	af 93       	push	r26
     8e0:	bf 93       	push	r27
     8e2:	ef 93       	push	r30
     8e4:	ff 93       	push	r31
		 if (USART0.TXC_InterruptCall != NULL)
     8e6:	e0 91 61 02 	lds	r30, 0x0261
     8ea:	f0 91 62 02 	lds	r31, 0x0262
     8ee:	30 97       	sbiw	r30, 0x00	; 0
     8f0:	09 f0       	breq	.+2      	; 0x8f4 <USART_TXC_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.TXC_InterruptCall();
     8f2:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     8f4:	ff 91       	pop	r31
     8f6:	ef 91       	pop	r30
     8f8:	bf 91       	pop	r27
     8fa:	af 91       	pop	r26
     8fc:	9f 91       	pop	r25
     8fe:	8f 91       	pop	r24
     900:	7f 91       	pop	r23
     902:	6f 91       	pop	r22
     904:	5f 91       	pop	r21
     906:	4f 91       	pop	r20
     908:	3f 91       	pop	r19
     90a:	2f 91       	pop	r18
     90c:	0f 90       	pop	r0
     90e:	0f be       	out	0x3f, r0	; 63
     910:	0f 90       	pop	r0
     912:	1f 90       	pop	r1
     914:	18 95       	reti

00000916 <USART_UDRE_vect>:
	 
	 
	 /* interrupt function by the UDRE */						 
	 ISR (USART_UDRE_vect)
	 {
     916:	1f 92       	push	r1
     918:	0f 92       	push	r0
     91a:	0f b6       	in	r0, 0x3f	; 63
     91c:	0f 92       	push	r0
     91e:	11 24       	eor	r1, r1
     920:	2f 93       	push	r18
     922:	3f 93       	push	r19
     924:	4f 93       	push	r20
     926:	5f 93       	push	r21
     928:	6f 93       	push	r22
     92a:	7f 93       	push	r23
     92c:	8f 93       	push	r24
     92e:	9f 93       	push	r25
     930:	af 93       	push	r26
     932:	bf 93       	push	r27
     934:	ef 93       	push	r30
     936:	ff 93       	push	r31
		 if (USART0.UDRE_InterruptCall != NULL)
     938:	e0 91 63 02 	lds	r30, 0x0263
     93c:	f0 91 64 02 	lds	r31, 0x0264
     940:	30 97       	sbiw	r30, 0x00	; 0
     942:	09 f0       	breq	.+2      	; 0x946 <USART_UDRE_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.UDRE_InterruptCall();
     944:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     946:	ff 91       	pop	r31
     948:	ef 91       	pop	r30
     94a:	bf 91       	pop	r27
     94c:	af 91       	pop	r26
     94e:	9f 91       	pop	r25
     950:	8f 91       	pop	r24
     952:	7f 91       	pop	r23
     954:	6f 91       	pop	r22
     956:	5f 91       	pop	r21
     958:	4f 91       	pop	r20
     95a:	3f 91       	pop	r19
     95c:	2f 91       	pop	r18
     95e:	0f 90       	pop	r0
     960:	0f be       	out	0x3f, r0	; 63
     962:	0f 90       	pop	r0
     964:	1f 90       	pop	r1
     966:	18 95       	reti

00000968 <USART_Intia>:
	
	  void USART_Intia(void)
	  {
     968:	ff 92       	push	r15
     96a:	0f 93       	push	r16
     96c:	1f 93       	push	r17
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
		  unsigned char UCSRA_Temp = 0;
		  unsigned char UCSRB_Temp = 0;
		  unsigned char UCSRC_Temp = 0;
		  float   UBRR_Temp = 0.0;
		  
		  switch (USART0.enableMode)
     972:	80 91 53 02 	lds	r24, 0x0253
     976:	82 30       	cpi	r24, 0x02	; 2
     978:	51 f0       	breq	.+20     	; 0x98e <USART_Intia+0x26>
     97a:	83 30       	cpi	r24, 0x03	; 3
     97c:	31 f0       	breq	.+12     	; 0x98a <USART_Intia+0x22>
     97e:	81 30       	cpi	r24, 0x01	; 1
     980:	11 f0       	breq	.+4      	; 0x986 <USART_Intia+0x1e>
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
		  unsigned char UCSRB_Temp = 0;
     982:	c0 e0       	ldi	r28, 0x00	; 0
     984:	05 c0       	rjmp	.+10     	; 0x990 <USART_Intia+0x28>
			  break;
			  case USART_Rx_Only:
			       UCSRB_Temp |= (1<<RXEN);
			  break;
			  case USART_Tx_Only:
			       UCSRB_Temp |= (1<<TXEN);
     986:	c8 e0       	ldi	r28, 0x08	; 8
			  break;
     988:	03 c0       	rjmp	.+6      	; 0x990 <USART_Intia+0x28>
			  case USART_TxRx_Enable:
			       UCSRB_Temp |= (1<<RXEN) | (1<<TXEN);
     98a:	c8 e1       	ldi	r28, 0x18	; 24
			  break;
     98c:	01 c0       	rjmp	.+2      	; 0x990 <USART_Intia+0x28>
		  {
			  case USART_Disable:
			    
			  break;
			  case USART_Rx_Only:
			       UCSRB_Temp |= (1<<RXEN);
     98e:	c0 e1       	ldi	r28, 0x10	; 16
			  break;
			  default:
			  break;
		  }	
		  
		  switch(USART0.communicationMode)
     990:	80 91 54 02 	lds	r24, 0x0254
     994:	81 30       	cpi	r24, 0x01	; 1
     996:	51 f1       	breq	.+84     	; 0x9ec <USART_Intia+0x84>
     998:	81 30       	cpi	r24, 0x01	; 1
     99a:	20 f0       	brcs	.+8      	; 0x9a4 <USART_Intia+0x3c>
     99c:	82 30       	cpi	r24, 0x02	; 2
     99e:	09 f0       	breq	.+2      	; 0x9a2 <USART_Intia+0x3a>
     9a0:	6b c0       	rjmp	.+214    	; 0xa78 <USART_Intia+0x110>
     9a2:	48 c0       	rjmp	.+144    	; 0xa34 <USART_Intia+0xcc>
		  {
			  case USART_Asyn_DoupleSpeed:
			       UCSRA_Temp |= (1<<U2X);
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
     9a4:	60 91 5b 02 	lds	r22, 0x025B
     9a8:	70 91 5c 02 	lds	r23, 0x025C
     9ac:	80 91 5d 02 	lds	r24, 0x025D
     9b0:	90 91 5e 02 	lds	r25, 0x025E
     9b4:	0e 94 22 13 	call	0x2644	; 0x2644 <__floatunsisf>
     9b8:	20 e0       	ldi	r18, 0x00	; 0
     9ba:	30 e0       	ldi	r19, 0x00	; 0
     9bc:	40 e0       	ldi	r20, 0x00	; 0
     9be:	51 e4       	ldi	r21, 0x41	; 65
     9c0:	0e 94 b0 13 	call	0x2760	; 0x2760 <__mulsf3>
     9c4:	9b 01       	movw	r18, r22
     9c6:	ac 01       	movw	r20, r24
     9c8:	60 e0       	ldi	r22, 0x00	; 0
     9ca:	74 e2       	ldi	r23, 0x24	; 36
     9cc:	84 e7       	ldi	r24, 0x74	; 116
     9ce:	9b e4       	ldi	r25, 0x4B	; 75
     9d0:	0e 94 89 12 	call	0x2512	; 0x2512 <__divsf3>
     9d4:	20 e0       	ldi	r18, 0x00	; 0
     9d6:	30 e0       	ldi	r19, 0x00	; 0
     9d8:	40 e0       	ldi	r20, 0x00	; 0
     9da:	5f e3       	ldi	r21, 0x3F	; 63
     9dc:	0e 94 24 12 	call	0x2448	; 0x2448 <__subsf3>
     9e0:	f6 2e       	mov	r15, r22
     9e2:	07 2f       	mov	r16, r23
     9e4:	18 2f       	mov	r17, r24
     9e6:	d9 2f       	mov	r29, r25
		  }	
		  
		  switch(USART0.communicationMode)
		  {
			  case USART_Asyn_DoupleSpeed:
			       UCSRA_Temp |= (1<<U2X);
     9e8:	92 e0       	ldi	r25, 0x02	; 2
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
			  break;
     9ea:	4b c0       	rjmp	.+150    	; 0xa82 <USART_Intia+0x11a>
			  
			  case USART_Asyn_SingleSpeed:
			       UBRR_Temp = (((float)F_CPU) / (16.0 * USART0.baudRate)) - 0.5;
     9ec:	60 91 5b 02 	lds	r22, 0x025B
     9f0:	70 91 5c 02 	lds	r23, 0x025C
     9f4:	80 91 5d 02 	lds	r24, 0x025D
     9f8:	90 91 5e 02 	lds	r25, 0x025E
     9fc:	0e 94 22 13 	call	0x2644	; 0x2644 <__floatunsisf>
     a00:	20 e0       	ldi	r18, 0x00	; 0
     a02:	30 e0       	ldi	r19, 0x00	; 0
     a04:	40 e8       	ldi	r20, 0x80	; 128
     a06:	51 e4       	ldi	r21, 0x41	; 65
     a08:	0e 94 b0 13 	call	0x2760	; 0x2760 <__mulsf3>
     a0c:	9b 01       	movw	r18, r22
     a0e:	ac 01       	movw	r20, r24
     a10:	60 e0       	ldi	r22, 0x00	; 0
     a12:	74 e2       	ldi	r23, 0x24	; 36
     a14:	84 e7       	ldi	r24, 0x74	; 116
     a16:	9b e4       	ldi	r25, 0x4B	; 75
     a18:	0e 94 89 12 	call	0x2512	; 0x2512 <__divsf3>
     a1c:	20 e0       	ldi	r18, 0x00	; 0
     a1e:	30 e0       	ldi	r19, 0x00	; 0
     a20:	40 e0       	ldi	r20, 0x00	; 0
     a22:	5f e3       	ldi	r21, 0x3F	; 63
     a24:	0e 94 24 12 	call	0x2448	; 0x2448 <__subsf3>
     a28:	f6 2e       	mov	r15, r22
     a2a:	07 2f       	mov	r16, r23
     a2c:	18 2f       	mov	r17, r24
     a2e:	d9 2f       	mov	r29, r25
		 }			 
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
     a30:	90 e0       	ldi	r25, 0x00	; 0
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
			  break;
			  
			  case USART_Asyn_SingleSpeed:
			       UBRR_Temp = (((float)F_CPU) / (16.0 * USART0.baudRate)) - 0.5;
			  break;
     a32:	27 c0       	rjmp	.+78     	; 0xa82 <USART_Intia+0x11a>
			  
			  case USART_Sync:
			       UCSRC_Temp |= (1<<UMSEL);
				   UBRR_Temp = (((float)F_CPU) / (2.0 * USART0.baudRate)) - 0.5;
     a34:	60 91 5b 02 	lds	r22, 0x025B
     a38:	70 91 5c 02 	lds	r23, 0x025C
     a3c:	80 91 5d 02 	lds	r24, 0x025D
     a40:	90 91 5e 02 	lds	r25, 0x025E
     a44:	0e 94 22 13 	call	0x2644	; 0x2644 <__floatunsisf>
     a48:	9b 01       	movw	r18, r22
     a4a:	ac 01       	movw	r20, r24
     a4c:	0e 94 25 12 	call	0x244a	; 0x244a <__addsf3>
     a50:	9b 01       	movw	r18, r22
     a52:	ac 01       	movw	r20, r24
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	74 e2       	ldi	r23, 0x24	; 36
     a58:	84 e7       	ldi	r24, 0x74	; 116
     a5a:	9b e4       	ldi	r25, 0x4B	; 75
     a5c:	0e 94 89 12 	call	0x2512	; 0x2512 <__divsf3>
     a60:	20 e0       	ldi	r18, 0x00	; 0
     a62:	30 e0       	ldi	r19, 0x00	; 0
     a64:	40 e0       	ldi	r20, 0x00	; 0
     a66:	5f e3       	ldi	r21, 0x3F	; 63
     a68:	0e 94 24 12 	call	0x2448	; 0x2448 <__subsf3>
     a6c:	f6 2e       	mov	r15, r22
     a6e:	07 2f       	mov	r16, r23
     a70:	18 2f       	mov	r17, r24
     a72:	d9 2f       	mov	r29, r25
		 }			 
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	05 c0       	rjmp	.+10     	; 0xa82 <USART_Intia+0x11a>
		  unsigned char UCSRB_Temp = 0;
		  unsigned char UCSRC_Temp = 0;
		  float   UBRR_Temp = 0.0;
     a78:	ff 24       	eor	r15, r15
     a7a:	00 e0       	ldi	r16, 0x00	; 0
     a7c:	10 e0       	ldi	r17, 0x00	; 0
     a7e:	d0 e0       	ldi	r29, 0x00	; 0
		 }			 
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
     a80:	90 e0       	ldi	r25, 0x00	; 0
			 break;
			  default:
			  break;
		  }
		  
		  switch(USART0.communicationTerminal)
     a82:	80 91 55 02 	lds	r24, 0x0255
     a86:	81 30       	cpi	r24, 0x01	; 1
     a88:	09 f4       	brne	.+2      	; 0xa8c <USART_Intia+0x124>
		  {
			  case USART_SingleProcessor:
			  break;
			  case USART_MultiProcessor:
			       UCSRA_Temp |= (1<<MPCM);
     a8a:	91 60       	ori	r25, 0x01	; 1
			  break;
			  default:
			  break;
		  }
		  
		  switch (USART0.interruptSource)
     a8c:	80 91 56 02 	lds	r24, 0x0256
     a90:	84 30       	cpi	r24, 0x04	; 4
     a92:	b1 f0       	breq	.+44     	; 0xac0 <USART_Intia+0x158>
     a94:	85 30       	cpi	r24, 0x05	; 5
     a96:	38 f4       	brcc	.+14     	; 0xaa6 <USART_Intia+0x13e>
     a98:	82 30       	cpi	r24, 0x02	; 2
     a9a:	71 f0       	breq	.+28     	; 0xab8 <USART_Intia+0x150>
     a9c:	83 30       	cpi	r24, 0x03	; 3
     a9e:	70 f4       	brcc	.+28     	; 0xabc <USART_Intia+0x154>
     aa0:	81 30       	cpi	r24, 0x01	; 1
     aa2:	a9 f4       	brne	.+42     	; 0xace <USART_Intia+0x166>
     aa4:	07 c0       	rjmp	.+14     	; 0xab4 <USART_Intia+0x14c>
     aa6:	86 30       	cpi	r24, 0x06	; 6
     aa8:	79 f0       	breq	.+30     	; 0xac8 <USART_Intia+0x160>
     aaa:	86 30       	cpi	r24, 0x06	; 6
     aac:	58 f0       	brcs	.+22     	; 0xac4 <USART_Intia+0x15c>
     aae:	87 30       	cpi	r24, 0x07	; 7
     ab0:	71 f4       	brne	.+28     	; 0xace <USART_Intia+0x166>
     ab2:	0c c0       	rjmp	.+24     	; 0xacc <USART_Intia+0x164>
		  {
		    case USART_InterruptsDisable:
		  	break;
			case USART_RxComInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE);
     ab4:	c0 68       	ori	r28, 0x80	; 128
			break;
     ab6:	0b c0       	rjmp	.+22     	; 0xace <USART_Intia+0x166>
			case USART_TxComInt_Enable:
			     UCSRB_Temp |= (1<<TXCIE);
     ab8:	c0 64       	ori	r28, 0x40	; 64
			break;
     aba:	09 c0       	rjmp	.+18     	; 0xace <USART_Intia+0x166>
			case USART_UDRInt_Enable:
			     UCSRB_Temp |= (1<<UDRIE);
     abc:	c0 62       	ori	r28, 0x20	; 32
			break;
     abe:	07 c0       	rjmp	.+14     	; 0xace <USART_Intia+0x166>
			case USART_RxTxComInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE) | (1<<TXCIE);
     ac0:	c0 6c       	ori	r28, 0xC0	; 192
			break;
     ac2:	05 c0       	rjmp	.+10     	; 0xace <USART_Intia+0x166>
			case USART_RxComUDRInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE) | (1<<UDRIE);
     ac4:	c0 6a       	ori	r28, 0xA0	; 160
			break;
     ac6:	03 c0       	rjmp	.+6      	; 0xace <USART_Intia+0x166>
			case USART_TxComUDRInt_Enable:
			     UCSRB_Temp |= (1<<TXCIE) | (1<<UDRIE);
     ac8:	c0 66       	ori	r28, 0x60	; 96
			break;
     aca:	01 c0       	rjmp	.+2      	; 0xace <USART_Intia+0x166>
			case USART_InterruptsEnable:
			     UCSRB_Temp |= (1<<TXCIE) | (1<<UDRIE) | (1<<RXCIE);
     acc:	c0 6e       	ori	r28, 0xE0	; 224
			default:
			break;
		  }
		  
		  
		  switch(USART0.dataFrame)
     ace:	80 91 57 02 	lds	r24, 0x0257
     ad2:	84 30       	cpi	r24, 0x04	; 4
     ad4:	09 f4       	brne	.+2      	; 0xad8 <USART_Intia+0x170>
			  case USART_8bitData:
			       UCSRC_Temp |= (1<<UCSZ0) | (1<<UCSZ1);
			  break;
			  case USART_9bitData:
			       UCSRC_Temp |= (1<<UCSZ0) | (1<<UCSZ1);
				   UCSRB_Temp |= (1<<UCSZ2);
     ad6:	c4 60       	ori	r28, 0x04	; 4
			  default:
			  break;
		  }
		  
		  
		  UCSRA = UCSRA_Temp;
     ad8:	9b b9       	out	0x0b, r25	; 11
		  UCSRC = UCSRB_Temp;
     ada:	c0 bd       	out	0x20, r28	; 32
		  UBRRH = ((unsigned short)UBRR_Temp)>>8;
     adc:	8f 2d       	mov	r24, r15
     ade:	90 2f       	mov	r25, r16
     ae0:	a1 2f       	mov	r26, r17
     ae2:	bd 2f       	mov	r27, r29
     ae4:	bc 01       	movw	r22, r24
     ae6:	cd 01       	movw	r24, r26
     ae8:	0e 94 f6 12 	call	0x25ec	; 0x25ec <__fixunssfsi>
     aec:	70 bd       	out	0x20, r23	; 32
		  UBRRL = ((unsigned char)UBRR_Temp);
     aee:	8f 2d       	mov	r24, r15
     af0:	90 2f       	mov	r25, r16
     af2:	a1 2f       	mov	r26, r17
     af4:	bd 2f       	mov	r27, r29
     af6:	bc 01       	movw	r22, r24
     af8:	cd 01       	movw	r24, r26
     afa:	0e 94 f6 12 	call	0x25ec	; 0x25ec <__fixunssfsi>
     afe:	69 b9       	out	0x09, r22	; 9
		  UCSRB = UCSRB_Temp; //put in the last because on it the enable bit of the UART
     b00:	ca b9       	out	0x0a, r28	; 10
		  		  
	  }
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	1f 91       	pop	r17
     b08:	0f 91       	pop	r16
     b0a:	ff 90       	pop	r15
     b0c:	08 95       	ret

00000b0e <USART_SendByte_Blocking>:
	  
	  void USART_SendByte_Blocking(unsigned short Data)
	  {
		  while ((UCSRA & (1<<UDRE)) == 0)
     b0e:	5d 9b       	sbis	0x0b, 5	; 11
     b10:	fe cf       	rjmp	.-4      	; 0xb0e <USART_SendByte_Blocking>
		  {
			  /* this to blocking on the bit UDRE until it change to 1 to start transmit*/
		  }
		  if (USART0.dataFrame == USART_9bitData)
     b12:	20 91 57 02 	lds	r18, 0x0257
     b16:	24 30       	cpi	r18, 0x04	; 4
     b18:	41 f4       	brne	.+16     	; 0xb2a <USART_SendByte_Blocking+0x1c>
			  /*
			   * UCSRB & 1111 1110 to make sure the bit 0 is reset to hold the new value because it does not mention in data sheet
			   * we need to take the bit 9  in the data and hold it in the bit 0  in the UCSRB so we & the data with 8 to get 
			   *  and shift it again to put in the position of the bit 0
			   */ 
			  UCSRB = (UCSRB & 0xFE) | ((Data & (1<<8))>>8);
     b1a:	4a b1       	in	r20, 0x0a	; 10
     b1c:	9c 01       	movw	r18, r24
     b1e:	20 70       	andi	r18, 0x00	; 0
     b20:	31 70       	andi	r19, 0x01	; 1
     b22:	24 2f       	mov	r18, r20
     b24:	2e 7f       	andi	r18, 0xFE	; 254
     b26:	23 2b       	or	r18, r19
     b28:	2a b9       	out	0x0a, r18	; 10
		  }
		  /* casting the data to char to get only the 8 bit */
		  UDR = (unsigned char) Data;
     b2a:	8c b9       	out	0x0c, r24	; 12
	  }
     b2c:	08 95       	ret

00000b2e <USART_SendByte_NoneBlocking>:
	  
	  /* this function is use in case called by interrupt */
	  void USART_SendByte_NoneBlocking(unsigned short Data)
	  {
		  if ((UCSRA & (1<<UDRE)) != 0)
     b2e:	5d 9b       	sbis	0x0b, 5	; 11
     b30:	0d c0       	rjmp	.+26     	; 0xb4c <USART_SendByte_NoneBlocking+0x1e>
		  {
			
			  if (USART0.dataFrame == USART_9bitData)
     b32:	20 91 57 02 	lds	r18, 0x0257
     b36:	24 30       	cpi	r18, 0x04	; 4
     b38:	41 f4       	brne	.+16     	; 0xb4a <USART_SendByte_NoneBlocking+0x1c>
				  /*
				   * UCSRB & 1111 1110 to make sure the bit 0 is reset to hold the new value because it does not mention in data sheet
				   * we need to take the bit 9  in the data and hold it in the bit 0  in the UCSRB so we & the data with 8 to get 
					   and shift it again to put in the position of the bit 0
				  */ 
				  UCSRB = (UCSRB & 0xFE) | ((Data & (1<<8))>>8);
     b3a:	4a b1       	in	r20, 0x0a	; 10
     b3c:	9c 01       	movw	r18, r24
     b3e:	20 70       	andi	r18, 0x00	; 0
     b40:	31 70       	andi	r19, 0x01	; 1
     b42:	24 2f       	mov	r18, r20
     b44:	2e 7f       	andi	r18, 0xFE	; 254
     b46:	23 2b       	or	r18, r19
     b48:	2a b9       	out	0x0a, r18	; 10
			  }
			  /* casting the data to char to get only the 8 bit */
			  UDR = (unsigned char) Data;
     b4a:	8c b9       	out	0x0c, r24	; 12
     b4c:	08 95       	ret

00000b4e <USART_ReadByte_Blocking>:
	  unsigned short USART_ReadByte_Blocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
		  
		  while ((UCSRA & (1<<RXC)) == 0)
     b4e:	5f 9b       	sbis	0x0b, 7	; 11
     b50:	fe cf       	rjmp	.-4      	; 0xb4e <USART_ReadByte_Blocking>
		  {
			  /* this flag set when there was unread data in the receive buffer so we blocking until it set */ 
		  }
		  
		  if (UCSRA & ((1<<FE) | (1<<DOR) | (1<<PE)))
     b52:	8b b1       	in	r24, 0x0b	; 11
     b54:	8c 71       	andi	r24, 0x1C	; 28
     b56:	89 f0       	breq	.+34     	; 0xb7a <USART_ReadByte_Blocking+0x2c>
		  {
			  /* error handle as you wish */
			  if(UCSRA & (1<<FE))
     b58:	5c 9b       	sbis	0x0b, 4	; 11
     b5a:	04 c0       	rjmp	.+8      	; 0xb64 <USART_ReadByte_Blocking+0x16>
			  {
				  USART0.errorType = USART_FrameError;
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	80 93 5a 02 	sts	0x025A, r24
     b62:	0b c0       	rjmp	.+22     	; 0xb7a <USART_ReadByte_Blocking+0x2c>
			  }	
			  else if(UCSRA & (1<<DOR))
     b64:	5b 9b       	sbis	0x0b, 3	; 11
     b66:	04 c0       	rjmp	.+8      	; 0xb70 <USART_ReadByte_Blocking+0x22>
			  {
				  USART0.errorType = USART_OverRunError;
     b68:	82 e0       	ldi	r24, 0x02	; 2
     b6a:	80 93 5a 02 	sts	0x025A, r24
     b6e:	05 c0       	rjmp	.+10     	; 0xb7a <USART_ReadByte_Blocking+0x2c>
			  }
			  else if(UCSRA & (1<<PE))
     b70:	5a 9b       	sbis	0x0b, 2	; 11
     b72:	03 c0       	rjmp	.+6      	; 0xb7a <USART_ReadByte_Blocking+0x2c>
			  {
				  USART0.errorType = USART_ParityError;
     b74:	81 e0       	ldi	r24, 0x01	; 1
     b76:	80 93 5a 02 	sts	0x025A, r24
			  }
			  			  
		  }
		  
		  if(USART0.dataFrame == USART_9bitData)
     b7a:	80 91 57 02 	lds	r24, 0x0257
     b7e:	84 30       	cpi	r24, 0x04	; 4
     b80:	51 f4       	brne	.+20     	; 0xb96 <USART_ReadByte_Blocking+0x48>
		  {
			  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
			  RxData = ((UCSRB & (1<<RXB8)) << 7);
     b82:	8a b1       	in	r24, 0x0a	; 10
     b84:	90 e0       	ldi	r25, 0x00	; 0
     b86:	82 70       	andi	r24, 0x02	; 2
     b88:	90 70       	andi	r25, 0x00	; 0
     b8a:	96 95       	lsr	r25
     b8c:	98 2f       	mov	r25, r24
     b8e:	88 27       	eor	r24, r24
     b90:	97 95       	ror	r25
     b92:	87 95       	ror	r24
     b94:	02 c0       	rjmp	.+4      	; 0xb9a <USART_ReadByte_Blocking+0x4c>
	  }
	  
	  unsigned short USART_ReadByte_Blocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
     b96:	80 e0       	ldi	r24, 0x00	; 0
     b98:	90 e0       	ldi	r25, 0x00	; 0
		  {
			  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
			  RxData = ((UCSRB & (1<<RXB8)) << 7);
		  }
		  
		  RxData |= UDR;
     b9a:	2c b1       	in	r18, 0x0c	; 12
     b9c:	30 e0       	ldi	r19, 0x00	; 0
     b9e:	82 2b       	or	r24, r18
     ba0:	93 2b       	or	r25, r19
		  return RxData;
		  
	  }
     ba2:	08 95       	ret

00000ba4 <USART_ReadByte_NoneBlocking>:
	  unsigned short USART_ReadByte_NoneBlocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
		  
		  if ((UCSRA & (1<<RXC)) != 0)
     ba4:	5f 9b       	sbis	0x0b, 7	; 11
     ba6:	22 c0       	rjmp	.+68     	; 0xbec <USART_ReadByte_NoneBlocking+0x48>
		  {
		  
			  if (UCSRA & ((1<<FE) | (1<<DOR) | (1<<PE)))
     ba8:	8b b1       	in	r24, 0x0b	; 11
     baa:	8c 71       	andi	r24, 0x1C	; 28
     bac:	89 f0       	breq	.+34     	; 0xbd0 <USART_ReadByte_NoneBlocking+0x2c>
			  {
				  /* error handle as you wish */
				  if(UCSRA & (1<<FE))
     bae:	5c 9b       	sbis	0x0b, 4	; 11
     bb0:	04 c0       	rjmp	.+8      	; 0xbba <USART_ReadByte_NoneBlocking+0x16>
				  {
					  USART0.errorType = USART_FrameError;
     bb2:	83 e0       	ldi	r24, 0x03	; 3
     bb4:	80 93 5a 02 	sts	0x025A, r24
     bb8:	0b c0       	rjmp	.+22     	; 0xbd0 <USART_ReadByte_NoneBlocking+0x2c>
				  }
				  else if(UCSRA & (1<<DOR))
     bba:	5b 9b       	sbis	0x0b, 3	; 11
     bbc:	04 c0       	rjmp	.+8      	; 0xbc6 <USART_ReadByte_NoneBlocking+0x22>
				  {
					  USART0.errorType = USART_OverRunError;
     bbe:	82 e0       	ldi	r24, 0x02	; 2
     bc0:	80 93 5a 02 	sts	0x025A, r24
     bc4:	05 c0       	rjmp	.+10     	; 0xbd0 <USART_ReadByte_NoneBlocking+0x2c>
				  }
				  else if(UCSRA & (1<<PE))
     bc6:	5a 9b       	sbis	0x0b, 2	; 11
     bc8:	03 c0       	rjmp	.+6      	; 0xbd0 <USART_ReadByte_NoneBlocking+0x2c>
				  {
					  USART0.errorType = USART_ParityError;
     bca:	81 e0       	ldi	r24, 0x01	; 1
     bcc:	80 93 5a 02 	sts	0x025A, r24
				  }
			  
			  }
		  
			  if(USART0.dataFrame == USART_9bitData)
     bd0:	80 91 57 02 	lds	r24, 0x0257
     bd4:	84 30       	cpi	r24, 0x04	; 4
     bd6:	69 f4       	brne	.+26     	; 0xbf2 <USART_ReadByte_NoneBlocking+0x4e>
			  {
				  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
				  RxData = ((UCSRB & (1<<RXB8)) << 7);
     bd8:	8a b1       	in	r24, 0x0a	; 10
     bda:	90 e0       	ldi	r25, 0x00	; 0
     bdc:	82 70       	andi	r24, 0x02	; 2
     bde:	90 70       	andi	r25, 0x00	; 0
     be0:	96 95       	lsr	r25
     be2:	98 2f       	mov	r25, r24
     be4:	88 27       	eor	r24, r24
     be6:	97 95       	ror	r25
     be8:	87 95       	ror	r24
     bea:	05 c0       	rjmp	.+10     	; 0xbf6 <USART_ReadByte_NoneBlocking+0x52>
	  
	  
	  unsigned short USART_ReadByte_NoneBlocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
     bec:	80 e0       	ldi	r24, 0x00	; 0
     bee:	90 e0       	ldi	r25, 0x00	; 0
     bf0:	02 c0       	rjmp	.+4      	; 0xbf6 <USART_ReadByte_NoneBlocking+0x52>
     bf2:	80 e0       	ldi	r24, 0x00	; 0
     bf4:	90 e0       	ldi	r25, 0x00	; 0
				  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
				  RxData = ((UCSRB & (1<<RXB8)) << 7);
			  }
		  }			
		  
			RxData |= UDR;
     bf6:	2c b1       	in	r18, 0x0c	; 12
     bf8:	30 e0       	ldi	r19, 0x00	; 0
     bfa:	82 2b       	or	r24, r18
     bfc:	93 2b       	or	r25, r19
			return RxData;
		 	  
		  
     bfe:	08 95       	ret

00000c00 <sevenSegment_setup>:
  #define bit_2_num (2)
  #define bit_3_num (3)
  
  
  void sevenSegment_setup(SevenSegment pins)
  {
     c00:	0f 93       	push	r16
     c02:	1f 93       	push	r17
     c04:	cf 93       	push	r28
     c06:	df 93       	push	r29
     c08:	00 d0       	rcall	.+0      	; 0xc0a <sevenSegment_setup+0xa>
     c0a:	00 d0       	rcall	.+0      	; 0xc0c <sevenSegment_setup+0xc>
     c0c:	00 d0       	rcall	.+0      	; 0xc0e <sevenSegment_setup+0xe>
     c0e:	cd b7       	in	r28, 0x3d	; 61
     c10:	de b7       	in	r29, 0x3e	; 62
     c12:	49 83       	std	Y+1, r20	; 0x01
     c14:	5a 83       	std	Y+2, r21	; 0x02
     c16:	6b 83       	std	Y+3, r22	; 0x03
     c18:	7c 83       	std	Y+4, r23	; 0x04
     c1a:	8d 83       	std	Y+5, r24	; 0x05
     c1c:	9e 83       	std	Y+6, r25	; 0x06
     c1e:	09 81       	ldd	r16, Y+1	; 0x01
     c20:	1a 81       	ldd	r17, Y+2	; 0x02
	  /* define The Pins Of The BCD IC As Output Pins */
	  DIO_pinConfiguration(pins.drivPORT,pins.Apin,Output);
     c22:	c8 01       	movw	r24, r16
     c24:	42 e0       	ldi	r20, 0x02	; 2
     c26:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Bpin,Output);
     c2a:	c8 01       	movw	r24, r16
     c2c:	6c 81       	ldd	r22, Y+4	; 0x04
     c2e:	42 e0       	ldi	r20, 0x02	; 2
     c30:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Cpin,Output);
     c34:	c8 01       	movw	r24, r16
     c36:	6d 81       	ldd	r22, Y+5	; 0x05
     c38:	42 e0       	ldi	r20, 0x02	; 2
     c3a:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Dpin,Output);
     c3e:	c8 01       	movw	r24, r16
     c40:	6e 81       	ldd	r22, Y+6	; 0x06
     c42:	42 e0       	ldi	r20, 0x02	; 2
     c44:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
  }
     c48:	26 96       	adiw	r28, 0x06	; 6
     c4a:	0f b6       	in	r0, 0x3f	; 63
     c4c:	f8 94       	cli
     c4e:	de bf       	out	0x3e, r29	; 62
     c50:	0f be       	out	0x3f, r0	; 63
     c52:	cd bf       	out	0x3d, r28	; 61
     c54:	df 91       	pop	r29
     c56:	cf 91       	pop	r28
     c58:	1f 91       	pop	r17
     c5a:	0f 91       	pop	r16
     c5c:	08 95       	ret

00000c5e <sevenSegment_write>:
  
  
  void sevenSegment_write(SevenSegment pins, unsigned char number)
  {
     c5e:	ef 92       	push	r14
     c60:	ff 92       	push	r15
     c62:	0f 93       	push	r16
     c64:	1f 93       	push	r17
     c66:	cf 93       	push	r28
     c68:	df 93       	push	r29
     c6a:	00 d0       	rcall	.+0      	; 0xc6c <sevenSegment_write+0xe>
     c6c:	00 d0       	rcall	.+0      	; 0xc6e <sevenSegment_write+0x10>
     c6e:	00 d0       	rcall	.+0      	; 0xc70 <sevenSegment_write+0x12>
     c70:	cd b7       	in	r28, 0x3d	; 61
     c72:	de b7       	in	r29, 0x3e	; 62
     c74:	49 83       	std	Y+1, r20	; 0x01
     c76:	5a 83       	std	Y+2, r21	; 0x02
     c78:	6b 83       	std	Y+3, r22	; 0x03
     c7a:	7c 83       	std	Y+4, r23	; 0x04
     c7c:	8d 83       	std	Y+5, r24	; 0x05
     c7e:	9e 83       	std	Y+6, r25	; 0x06
     c80:	12 2f       	mov	r17, r18
     c82:	e9 80       	ldd	r14, Y+1	; 0x01
     c84:	fa 80       	ldd	r15, Y+2	; 0x02
	  /* read The Bit Zero from The Number And represent By The Pin A */
	  DIO_pinWrite(pins.drivPORT,pins.Apin, (READ_Bit(number,bit_0_num)));
     c86:	42 2f       	mov	r20, r18
     c88:	41 70       	andi	r20, 0x01	; 1
     c8a:	c7 01       	movw	r24, r14
     c8c:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
	  /* read The Bit 1 from The Number And represent By The Pin B */
	  DIO_pinWrite(pins.drivPORT,pins.Bpin, (READ_Bit(number,bit_1_num)));
     c90:	01 2f       	mov	r16, r17
     c92:	10 e0       	ldi	r17, 0x00	; 0
     c94:	a8 01       	movw	r20, r16
     c96:	42 70       	andi	r20, 0x02	; 2
     c98:	50 70       	andi	r21, 0x00	; 0
     c9a:	55 95       	asr	r21
     c9c:	47 95       	ror	r20
     c9e:	c7 01       	movw	r24, r14
     ca0:	6c 81       	ldd	r22, Y+4	; 0x04
     ca2:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
	  /* read The Bit 2 from The Number And represent By The Pin C */
	  DIO_pinWrite(pins.drivPORT,pins.Cpin, (READ_Bit(number,bit_2_num)));
     ca6:	a8 01       	movw	r20, r16
     ca8:	44 70       	andi	r20, 0x04	; 4
     caa:	50 70       	andi	r21, 0x00	; 0
     cac:	55 95       	asr	r21
     cae:	47 95       	ror	r20
     cb0:	55 95       	asr	r21
     cb2:	47 95       	ror	r20
     cb4:	c7 01       	movw	r24, r14
     cb6:	6d 81       	ldd	r22, Y+5	; 0x05
     cb8:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
	  /* read The Bit 3 from The Number And represent By The Pin D */
	  DIO_pinWrite(pins.drivPORT,pins.Dpin, (READ_Bit(number,bit_3_num)));
     cbc:	08 70       	andi	r16, 0x08	; 8
     cbe:	10 70       	andi	r17, 0x00	; 0
     cc0:	a8 01       	movw	r20, r16
     cc2:	55 95       	asr	r21
     cc4:	47 95       	ror	r20
     cc6:	55 95       	asr	r21
     cc8:	47 95       	ror	r20
     cca:	55 95       	asr	r21
     ccc:	47 95       	ror	r20
     cce:	c7 01       	movw	r24, r14
     cd0:	6e 81       	ldd	r22, Y+6	; 0x06
     cd2:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
     cd6:	26 96       	adiw	r28, 0x06	; 6
     cd8:	0f b6       	in	r0, 0x3f	; 63
     cda:	f8 94       	cli
     cdc:	de bf       	out	0x3e, r29	; 62
     cde:	0f be       	out	0x3f, r0	; 63
     ce0:	cd bf       	out	0x3d, r28	; 61
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	ef 90       	pop	r14
     cee:	08 95       	ret

00000cf0 <BUZZER_Setup>:
  #define PEP_DELAY (100)
  
  
  
  void BUZZER_Setup (BUZZER_dataType buz)
  {
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
     cf4:	00 d0       	rcall	.+0      	; 0xcf6 <BUZZER_Setup+0x6>
     cf6:	0f 92       	push	r0
     cf8:	cd b7       	in	r28, 0x3d	; 61
     cfa:	de b7       	in	r29, 0x3e	; 62
     cfc:	69 83       	std	Y+1, r22	; 0x01
     cfe:	7a 83       	std	Y+2, r23	; 0x02
     d00:	68 2f       	mov	r22, r24
     d02:	8b 83       	std	Y+3, r24	; 0x03
	  /* Configuration The Pin Of The Buzzer As Output Pin */
	  DIO_pinConfiguration(buz.buzzerPORT,buz.buzzerPIN,Output);
     d04:	89 81       	ldd	r24, Y+1	; 0x01
     d06:	9a 81       	ldd	r25, Y+2	; 0x02
     d08:	42 e0       	ldi	r20, 0x02	; 2
     d0a:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
  }
     d0e:	0f 90       	pop	r0
     d10:	0f 90       	pop	r0
     d12:	0f 90       	pop	r0
     d14:	df 91       	pop	r29
     d16:	cf 91       	pop	r28
     d18:	08 95       	ret

00000d1a <BUZZER_ALARM>:
  
  
  void BUZZER_ALARM(BUZZER_dataType buz)
  {
     d1a:	ef 92       	push	r14
     d1c:	ff 92       	push	r15
     d1e:	1f 93       	push	r17
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	00 d0       	rcall	.+0      	; 0xd26 <BUZZER_ALARM+0xc>
     d26:	0f 92       	push	r0
     d28:	cd b7       	in	r28, 0x3d	; 61
     d2a:	de b7       	in	r29, 0x3e	; 62
     d2c:	69 83       	std	Y+1, r22	; 0x01
     d2e:	7a 83       	std	Y+2, r23	; 0x02
     d30:	8b 83       	std	Y+3, r24	; 0x03
     d32:	e9 80       	ldd	r14, Y+1	; 0x01
     d34:	fa 80       	ldd	r15, Y+2	; 0x02
     d36:	18 2f       	mov	r17, r24
	  /* That Make A sequence Of PeP By On an Off THe Buzzer */
	  DIO_pinWrite(buz.buzzerPORT, buz.buzzerPIN, HIGH);
     d38:	c7 01       	movw	r24, r14
     d3a:	61 2f       	mov	r22, r17
     d3c:	41 e0       	ldi	r20, 0x01	; 1
     d3e:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     d42:	8f ef       	ldi	r24, 0xFF	; 255
     d44:	91 ee       	ldi	r25, 0xE1	; 225
     d46:	a4 e0       	ldi	r26, 0x04	; 4
     d48:	81 50       	subi	r24, 0x01	; 1
     d4a:	90 40       	sbci	r25, 0x00	; 0
     d4c:	a0 40       	sbci	r26, 0x00	; 0
     d4e:	e1 f7       	brne	.-8      	; 0xd48 <BUZZER_ALARM+0x2e>
     d50:	00 c0       	rjmp	.+0      	; 0xd52 <BUZZER_ALARM+0x38>
     d52:	00 00       	nop
	  _delay_ms(PEP_DELAY);
	  DIO_pinWrite(buz.buzzerPORT, buz.buzzerPIN, LOW);
     d54:	c7 01       	movw	r24, r14
     d56:	61 2f       	mov	r22, r17
     d58:	40 e0       	ldi	r20, 0x00	; 0
     d5a:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
     d5e:	8f ef       	ldi	r24, 0xFF	; 255
     d60:	91 ee       	ldi	r25, 0xE1	; 225
     d62:	a4 e0       	ldi	r26, 0x04	; 4
     d64:	81 50       	subi	r24, 0x01	; 1
     d66:	90 40       	sbci	r25, 0x00	; 0
     d68:	a0 40       	sbci	r26, 0x00	; 0
     d6a:	e1 f7       	brne	.-8      	; 0xd64 <BUZZER_ALARM+0x4a>
     d6c:	00 c0       	rjmp	.+0      	; 0xd6e <BUZZER_ALARM+0x54>
     d6e:	00 00       	nop
	  _delay_ms(PEP_DELAY);
     d70:	0f 90       	pop	r0
     d72:	0f 90       	pop	r0
     d74:	0f 90       	pop	r0
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	1f 91       	pop	r17
     d7c:	ff 90       	pop	r15
     d7e:	ef 90       	pop	r14
     d80:	08 95       	ret

00000d82 <sensor_setup>:
   #include <IndicatorSensor.h>
   
   
   
   void sensor_setup(indecationSensor_dataType sensor)
   {
     d82:	28 2f       	mov	r18, r24
	   /* Configuration The PinOf The Sensor As an Input Pull up Pin So It default Is LOW */
	   DIO_pinConfiguration(sensor.sensorPORT, sensor.sensorPIN, InputFloat);
     d84:	86 2f       	mov	r24, r22
     d86:	97 2f       	mov	r25, r23
     d88:	62 2f       	mov	r22, r18
     d8a:	40 e0       	ldi	r20, 0x00	; 0
     d8c:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
   }
     d90:	08 95       	ret

00000d92 <sensor_operate>:
   
   
   
   DigitalValue sensor_operate(indecationSensor_dataType sensor)
   {
     d92:	28 2f       	mov	r18, r24
	   /* read The Pin State Refer To The Condition OfThe sensor If It Indicate Will return High Else Will Return LOW */ 
	   return ( DIO_pinRead(sensor.sensorPORT, sensor.sensorPIN) );
     d94:	86 2f       	mov	r24, r22
     d96:	97 2f       	mov	r25, r23
     d98:	62 2f       	mov	r22, r18
     d9a:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     d9e:	08 95       	ret

00000da0 <CheckData>:
	
	
	 
 /* This is an static function to check the value of the current data get from the keypad key */
 static unsigned char CheckData(KEYPAD_PIN keypad,MATRIX_COL col )
 {
     da0:	bf 92       	push	r11
     da2:	cf 92       	push	r12
     da4:	df 92       	push	r13
     da6:	ef 92       	push	r14
     da8:	ff 92       	push	r15
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	cd b7       	in	r28, 0x3d	; 61
     db4:	de b7       	in	r29, 0x3e	; 62
     db6:	2a 97       	sbiw	r28, 0x0a	; 10
     db8:	0f b6       	in	r0, 0x3f	; 63
     dba:	f8 94       	cli
     dbc:	de bf       	out	0x3e, r29	; 62
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	cd bf       	out	0x3d, r28	; 61
     dc2:	09 83       	std	Y+1, r16	; 0x01
     dc4:	1a 83       	std	Y+2, r17	; 0x02
     dc6:	f2 2e       	mov	r15, r18
     dc8:	2b 83       	std	Y+3, r18	; 0x03
     dca:	d3 2e       	mov	r13, r19
     dcc:	3c 83       	std	Y+4, r19	; 0x04
     dce:	c4 2e       	mov	r12, r20
     dd0:	4d 83       	std	Y+5, r20	; 0x05
     dd2:	b5 2e       	mov	r11, r21
     dd4:	5e 83       	std	Y+6, r21	; 0x06
     dd6:	6f 83       	std	Y+7, r22	; 0x07
     dd8:	78 87       	std	Y+8, r23	; 0x08
     dda:	89 87       	std	Y+9, r24	; 0x09
     ddc:	9a 87       	std	Y+10, r25	; 0x0a
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
		 {
			 return(KeyData[ROW4][col]);
		 }
	 }
	 return 0;
     dde:	09 81       	ldd	r16, Y+1	; 0x01
     de0:	1a 81       	ldd	r17, Y+2	; 0x02
	 
 /* This is an static function to check the value of the current data get from the keypad key */
 static unsigned char CheckData(KEYPAD_PIN keypad,MATRIX_COL col )
 {
	 /* Each time We Check If The User Is Push The button by Check the value get on The Raw Pin if HIGH the button pushed else we check the other Raw */ 
	 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW1))
     de2:	c8 01       	movw	r24, r16
     de4:	62 2f       	mov	r22, r18
     de6:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     dea:	88 23       	and	r24, r24
     dec:	b1 f0       	breq	.+44     	; 0xe1a <CheckData+0x7a>
     dee:	8f ef       	ldi	r24, 0xFF	; 255
     df0:	99 ef       	ldi	r25, 0xF9	; 249
     df2:	a0 e0       	ldi	r26, 0x00	; 0
     df4:	81 50       	subi	r24, 0x01	; 1
     df6:	90 40       	sbci	r25, 0x00	; 0
     df8:	a0 40       	sbci	r26, 0x00	; 0
     dfa:	e1 f7       	brne	.-8      	; 0xdf4 <CheckData+0x54>
     dfc:	00 c0       	rjmp	.+0      	; 0xdfe <CheckData+0x5e>
     dfe:	00 00       	nop
	 {
		 /* wait Time Delay and recheck the condition of the Raw pin to Make Sure The Is Not An Noise */
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW1))
     e00:	c8 01       	movw	r24, r16
     e02:	6f 2d       	mov	r22, r15
     e04:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     e08:	88 23       	and	r24, r24
     e0a:	09 f4       	brne	.+2      	; 0xe0e <CheckData+0x6e>
     e0c:	57 c0       	rjmp	.+174    	; 0xebc <CheckData+0x11c>
		 {
			 /* We Match the Value Get From The REad Function Of The Number Of The Column And The Number Of The Raw We Get Here To Get The Value From The Matrix */
			return(KeyData[ROW1][col]);
     e0e:	e3 e3       	ldi	r30, 0x33	; 51
     e10:	f2 e0       	ldi	r31, 0x02	; 2
     e12:	ee 0d       	add	r30, r14
     e14:	f1 1d       	adc	r31, r1
     e16:	80 81       	ld	r24, Z
     e18:	5a c0       	rjmp	.+180    	; 0xece <CheckData+0x12e>
		 }			 
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW2))
     e1a:	c8 01       	movw	r24, r16
     e1c:	6d 2d       	mov	r22, r13
     e1e:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     e22:	88 23       	and	r24, r24
     e24:	a9 f0       	breq	.+42     	; 0xe50 <CheckData+0xb0>
     e26:	8f ef       	ldi	r24, 0xFF	; 255
     e28:	99 ef       	ldi	r25, 0xF9	; 249
     e2a:	a0 e0       	ldi	r26, 0x00	; 0
     e2c:	81 50       	subi	r24, 0x01	; 1
     e2e:	90 40       	sbci	r25, 0x00	; 0
     e30:	a0 40       	sbci	r26, 0x00	; 0
     e32:	e1 f7       	brne	.-8      	; 0xe2c <CheckData+0x8c>
     e34:	00 c0       	rjmp	.+0      	; 0xe36 <CheckData+0x96>
     e36:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW2))
     e38:	c8 01       	movw	r24, r16
     e3a:	6d 2d       	mov	r22, r13
     e3c:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     e40:	88 23       	and	r24, r24
     e42:	f1 f1       	breq	.+124    	; 0xec0 <CheckData+0x120>
		 {
			  return(KeyData[ROW2][col]);
     e44:	e3 e3       	ldi	r30, 0x33	; 51
     e46:	f2 e0       	ldi	r31, 0x02	; 2
     e48:	ee 0d       	add	r30, r14
     e4a:	f1 1d       	adc	r31, r1
     e4c:	84 81       	ldd	r24, Z+4	; 0x04
     e4e:	3f c0       	rjmp	.+126    	; 0xece <CheckData+0x12e>
		 }
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW3))
     e50:	c8 01       	movw	r24, r16
     e52:	6c 2d       	mov	r22, r12
     e54:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     e58:	88 23       	and	r24, r24
     e5a:	a9 f0       	breq	.+42     	; 0xe86 <CheckData+0xe6>
     e5c:	8f ef       	ldi	r24, 0xFF	; 255
     e5e:	99 ef       	ldi	r25, 0xF9	; 249
     e60:	a0 e0       	ldi	r26, 0x00	; 0
     e62:	81 50       	subi	r24, 0x01	; 1
     e64:	90 40       	sbci	r25, 0x00	; 0
     e66:	a0 40       	sbci	r26, 0x00	; 0
     e68:	e1 f7       	brne	.-8      	; 0xe62 <CheckData+0xc2>
     e6a:	00 c0       	rjmp	.+0      	; 0xe6c <CheckData+0xcc>
     e6c:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW3))
     e6e:	c8 01       	movw	r24, r16
     e70:	6c 2d       	mov	r22, r12
     e72:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     e76:	88 23       	and	r24, r24
     e78:	29 f1       	breq	.+74     	; 0xec4 <CheckData+0x124>
		 {
			return(KeyData[ROW3][col]);
     e7a:	e3 e3       	ldi	r30, 0x33	; 51
     e7c:	f2 e0       	ldi	r31, 0x02	; 2
     e7e:	ee 0d       	add	r30, r14
     e80:	f1 1d       	adc	r31, r1
     e82:	80 85       	ldd	r24, Z+8	; 0x08
     e84:	24 c0       	rjmp	.+72     	; 0xece <CheckData+0x12e>
		 }
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
     e86:	c8 01       	movw	r24, r16
     e88:	6b 2d       	mov	r22, r11
     e8a:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     e8e:	88 23       	and	r24, r24
     e90:	d9 f0       	breq	.+54     	; 0xec8 <CheckData+0x128>
     e92:	8f ef       	ldi	r24, 0xFF	; 255
     e94:	99 ef       	ldi	r25, 0xF9	; 249
     e96:	a0 e0       	ldi	r26, 0x00	; 0
     e98:	81 50       	subi	r24, 0x01	; 1
     e9a:	90 40       	sbci	r25, 0x00	; 0
     e9c:	a0 40       	sbci	r26, 0x00	; 0
     e9e:	e1 f7       	brne	.-8      	; 0xe98 <CheckData+0xf8>
     ea0:	00 c0       	rjmp	.+0      	; 0xea2 <CheckData+0x102>
     ea2:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
     ea4:	c8 01       	movw	r24, r16
     ea6:	6b 2d       	mov	r22, r11
     ea8:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
     eac:	88 23       	and	r24, r24
     eae:	71 f0       	breq	.+28     	; 0xecc <CheckData+0x12c>
		 {
			 return(KeyData[ROW4][col]);
     eb0:	e3 e3       	ldi	r30, 0x33	; 51
     eb2:	f2 e0       	ldi	r31, 0x02	; 2
     eb4:	ee 0d       	add	r30, r14
     eb6:	f1 1d       	adc	r31, r1
     eb8:	84 85       	ldd	r24, Z+12	; 0x0c
     eba:	09 c0       	rjmp	.+18     	; 0xece <CheckData+0x12e>
		 }
	 }
	 return 0;
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	07 c0       	rjmp	.+14     	; 0xece <CheckData+0x12e>
     ec0:	80 e0       	ldi	r24, 0x00	; 0
     ec2:	05 c0       	rjmp	.+10     	; 0xece <CheckData+0x12e>
     ec4:	80 e0       	ldi	r24, 0x00	; 0
     ec6:	03 c0       	rjmp	.+6      	; 0xece <CheckData+0x12e>
     ec8:	80 e0       	ldi	r24, 0x00	; 0
     eca:	01 c0       	rjmp	.+2      	; 0xece <CheckData+0x12e>
     ecc:	80 e0       	ldi	r24, 0x00	; 0
	 
 }
     ece:	2a 96       	adiw	r28, 0x0a	; 10
     ed0:	0f b6       	in	r0, 0x3f	; 63
     ed2:	f8 94       	cli
     ed4:	de bf       	out	0x3e, r29	; 62
     ed6:	0f be       	out	0x3f, r0	; 63
     ed8:	cd bf       	out	0x3d, r28	; 61
     eda:	df 91       	pop	r29
     edc:	cf 91       	pop	r28
     ede:	1f 91       	pop	r17
     ee0:	0f 91       	pop	r16
     ee2:	ff 90       	pop	r15
     ee4:	ef 90       	pop	r14
     ee6:	df 90       	pop	r13
     ee8:	cf 90       	pop	r12
     eea:	bf 90       	pop	r11
     eec:	08 95       	ret

00000eee <keypad_Intiat>:
 
 void keypad_Intiat (KEYPAD_PIN keypad)
 {
     eee:	0f 93       	push	r16
     ef0:	1f 93       	push	r17
     ef2:	cf 93       	push	r28
     ef4:	df 93       	push	r29
     ef6:	cd b7       	in	r28, 0x3d	; 61
     ef8:	de b7       	in	r29, 0x3e	; 62
     efa:	2a 97       	sbiw	r28, 0x0a	; 10
     efc:	0f b6       	in	r0, 0x3f	; 63
     efe:	f8 94       	cli
     f00:	de bf       	out	0x3e, r29	; 62
     f02:	0f be       	out	0x3f, r0	; 63
     f04:	cd bf       	out	0x3d, r28	; 61
     f06:	09 83       	std	Y+1, r16	; 0x01
     f08:	1a 83       	std	Y+2, r17	; 0x02
     f0a:	2b 83       	std	Y+3, r18	; 0x03
     f0c:	3c 83       	std	Y+4, r19	; 0x04
     f0e:	4d 83       	std	Y+5, r20	; 0x05
     f10:	5e 83       	std	Y+6, r21	; 0x06
     f12:	6f 83       	std	Y+7, r22	; 0x07
     f14:	78 87       	std	Y+8, r23	; 0x08
     f16:	89 87       	std	Y+9, r24	; 0x09
     f18:	9a 87       	std	Y+10, r25	; 0x0a
     f1a:	09 81       	ldd	r16, Y+1	; 0x01
     f1c:	1a 81       	ldd	r17, Y+2	; 0x02
	 /* Set the all pins of the Keypad input & And Make Its Initial Value Is Float by Set 0 To The Port And Connect a PullDowen Resistance */
	 DIO_portConfiguration(keypad.keypadREG_Port,0x00);
     f1e:	c8 01       	movw	r24, r16
     f20:	60 e0       	ldi	r22, 0x00	; 0
     f22:	0e 94 4c 01 	call	0x298	; 0x298 <DIO_portConfiguration>
	 DIO_portWrite(keypad.keypadREG_Port,0x00);
     f26:	c8 01       	movw	r24, r16
     f28:	60 e0       	ldi	r22, 0x00	; 0
     f2a:	0e 94 4f 01 	call	0x29e	; 0x29e <DIO_portWrite>
 }
     f2e:	2a 96       	adiw	r28, 0x0a	; 10
     f30:	0f b6       	in	r0, 0x3f	; 63
     f32:	f8 94       	cli
     f34:	de bf       	out	0x3e, r29	; 62
     f36:	0f be       	out	0x3f, r0	; 63
     f38:	cd bf       	out	0x3d, r28	; 61
     f3a:	df 91       	pop	r29
     f3c:	cf 91       	pop	r28
     f3e:	1f 91       	pop	r17
     f40:	0f 91       	pop	r16
     f42:	08 95       	ret

00000f44 <keypad_Read>:
 
 
 unsigned char keypad_Read(KEYPAD_PIN keypad)
 {
     f44:	8f 92       	push	r8
     f46:	9f 92       	push	r9
     f48:	af 92       	push	r10
     f4a:	bf 92       	push	r11
     f4c:	cf 92       	push	r12
     f4e:	df 92       	push	r13
     f50:	ef 92       	push	r14
     f52:	ff 92       	push	r15
     f54:	0f 93       	push	r16
     f56:	1f 93       	push	r17
     f58:	cf 93       	push	r28
     f5a:	df 93       	push	r29
     f5c:	cd b7       	in	r28, 0x3d	; 61
     f5e:	de b7       	in	r29, 0x3e	; 62
     f60:	2a 97       	sbiw	r28, 0x0a	; 10
     f62:	0f b6       	in	r0, 0x3f	; 63
     f64:	f8 94       	cli
     f66:	de bf       	out	0x3e, r29	; 62
     f68:	0f be       	out	0x3f, r0	; 63
     f6a:	cd bf       	out	0x3d, r28	; 61
     f6c:	09 83       	std	Y+1, r16	; 0x01
     f6e:	1a 83       	std	Y+2, r17	; 0x02
     f70:	2b 83       	std	Y+3, r18	; 0x03
     f72:	3c 83       	std	Y+4, r19	; 0x04
     f74:	4d 83       	std	Y+5, r20	; 0x05
     f76:	5e 83       	std	Y+6, r21	; 0x06
     f78:	c6 2e       	mov	r12, r22
     f7a:	6f 83       	std	Y+7, r22	; 0x07
     f7c:	b7 2e       	mov	r11, r23
     f7e:	78 87       	std	Y+8, r23	; 0x08
     f80:	89 87       	std	Y+9, r24	; 0x09
     f82:	9a 87       	std	Y+10, r25	; 0x0a
	 unsigned char DataRead = 0x00;
     f84:	f0 2e       	mov	r15, r16
     f86:	d1 2e       	mov	r13, r17
     f88:	a8 2e       	mov	r10, r24
     f8a:	99 2e       	mov	r9, r25
	 
	 /* CHECK IN THE COLUM 1 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL1,Output);
     f8c:	80 2f       	mov	r24, r16
     f8e:	91 2f       	mov	r25, r17
     f90:	42 e0       	ldi	r20, 0x02	; 2
     f92:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL1,HIGH);
     f96:	80 2f       	mov	r24, r16
     f98:	91 2f       	mov	r25, r17
     f9a:	6c 2d       	mov	r22, r12
     f9c:	41 e0       	ldi	r20, 0x01	; 1
     f9e:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
     
	 if (CheckData(keypad, COL1))
     fa2:	f9 82       	std	Y+1, r15	; 0x01
     fa4:	1a 83       	std	Y+2, r17	; 0x02
     fa6:	cf 82       	std	Y+7, r12	; 0x07
     fa8:	b8 86       	std	Y+8, r11	; 0x08
     faa:	a9 86       	std	Y+9, r10	; 0x09
     fac:	9a 86       	std	Y+10, r9	; 0x0a
     fae:	2b 81       	ldd	r18, Y+3	; 0x03
     fb0:	3c 81       	ldd	r19, Y+4	; 0x04
     fb2:	4d 81       	ldd	r20, Y+5	; 0x05
     fb4:	5e 81       	ldd	r21, Y+6	; 0x06
     fb6:	6c 2d       	mov	r22, r12
     fb8:	7b 2d       	mov	r23, r11
     fba:	8a 2d       	mov	r24, r10
     fbc:	99 2d       	mov	r25, r9
     fbe:	ee 24       	eor	r14, r14
     fc0:	0e 94 d0 06 	call	0xda0	; 0xda0 <CheckData>
     fc4:	88 23       	and	r24, r24
     fc6:	91 f0       	breq	.+36     	; 0xfec <keypad_Read+0xa8>
	 { 
		 DataRead = CheckData(keypad, COL1);
     fc8:	f9 82       	std	Y+1, r15	; 0x01
     fca:	da 82       	std	Y+2, r13	; 0x02
     fcc:	cf 82       	std	Y+7, r12	; 0x07
     fce:	b8 86       	std	Y+8, r11	; 0x08
     fd0:	a9 86       	std	Y+9, r10	; 0x09
     fd2:	9a 86       	std	Y+10, r9	; 0x0a
     fd4:	2b 81       	ldd	r18, Y+3	; 0x03
     fd6:	3c 81       	ldd	r19, Y+4	; 0x04
     fd8:	4d 81       	ldd	r20, Y+5	; 0x05
     fda:	5e 81       	ldd	r21, Y+6	; 0x06
     fdc:	6c 2d       	mov	r22, r12
     fde:	7b 2d       	mov	r23, r11
     fe0:	8a 2d       	mov	r24, r10
     fe2:	99 2d       	mov	r25, r9
     fe4:	0e 94 d0 06 	call	0xda0	; 0xda0 <CheckData>
     fe8:	88 2e       	mov	r8, r24
     fea:	01 c0       	rjmp	.+2      	; 0xfee <keypad_Read+0xaa>
 }
 
 
 unsigned char keypad_Read(KEYPAD_PIN keypad)
 {
	 unsigned char DataRead = 0x00;
     fec:	88 24       	eor	r8, r8
	 if (CheckData(keypad, COL1))
	 { 
		 DataRead = CheckData(keypad, COL1);
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL1,InputFloat);
     fee:	8f 2d       	mov	r24, r15
     ff0:	9d 2d       	mov	r25, r13
     ff2:	6c 2d       	mov	r22, r12
     ff4:	40 e0       	ldi	r20, 0x00	; 0
     ff6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
     ffa:	8f e1       	ldi	r24, 0x1F	; 31
     ffc:	9e e4       	ldi	r25, 0x4E	; 78
     ffe:	01 97       	sbiw	r24, 0x01	; 1
    1000:	f1 f7       	brne	.-4      	; 0xffe <keypad_Read+0xba>
    1002:	00 c0       	rjmp	.+0      	; 0x1004 <keypad_Read+0xc0>
    1004:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	
	 /* CHECK IN THE COLUM 2 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL2,Output);
    1006:	8f 2d       	mov	r24, r15
    1008:	9d 2d       	mov	r25, r13
    100a:	6b 2d       	mov	r22, r11
    100c:	42 e0       	ldi	r20, 0x02	; 2
    100e:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL2,HIGH);
    1012:	8f 2d       	mov	r24, r15
    1014:	9d 2d       	mov	r25, r13
    1016:	6b 2d       	mov	r22, r11
    1018:	41 e0       	ldi	r20, 0x01	; 1
    101a:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
     
	 if (CheckData(keypad, COL2))
    101e:	0f 2d       	mov	r16, r15
    1020:	f9 82       	std	Y+1, r15	; 0x01
    1022:	da 82       	std	Y+2, r13	; 0x02
    1024:	cf 82       	std	Y+7, r12	; 0x07
    1026:	b8 86       	std	Y+8, r11	; 0x08
    1028:	a9 86       	std	Y+9, r10	; 0x09
    102a:	9a 86       	std	Y+10, r9	; 0x0a
    102c:	1d 2d       	mov	r17, r13
    102e:	2b 81       	ldd	r18, Y+3	; 0x03
    1030:	3c 81       	ldd	r19, Y+4	; 0x04
    1032:	4d 81       	ldd	r20, Y+5	; 0x05
    1034:	5e 81       	ldd	r21, Y+6	; 0x06
    1036:	6c 2d       	mov	r22, r12
    1038:	7b 2d       	mov	r23, r11
    103a:	8a 2d       	mov	r24, r10
    103c:	99 2d       	mov	r25, r9
    103e:	ee 24       	eor	r14, r14
    1040:	e3 94       	inc	r14
    1042:	0e 94 d0 06 	call	0xda0	; 0xda0 <CheckData>
    1046:	88 23       	and	r24, r24
    1048:	89 f0       	breq	.+34     	; 0x106c <keypad_Read+0x128>
	 {
		 DataRead = CheckData(keypad, COL2);
    104a:	f9 82       	std	Y+1, r15	; 0x01
    104c:	da 82       	std	Y+2, r13	; 0x02
    104e:	cf 82       	std	Y+7, r12	; 0x07
    1050:	b8 86       	std	Y+8, r11	; 0x08
    1052:	a9 86       	std	Y+9, r10	; 0x09
    1054:	9a 86       	std	Y+10, r9	; 0x0a
    1056:	2b 81       	ldd	r18, Y+3	; 0x03
    1058:	3c 81       	ldd	r19, Y+4	; 0x04
    105a:	4d 81       	ldd	r20, Y+5	; 0x05
    105c:	5e 81       	ldd	r21, Y+6	; 0x06
    105e:	6c 2d       	mov	r22, r12
    1060:	7b 2d       	mov	r23, r11
    1062:	8a 2d       	mov	r24, r10
    1064:	99 2d       	mov	r25, r9
    1066:	0e 94 d0 06 	call	0xda0	; 0xda0 <CheckData>
    106a:	88 2e       	mov	r8, r24
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL2,InputFloat);
    106c:	8f 2d       	mov	r24, r15
    106e:	9d 2d       	mov	r25, r13
    1070:	6b 2d       	mov	r22, r11
    1072:	40 e0       	ldi	r20, 0x00	; 0
    1074:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
    1078:	8f e1       	ldi	r24, 0x1F	; 31
    107a:	9e e4       	ldi	r25, 0x4E	; 78
    107c:	01 97       	sbiw	r24, 0x01	; 1
    107e:	f1 f7       	brne	.-4      	; 0x107c <keypad_Read+0x138>
    1080:	00 c0       	rjmp	.+0      	; 0x1082 <keypad_Read+0x13e>
    1082:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 
	 /* CHECK IN THE COLUM 3 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL3,Output);
    1084:	8f 2d       	mov	r24, r15
    1086:	9d 2d       	mov	r25, r13
    1088:	6a 2d       	mov	r22, r10
    108a:	42 e0       	ldi	r20, 0x02	; 2
    108c:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL3,HIGH);
    1090:	8f 2d       	mov	r24, r15
    1092:	9d 2d       	mov	r25, r13
    1094:	6a 2d       	mov	r22, r10
    1096:	41 e0       	ldi	r20, 0x01	; 1
    1098:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
     
	 if (CheckData(keypad, COL3))
    109c:	0f 2d       	mov	r16, r15
    109e:	f9 82       	std	Y+1, r15	; 0x01
    10a0:	da 82       	std	Y+2, r13	; 0x02
    10a2:	cf 82       	std	Y+7, r12	; 0x07
    10a4:	b8 86       	std	Y+8, r11	; 0x08
    10a6:	a9 86       	std	Y+9, r10	; 0x09
    10a8:	9a 86       	std	Y+10, r9	; 0x0a
    10aa:	1d 2d       	mov	r17, r13
    10ac:	2b 81       	ldd	r18, Y+3	; 0x03
    10ae:	3c 81       	ldd	r19, Y+4	; 0x04
    10b0:	4d 81       	ldd	r20, Y+5	; 0x05
    10b2:	5e 81       	ldd	r21, Y+6	; 0x06
    10b4:	6c 2d       	mov	r22, r12
    10b6:	7b 2d       	mov	r23, r11
    10b8:	8a 2d       	mov	r24, r10
    10ba:	99 2d       	mov	r25, r9
    10bc:	ee 24       	eor	r14, r14
    10be:	68 94       	set
    10c0:	e1 f8       	bld	r14, 1
    10c2:	0e 94 d0 06 	call	0xda0	; 0xda0 <CheckData>
    10c6:	88 23       	and	r24, r24
    10c8:	89 f0       	breq	.+34     	; 0x10ec <keypad_Read+0x1a8>
	 { 
		 DataRead = CheckData(keypad, COL3);
    10ca:	f9 82       	std	Y+1, r15	; 0x01
    10cc:	da 82       	std	Y+2, r13	; 0x02
    10ce:	cf 82       	std	Y+7, r12	; 0x07
    10d0:	b8 86       	std	Y+8, r11	; 0x08
    10d2:	a9 86       	std	Y+9, r10	; 0x09
    10d4:	9a 86       	std	Y+10, r9	; 0x0a
    10d6:	2b 81       	ldd	r18, Y+3	; 0x03
    10d8:	3c 81       	ldd	r19, Y+4	; 0x04
    10da:	4d 81       	ldd	r20, Y+5	; 0x05
    10dc:	5e 81       	ldd	r21, Y+6	; 0x06
    10de:	6c 2d       	mov	r22, r12
    10e0:	7b 2d       	mov	r23, r11
    10e2:	8a 2d       	mov	r24, r10
    10e4:	99 2d       	mov	r25, r9
    10e6:	0e 94 d0 06 	call	0xda0	; 0xda0 <CheckData>
    10ea:	88 2e       	mov	r8, r24
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL3,InputFloat);
    10ec:	8f 2d       	mov	r24, r15
    10ee:	9d 2d       	mov	r25, r13
    10f0:	6a 2d       	mov	r22, r10
    10f2:	40 e0       	ldi	r20, 0x00	; 0
    10f4:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
    10f8:	8f e1       	ldi	r24, 0x1F	; 31
    10fa:	9e e4       	ldi	r25, 0x4E	; 78
    10fc:	01 97       	sbiw	r24, 0x01	; 1
    10fe:	f1 f7       	brne	.-4      	; 0x10fc <keypad_Read+0x1b8>
    1100:	00 c0       	rjmp	.+0      	; 0x1102 <keypad_Read+0x1be>
    1102:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 
	 /* CHECK IN THE COLUM 4 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL4,Output);
    1104:	8f 2d       	mov	r24, r15
    1106:	9d 2d       	mov	r25, r13
    1108:	69 2d       	mov	r22, r9
    110a:	42 e0       	ldi	r20, 0x02	; 2
    110c:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL4,HIGH);
    1110:	8f 2d       	mov	r24, r15
    1112:	9d 2d       	mov	r25, r13
    1114:	69 2d       	mov	r22, r9
    1116:	41 e0       	ldi	r20, 0x01	; 1
    1118:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
     
	 if (CheckData(keypad, COL4))
    111c:	0f 2d       	mov	r16, r15
    111e:	f9 82       	std	Y+1, r15	; 0x01
    1120:	da 82       	std	Y+2, r13	; 0x02
    1122:	cf 82       	std	Y+7, r12	; 0x07
    1124:	b8 86       	std	Y+8, r11	; 0x08
    1126:	a9 86       	std	Y+9, r10	; 0x09
    1128:	9a 86       	std	Y+10, r9	; 0x0a
    112a:	1d 2d       	mov	r17, r13
    112c:	2b 81       	ldd	r18, Y+3	; 0x03
    112e:	3c 81       	ldd	r19, Y+4	; 0x04
    1130:	4d 81       	ldd	r20, Y+5	; 0x05
    1132:	5e 81       	ldd	r21, Y+6	; 0x06
    1134:	6c 2d       	mov	r22, r12
    1136:	7b 2d       	mov	r23, r11
    1138:	8a 2d       	mov	r24, r10
    113a:	99 2d       	mov	r25, r9
    113c:	0f 2e       	mov	r0, r31
    113e:	f3 e0       	ldi	r31, 0x03	; 3
    1140:	ef 2e       	mov	r14, r31
    1142:	f0 2d       	mov	r31, r0
    1144:	0e 94 d0 06 	call	0xda0	; 0xda0 <CheckData>
    1148:	88 23       	and	r24, r24
    114a:	89 f0       	breq	.+34     	; 0x116e <keypad_Read+0x22a>
	 {
		 DataRead = CheckData(keypad, COL4);
    114c:	f9 82       	std	Y+1, r15	; 0x01
    114e:	da 82       	std	Y+2, r13	; 0x02
    1150:	cf 82       	std	Y+7, r12	; 0x07
    1152:	b8 86       	std	Y+8, r11	; 0x08
    1154:	a9 86       	std	Y+9, r10	; 0x09
    1156:	9a 86       	std	Y+10, r9	; 0x0a
    1158:	2b 81       	ldd	r18, Y+3	; 0x03
    115a:	3c 81       	ldd	r19, Y+4	; 0x04
    115c:	4d 81       	ldd	r20, Y+5	; 0x05
    115e:	5e 81       	ldd	r21, Y+6	; 0x06
    1160:	6c 2d       	mov	r22, r12
    1162:	7b 2d       	mov	r23, r11
    1164:	8a 2d       	mov	r24, r10
    1166:	99 2d       	mov	r25, r9
    1168:	0e 94 d0 06 	call	0xda0	; 0xda0 <CheckData>
    116c:	88 2e       	mov	r8, r24
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL4,InputFloat);
    116e:	8f 2d       	mov	r24, r15
    1170:	9d 2d       	mov	r25, r13
    1172:	69 2d       	mov	r22, r9
    1174:	40 e0       	ldi	r20, 0x00	; 0
    1176:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
    117a:	8f e1       	ldi	r24, 0x1F	; 31
    117c:	9e e4       	ldi	r25, 0x4E	; 78
    117e:	01 97       	sbiw	r24, 0x01	; 1
    1180:	f1 f7       	brne	.-4      	; 0x117e <keypad_Read+0x23a>
    1182:	00 c0       	rjmp	.+0      	; 0x1184 <keypad_Read+0x240>
    1184:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 return DataRead;
	 
    1186:	88 2d       	mov	r24, r8
    1188:	2a 96       	adiw	r28, 0x0a	; 10
    118a:	0f b6       	in	r0, 0x3f	; 63
    118c:	f8 94       	cli
    118e:	de bf       	out	0x3e, r29	; 62
    1190:	0f be       	out	0x3f, r0	; 63
    1192:	cd bf       	out	0x3d, r28	; 61
    1194:	df 91       	pop	r29
    1196:	cf 91       	pop	r28
    1198:	1f 91       	pop	r17
    119a:	0f 91       	pop	r16
    119c:	ff 90       	pop	r15
    119e:	ef 90       	pop	r14
    11a0:	df 90       	pop	r13
    11a2:	cf 90       	pop	r12
    11a4:	bf 90       	pop	r11
    11a6:	af 90       	pop	r10
    11a8:	9f 90       	pop	r9
    11aa:	8f 90       	pop	r8
    11ac:	08 95       	ret

000011ae <MotorDriver_Setup>:
  #include "L298N_MotorDriver.h"
  
  
  
  void MotorDriver_Setup(MotorDriver PINS)
  {
    11ae:	0f 93       	push	r16
    11b0:	1f 93       	push	r17
    11b2:	cf 93       	push	r28
    11b4:	df 93       	push	r29
    11b6:	cd b7       	in	r28, 0x3d	; 61
    11b8:	de b7       	in	r29, 0x3e	; 62
    11ba:	28 97       	sbiw	r28, 0x08	; 8
    11bc:	0f b6       	in	r0, 0x3f	; 63
    11be:	f8 94       	cli
    11c0:	de bf       	out	0x3e, r29	; 62
    11c2:	0f be       	out	0x3f, r0	; 63
    11c4:	cd bf       	out	0x3d, r28	; 61
    11c6:	29 83       	std	Y+1, r18	; 0x01
    11c8:	3a 83       	std	Y+2, r19	; 0x02
    11ca:	4b 83       	std	Y+3, r20	; 0x03
    11cc:	5c 83       	std	Y+4, r21	; 0x04
    11ce:	6d 83       	std	Y+5, r22	; 0x05
    11d0:	7e 83       	std	Y+6, r23	; 0x06
    11d2:	8f 83       	std	Y+7, r24	; 0x07
    11d4:	98 87       	std	Y+8, r25	; 0x08
    11d6:	09 81       	ldd	r16, Y+1	; 0x01
    11d8:	1a 81       	ldd	r17, Y+2	; 0x02
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA1,Output);
    11da:	c8 01       	movw	r24, r16
    11dc:	64 2f       	mov	r22, r20
    11de:	42 e0       	ldi	r20, 0x02	; 2
    11e0:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA2,Output);
    11e4:	c8 01       	movw	r24, r16
    11e6:	6c 81       	ldd	r22, Y+4	; 0x04
    11e8:	42 e0       	ldi	r20, 0x02	; 2
    11ea:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA3,Output);
    11ee:	c8 01       	movw	r24, r16
    11f0:	6d 81       	ldd	r22, Y+5	; 0x05
    11f2:	42 e0       	ldi	r20, 0x02	; 2
    11f4:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA4,Output);
    11f8:	c8 01       	movw	r24, r16
    11fa:	6e 81       	ldd	r22, Y+6	; 0x06
    11fc:	42 e0       	ldi	r20, 0x02	; 2
    11fe:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
  }
    1202:	28 96       	adiw	r28, 0x08	; 8
    1204:	0f b6       	in	r0, 0x3f	; 63
    1206:	f8 94       	cli
    1208:	de bf       	out	0x3e, r29	; 62
    120a:	0f be       	out	0x3f, r0	; 63
    120c:	cd bf       	out	0x3d, r28	; 61
    120e:	df 91       	pop	r29
    1210:	cf 91       	pop	r28
    1212:	1f 91       	pop	r17
    1214:	0f 91       	pop	r16
    1216:	08 95       	ret

00001218 <Motor_Direction>:
  
  
  
  void Motor_Direction(MotorDriver motordirection)
  {
    1218:	cf 92       	push	r12
    121a:	df 92       	push	r13
    121c:	ef 92       	push	r14
    121e:	ff 92       	push	r15
    1220:	0f 93       	push	r16
    1222:	1f 93       	push	r17
    1224:	cf 93       	push	r28
    1226:	df 93       	push	r29
    1228:	cd b7       	in	r28, 0x3d	; 61
    122a:	de b7       	in	r29, 0x3e	; 62
    122c:	28 97       	sbiw	r28, 0x08	; 8
    122e:	0f b6       	in	r0, 0x3f	; 63
    1230:	f8 94       	cli
    1232:	de bf       	out	0x3e, r29	; 62
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	cd bf       	out	0x3d, r28	; 61
    1238:	29 83       	std	Y+1, r18	; 0x01
    123a:	3a 83       	std	Y+2, r19	; 0x02
    123c:	f4 2e       	mov	r15, r20
    123e:	4b 83       	std	Y+3, r20	; 0x03
    1240:	e5 2e       	mov	r14, r21
    1242:	5c 83       	std	Y+4, r21	; 0x04
    1244:	d6 2e       	mov	r13, r22
    1246:	6d 83       	std	Y+5, r22	; 0x05
    1248:	c7 2e       	mov	r12, r23
    124a:	7e 83       	std	Y+6, r23	; 0x06
    124c:	8f 83       	std	Y+7, r24	; 0x07
    124e:	98 87       	std	Y+8, r25	; 0x08
    1250:	09 81       	ldd	r16, Y+1	; 0x01
    1252:	1a 81       	ldd	r17, Y+2	; 0x02
	  switch (motordirection.MOTORNUM)
    1254:	88 23       	and	r24, r24
    1256:	21 f0       	breq	.+8      	; 0x1260 <Motor_Direction+0x48>
    1258:	81 30       	cpi	r24, 0x01	; 1
    125a:	09 f0       	breq	.+2      	; 0x125e <Motor_Direction+0x46>
    125c:	a8 c0       	rjmp	.+336    	; 0x13ae <Motor_Direction+0x196>
    125e:	4a c0       	rjmp	.+148    	; 0x12f4 <Motor_Direction+0xdc>
	  {
		  case Two_Motor :
		  /* in This Case Motor A is the Back Motor that give The Main Motion To The Robot And Th Motor B is Direction Motor */
		        switch(motordirection.MOVMENT)
    1260:	91 30       	cpi	r25, 0x01	; 1
    1262:	99 f0       	breq	.+38     	; 0x128a <Motor_Direction+0x72>
    1264:	91 30       	cpi	r25, 0x01	; 1
    1266:	30 f0       	brcs	.+12     	; 0x1274 <Motor_Direction+0x5c>
    1268:	92 30       	cpi	r25, 0x02	; 2
    126a:	d1 f0       	breq	.+52     	; 0x12a0 <Motor_Direction+0x88>
    126c:	93 30       	cpi	r25, 0x03	; 3
    126e:	09 f0       	breq	.+2      	; 0x1272 <Motor_Direction+0x5a>
    1270:	41 c0       	rjmp	.+130    	; 0x12f4 <Motor_Direction+0xdc>
    1272:	2b c0       	rjmp	.+86     	; 0x12ca <Motor_Direction+0xb2>
				{
					case Forward:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    1274:	c8 01       	movw	r24, r16
    1276:	64 2f       	mov	r22, r20
    1278:	41 e0       	ldi	r20, 0x01	; 1
    127a:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    127e:	c8 01       	movw	r24, r16
    1280:	6e 2d       	mov	r22, r14
    1282:	40 e0       	ldi	r20, 0x00	; 0
    1284:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
    1288:	3f c0       	rjmp	.+126    	; 0x1308 <Motor_Direction+0xf0>
						 break;
					case Reverce:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
    128a:	c8 01       	movw	r24, r16
    128c:	64 2f       	mov	r22, r20
    128e:	40 e0       	ldi	r20, 0x00	; 0
    1290:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,HIGH);
    1294:	c8 01       	movw	r24, r16
    1296:	6e 2d       	mov	r22, r14
    1298:	41 e0       	ldi	r20, 0x01	; 1
    129a:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
    129e:	49 c0       	rjmp	.+146    	; 0x1332 <Motor_Direction+0x11a>
						 break;
				    case Left:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    12a0:	c8 01       	movw	r24, r16
    12a2:	64 2f       	mov	r22, r20
    12a4:	41 e0       	ldi	r20, 0x01	; 1
    12a6:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    12aa:	c8 01       	movw	r24, r16
    12ac:	6e 2d       	mov	r22, r14
    12ae:	40 e0       	ldi	r20, 0x00	; 0
    12b0:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,HIGH);
    12b4:	c8 01       	movw	r24, r16
    12b6:	6d 2d       	mov	r22, r13
    12b8:	41 e0       	ldi	r20, 0x01	; 1
    12ba:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
    12be:	c8 01       	movw	r24, r16
    12c0:	6c 2d       	mov	r22, r12
    12c2:	40 e0       	ldi	r20, 0x00	; 0
    12c4:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
    12c8:	49 c0       	rjmp	.+146    	; 0x135c <Motor_Direction+0x144>
						 break;
					case Right:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    12ca:	c8 01       	movw	r24, r16
    12cc:	64 2f       	mov	r22, r20
    12ce:	41 e0       	ldi	r20, 0x01	; 1
    12d0:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    12d4:	c8 01       	movw	r24, r16
    12d6:	6e 2d       	mov	r22, r14
    12d8:	40 e0       	ldi	r20, 0x00	; 0
    12da:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,LOW);
    12de:	c8 01       	movw	r24, r16
    12e0:	6d 2d       	mov	r22, r13
    12e2:	40 e0       	ldi	r20, 0x00	; 0
    12e4:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,HIGH);
    12e8:	c8 01       	movw	r24, r16
    12ea:	6c 2d       	mov	r22, r12
    12ec:	41 e0       	ldi	r20, 0x01	; 1
    12ee:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
    12f2:	49 c0       	rjmp	.+146    	; 0x1386 <Motor_Direction+0x16e>
					default:
					       /* Handle The Error Function */
						   break;
				}	
		case More:
		     switch (motordirection.MOVMENT)
    12f4:	91 30       	cpi	r25, 0x01	; 1
    12f6:	e9 f0       	breq	.+58     	; 0x1332 <Motor_Direction+0x11a>
    12f8:	91 30       	cpi	r25, 0x01	; 1
    12fa:	30 f0       	brcs	.+12     	; 0x1308 <Motor_Direction+0xf0>
    12fc:	92 30       	cpi	r25, 0x02	; 2
    12fe:	71 f1       	breq	.+92     	; 0x135c <Motor_Direction+0x144>
    1300:	93 30       	cpi	r25, 0x03	; 3
    1302:	09 f0       	breq	.+2      	; 0x1306 <Motor_Direction+0xee>
    1304:	54 c0       	rjmp	.+168    	; 0x13ae <Motor_Direction+0x196>
    1306:	3f c0       	rjmp	.+126    	; 0x1386 <Motor_Direction+0x16e>
			 {
				 case Forward:
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    1308:	c8 01       	movw	r24, r16
    130a:	6f 2d       	mov	r22, r15
    130c:	41 e0       	ldi	r20, 0x01	; 1
    130e:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    1312:	c8 01       	movw	r24, r16
    1314:	6e 2d       	mov	r22, r14
    1316:	40 e0       	ldi	r20, 0x00	; 0
    1318:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,HIGH);
    131c:	c8 01       	movw	r24, r16
    131e:	6d 2d       	mov	r22, r13
    1320:	41 e0       	ldi	r20, 0x01	; 1
    1322:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
    1326:	c8 01       	movw	r24, r16
    1328:	6c 2d       	mov	r22, r12
    132a:	40 e0       	ldi	r20, 0x00	; 0
    132c:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 break;
    1330:	3e c0       	rjmp	.+124    	; 0x13ae <Motor_Direction+0x196>
				 case Reverce:
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
    1332:	c8 01       	movw	r24, r16
    1334:	6f 2d       	mov	r22, r15
    1336:	40 e0       	ldi	r20, 0x00	; 0
    1338:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,HIGH);
    133c:	c8 01       	movw	r24, r16
    133e:	6e 2d       	mov	r22, r14
    1340:	41 e0       	ldi	r20, 0x01	; 1
    1342:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
    1346:	c8 01       	movw	r24, r16
    1348:	6f 2d       	mov	r22, r15
    134a:	40 e0       	ldi	r20, 0x00	; 0
    134c:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,HIGH);
    1350:	c8 01       	movw	r24, r16
    1352:	6e 2d       	mov	r22, r14
    1354:	41 e0       	ldi	r20, 0x01	; 1
    1356:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 break;
    135a:	29 c0       	rjmp	.+82     	; 0x13ae <Motor_Direction+0x196>
				 case Left:
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    135c:	c8 01       	movw	r24, r16
    135e:	6f 2d       	mov	r22, r15
    1360:	41 e0       	ldi	r20, 0x01	; 1
    1362:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    1366:	c8 01       	movw	r24, r16
    1368:	6e 2d       	mov	r22, r14
    136a:	40 e0       	ldi	r20, 0x00	; 0
    136c:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,HIGH);
    1370:	c8 01       	movw	r24, r16
    1372:	6d 2d       	mov	r22, r13
    1374:	41 e0       	ldi	r20, 0x01	; 1
    1376:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
    137a:	c8 01       	movw	r24, r16
    137c:	6c 2d       	mov	r22, r12
    137e:	40 e0       	ldi	r20, 0x00	; 0
    1380:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 break;
    1384:	14 c0       	rjmp	.+40     	; 0x13ae <Motor_Direction+0x196>
				 case Right:
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    1386:	c8 01       	movw	r24, r16
    1388:	6f 2d       	mov	r22, r15
    138a:	41 e0       	ldi	r20, 0x01	; 1
    138c:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    1390:	c8 01       	movw	r24, r16
    1392:	6e 2d       	mov	r22, r14
    1394:	40 e0       	ldi	r20, 0x00	; 0
    1396:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,LOW);
    139a:	c8 01       	movw	r24, r16
    139c:	6d 2d       	mov	r22, r13
    139e:	40 e0       	ldi	r20, 0x00	; 0
    13a0:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,HIGH);
    13a4:	c8 01       	movw	r24, r16
    13a6:	6c 2d       	mov	r22, r12
    13a8:	41 e0       	ldi	r20, 0x01	; 1
    13aa:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
				 default:
				 /* Handle The Error Function */
				 break;
			 }				 				
	  }		  
    13ae:	28 96       	adiw	r28, 0x08	; 8
    13b0:	0f b6       	in	r0, 0x3f	; 63
    13b2:	f8 94       	cli
    13b4:	de bf       	out	0x3e, r29	; 62
    13b6:	0f be       	out	0x3f, r0	; 63
    13b8:	cd bf       	out	0x3d, r28	; 61
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	1f 91       	pop	r17
    13c0:	0f 91       	pop	r16
    13c2:	ff 90       	pop	r15
    13c4:	ef 90       	pop	r14
    13c6:	df 90       	pop	r13
    13c8:	cf 90       	pop	r12
    13ca:	08 95       	ret

000013cc <Send_instruction>:
  #define MAX_NWCHAR   (8)
  
    void Send_instruction(unsigned char instruction)
	{
		/* The RS And The RW Must Be RESET When Send Instruction To The LCD */
		RESET_Bit(LCD_CONTROL_REG_OP, RS);
    13cc:	c0 98       	cbi	0x18, 0	; 24
		RESET_Bit(LCD_CONTROL_REG_OP, RW);
    13ce:	c1 98       	cbi	0x18, 1	; 24
    13d0:	ef e9       	ldi	r30, 0x9F	; 159
    13d2:	ff e0       	ldi	r31, 0x0F	; 15
    13d4:	31 97       	sbiw	r30, 0x01	; 1
    13d6:	f1 f7       	brne	.-4      	; 0x13d4 <Send_instruction+0x8>
    13d8:	00 c0       	rjmp	.+0      	; 0x13da <Send_instruction+0xe>
    13da:	00 00       	nop
		/* Delay of Address Set 60ns minimum This In The Ideal State */
		_delay_ms(1);
		
		/* We WriteTo the LCD InThe Falling Of The Enable Pin */
		/* Set The Enable Pin */
		SET_Bit(LCD_CONTROL_REG_OP, E);
    13dc:	c2 9a       	sbi	0x18, 2	; 24
    13de:	ef e9       	ldi	r30, 0x9F	; 159
    13e0:	ff e0       	ldi	r31, 0x0F	; 15
    13e2:	31 97       	sbiw	r30, 0x01	; 1
    13e4:	f1 f7       	brne	.-4      	; 0x13e2 <Send_instruction+0x16>
    13e6:	00 c0       	rjmp	.+0      	; 0x13e8 <Send_instruction+0x1c>
    13e8:	00 00       	nop
		
	   #else 
	        /* At The First We Send The MSB 4-bit Of The Instruction So We handle If The User Connect LCD in The Upper Or Lower Pin Of The Port */
	        #ifdef LCD_UPPER_DATA_PORT
			       /* Setup The Data Port To hold The Data By Reset the Upper Pin */
				   LCD_DATA_REG_OP &= 0x0F ; 
    13ea:	9b b3       	in	r25, 0x1b	; 27
    13ec:	9f 70       	andi	r25, 0x0F	; 15
    13ee:	9b bb       	out	0x1b, r25	; 27
				   LCD_DATA_REG_OP |= (instruction & 0xF0);
    13f0:	9b b3       	in	r25, 0x1b	; 27
    13f2:	28 2f       	mov	r18, r24
    13f4:	20 7f       	andi	r18, 0xF0	; 240
    13f6:	92 2b       	or	r25, r18
    13f8:	9b bb       	out	0x1b, r25	; 27
    13fa:	ef e9       	ldi	r30, 0x9F	; 159
    13fc:	ff e0       	ldi	r31, 0x0F	; 15
    13fe:	31 97       	sbiw	r30, 0x01	; 1
    1400:	f1 f7       	brne	.-4      	; 0x13fe <Send_instruction+0x32>
    1402:	00 c0       	rjmp	.+0      	; 0x1404 <Send_instruction+0x38>
    1404:	00 00       	nop
			
			/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
			_delay_ms(1);
			
			/* disable LCD E=0 */
			RESET_Bit(LCD_CONTROL_REG_OP,E);
    1406:	c2 98       	cbi	0x18, 2	; 24
    1408:	ef e9       	ldi	r30, 0x9F	; 159
    140a:	ff e0       	ldi	r31, 0x0F	; 15
    140c:	31 97       	sbiw	r30, 0x01	; 1
    140e:	f1 f7       	brne	.-4      	; 0x140c <Send_instruction+0x40>
    1410:	00 c0       	rjmp	.+0      	; 0x1412 <Send_instruction+0x46>
    1412:	00 00       	nop
			/* Data Hold delay Th = 10ns */
			_delay_ms(1);
		    
			/* Reconfigure The E Pin To Prepare To Send The Next 4-bit LSB */
		    SET_Bit(LCD_CONTROL_REG_OP, E);
    1414:	c2 9a       	sbi	0x18, 2	; 24
    1416:	ef e9       	ldi	r30, 0x9F	; 159
    1418:	ff e0       	ldi	r31, 0x0F	; 15
    141a:	31 97       	sbiw	r30, 0x01	; 1
    141c:	f1 f7       	brne	.-4      	; 0x141a <Send_instruction+0x4e>
    141e:	00 c0       	rjmp	.+0      	; 0x1420 <Send_instruction+0x54>
    1420:	00 00       	nop
		    /* delay for processing PW min 450ns This In The Ideal State */
		    _delay_ms(1);
			
			#ifdef LCD_UPPER_DATA_PORT
			       /* Setup The Data Port To hold The Data By Reset the Upper Pin */
			       LCD_DATA_REG_OP &= 0x0F ;
    1422:	9b b3       	in	r25, 0x1b	; 27
    1424:	9f 70       	andi	r25, 0x0F	; 15
    1426:	9b bb       	out	0x1b, r25	; 27
			       LCD_DATA_REG_OP |= ((instruction << 4) & 0xF0);
    1428:	9b b3       	in	r25, 0x1b	; 27
    142a:	82 95       	swap	r24
    142c:	80 7f       	andi	r24, 0xF0	; 240
    142e:	89 2b       	or	r24, r25
    1430:	8b bb       	out	0x1b, r24	; 27
    1432:	8f e9       	ldi	r24, 0x9F	; 159
    1434:	9f e0       	ldi	r25, 0x0F	; 15
    1436:	01 97       	sbiw	r24, 0x01	; 1
    1438:	f1 f7       	brne	.-4      	; 0x1436 <Send_instruction+0x6a>
    143a:	00 c0       	rjmp	.+0      	; 0x143c <Send_instruction+0x70>
    143c:	00 00       	nop
		     	   LCD_DATA_REG_OP |= (instruction & 0x0F);  
            #endif
			/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
			_delay_ms(1);
			/* disable LCD E=0 */
			RESET_Bit(LCD_CONTROL_REG_OP,E);
    143e:	c2 98       	cbi	0x18, 2	; 24
    1440:	ef e9       	ldi	r30, 0x9F	; 159
    1442:	ff e0       	ldi	r31, 0x0F	; 15
    1444:	31 97       	sbiw	r30, 0x01	; 1
    1446:	f1 f7       	brne	.-4      	; 0x1444 <Send_instruction+0x78>
    1448:	00 c0       	rjmp	.+0      	; 0x144a <Send_instruction+0x7e>
    144a:	00 00       	nop
			/* Data Hold delay Th = 10ns This In The Ideal State*/
			_delay_ms(1);
			#endif
	}	
    144c:	08 95       	ret

0000144e <LCD_init>:
		/* Set The Direction Of The 8 Data Bit As Output */
		LCD_DATA_REG_DIR = 0xFF;
		#else
		#ifdef LCD_UPPER_DATA_PORT
		/* Set The Direction Of The Higher 4 Data Bit As Output */
		LCD_DATA_REG_DIR |= 0xF0;
    144e:	8a b3       	in	r24, 0x1a	; 26
    1450:	80 6f       	ori	r24, 0xF0	; 240
    1452:	8a bb       	out	0x1a, r24	; 26
		#else
		/* Set The Direction Of The Lower 4 Data Bit As Output */
		LCD_DATA_REG_DIR |= 0x0F;
		#endif
		/* Setup The Control Pin As A Output Pin */
		LCD_CONTROL_REG_DIR |= (1 << E) | (1 << RS) | (1 << RW);
    1454:	87 b3       	in	r24, 0x17	; 23
    1456:	87 60       	ori	r24, 0x07	; 7
    1458:	87 bb       	out	0x17, r24	; 23
		
		
			 /* Set LCD to Use 4 bits Op */
			 Send_instruction(RETURN_HOME);
    145a:	82 e0       	ldi	r24, 0x02	; 2
    145c:	0e 94 e6 09 	call	0x13cc	; 0x13cc <Send_instruction>
	   #endif
	   Send_instruction(FUNCTION_SET);
    1460:	88 e2       	ldi	r24, 0x28	; 40
    1462:	0e 94 e6 09 	call	0x13cc	; 0x13cc <Send_instruction>
	   Send_instruction(DISPLAY_ON);
    1466:	8c e0       	ldi	r24, 0x0C	; 12
    1468:	0e 94 e6 09 	call	0x13cc	; 0x13cc <Send_instruction>
	   Send_instruction(CLEAR_DISPALY);
    146c:	81 e0       	ldi	r24, 0x01	; 1
    146e:	0e 94 e6 09 	call	0x13cc	; 0x13cc <Send_instruction>
		
	}
    1472:	08 95       	ret

00001474 <LCD_Clear>:
	
			
    void LCD_Clear(void)
	{
		/* Clear Instruction */
		Send_instruction(CLEAR_DISPALY);
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	0e 94 e6 09 	call	0x13cc	; 0x13cc <Send_instruction>
	}	
    147a:	08 95       	ret

0000147c <LCD_DisplayChar>:
	
		
    void LCD_DisplayChar(unsigned char Data)
	{
		/* The RS  Must Be RESET and The RW must be SET When Send Data To The LCD */
		SET_Bit(LCD_CONTROL_REG_OP, RS);
    147c:	c0 9a       	sbi	0x18, 0	; 24
		RESET_Bit(LCD_CONTROL_REG_OP, RW);
    147e:	c1 98       	cbi	0x18, 1	; 24
    1480:	ef e9       	ldi	r30, 0x9F	; 159
    1482:	ff e0       	ldi	r31, 0x0F	; 15
    1484:	31 97       	sbiw	r30, 0x01	; 1
    1486:	f1 f7       	brne	.-4      	; 0x1484 <LCD_DisplayChar+0x8>
    1488:	00 c0       	rjmp	.+0      	; 0x148a <LCD_DisplayChar+0xe>
    148a:	00 00       	nop
		/* Delay of Address Set 60ns minimum This In The Ideal State */
		_delay_ms(1);
		/* We WriteTo the LCD InThe Falling Of The Enable Pin */
		/* Set The Enable Pin */
		SET_Bit(LCD_CONTROL_REG_OP, E);
    148c:	c2 9a       	sbi	0x18, 2	; 24
    148e:	ef e9       	ldi	r30, 0x9F	; 159
    1490:	ff e0       	ldi	r31, 0x0F	; 15
    1492:	31 97       	sbiw	r30, 0x01	; 1
    1494:	f1 f7       	brne	.-4      	; 0x1492 <LCD_DisplayChar+0x16>
    1496:	00 c0       	rjmp	.+0      	; 0x1498 <LCD_DisplayChar+0x1c>
    1498:	00 00       	nop
		
		#else
		/* At The First We Send The MSB 4-bit Of The Instruction So We handle If The User Connect LCD in The Upper Or Lower Pin Of The Port */
		#ifdef LCD_UPPER_DATA_PORT
		/* Setup The Data Port To hold The Data By Reset the Upper Pin */
		LCD_DATA_REG_OP &= 0x0F ;
    149a:	9b b3       	in	r25, 0x1b	; 27
    149c:	9f 70       	andi	r25, 0x0F	; 15
    149e:	9b bb       	out	0x1b, r25	; 27
		LCD_DATA_REG_OP |= (Data & 0xF0);
    14a0:	9b b3       	in	r25, 0x1b	; 27
    14a2:	28 2f       	mov	r18, r24
    14a4:	20 7f       	andi	r18, 0xF0	; 240
    14a6:	92 2b       	or	r25, r18
    14a8:	9b bb       	out	0x1b, r25	; 27
    14aa:	ef e9       	ldi	r30, 0x9F	; 159
    14ac:	ff e0       	ldi	r31, 0x0F	; 15
    14ae:	31 97       	sbiw	r30, 0x01	; 1
    14b0:	f1 f7       	brne	.-4      	; 0x14ae <LCD_DisplayChar+0x32>
    14b2:	00 c0       	rjmp	.+0      	; 0x14b4 <LCD_DisplayChar+0x38>
    14b4:	00 00       	nop
		
		/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
		_delay_ms(1);
		
		/* disable LCD E=0 */
		RESET_Bit(LCD_CONTROL_REG_OP,E);
    14b6:	c2 98       	cbi	0x18, 2	; 24
    14b8:	ef e9       	ldi	r30, 0x9F	; 159
    14ba:	ff e0       	ldi	r31, 0x0F	; 15
    14bc:	31 97       	sbiw	r30, 0x01	; 1
    14be:	f1 f7       	brne	.-4      	; 0x14bc <LCD_DisplayChar+0x40>
    14c0:	00 c0       	rjmp	.+0      	; 0x14c2 <LCD_DisplayChar+0x46>
    14c2:	00 00       	nop
		/* Data Hold delay Th = 10ns */
		_delay_ms(1);
		
		/* Reconfigure The E Pin To Prepare To Send The Next 4-bit LSB */
		SET_Bit(LCD_CONTROL_REG_OP, E);
    14c4:	c2 9a       	sbi	0x18, 2	; 24
    14c6:	ef e9       	ldi	r30, 0x9F	; 159
    14c8:	ff e0       	ldi	r31, 0x0F	; 15
    14ca:	31 97       	sbiw	r30, 0x01	; 1
    14cc:	f1 f7       	brne	.-4      	; 0x14ca <LCD_DisplayChar+0x4e>
    14ce:	00 c0       	rjmp	.+0      	; 0x14d0 <LCD_DisplayChar+0x54>
    14d0:	00 00       	nop
		/* delay for processing PW min 450ns This In The Ideal State */
		_delay_ms(1);
		
		#ifdef LCD_UPPER_DATA_PORT
		/* Setup The Data Port To hold The Data By Reset the Upper Pin */
		LCD_DATA_REG_OP &= 0x0F ;
    14d2:	9b b3       	in	r25, 0x1b	; 27
    14d4:	9f 70       	andi	r25, 0x0F	; 15
    14d6:	9b bb       	out	0x1b, r25	; 27
		LCD_DATA_REG_OP |= ((Data << 4) & 0xF0);
    14d8:	9b b3       	in	r25, 0x1b	; 27
    14da:	82 95       	swap	r24
    14dc:	80 7f       	andi	r24, 0xF0	; 240
    14de:	89 2b       	or	r24, r25
    14e0:	8b bb       	out	0x1b, r24	; 27
    14e2:	8f e9       	ldi	r24, 0x9F	; 159
    14e4:	9f e0       	ldi	r25, 0x0F	; 15
    14e6:	01 97       	sbiw	r24, 0x01	; 1
    14e8:	f1 f7       	brne	.-4      	; 0x14e6 <LCD_DisplayChar+0x6a>
    14ea:	00 c0       	rjmp	.+0      	; 0x14ec <LCD_DisplayChar+0x70>
    14ec:	00 00       	nop
		LCD_DATA_REG_OP |= (Data & 0x0F);
		#endif
		/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
		_delay_ms(1);
		/* disable LCD E=0 */
		RESET_Bit(LCD_CONTROL_REG_OP,E);
    14ee:	c2 98       	cbi	0x18, 2	; 24
    14f0:	ef e9       	ldi	r30, 0x9F	; 159
    14f2:	ff e0       	ldi	r31, 0x0F	; 15
    14f4:	31 97       	sbiw	r30, 0x01	; 1
    14f6:	f1 f7       	brne	.-4      	; 0x14f4 <LCD_DisplayChar+0x78>
    14f8:	00 c0       	rjmp	.+0      	; 0x14fa <LCD_DisplayChar+0x7e>
    14fa:	00 00       	nop
		/* Data Hold delay Th = 10ns This In The Ideal State*/
		_delay_ms(1);
		#endif
	}	
    14fc:	08 95       	ret

000014fe <LCD_DisplayString>:
	
	
		
    void LCD_DisplayString(char * ptr)
	{
    14fe:	cf 93       	push	r28
    1500:	df 93       	push	r29
    1502:	ec 01       	movw	r28, r24
		while(*ptr != '\0')
    1504:	88 81       	ld	r24, Y
    1506:	88 23       	and	r24, r24
    1508:	31 f0       	breq	.+12     	; 0x1516 <LCD_DisplayString+0x18>
		#endif
	}	
	
	
		
    void LCD_DisplayString(char * ptr)
    150a:	21 96       	adiw	r28, 0x01	; 1
	{
		while(*ptr != '\0')
		{
			LCD_DisplayChar(*ptr);
    150c:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
	
	
		
    void LCD_DisplayString(char * ptr)
	{
		while(*ptr != '\0')
    1510:	89 91       	ld	r24, Y+
    1512:	88 23       	and	r24, r24
    1514:	d9 f7       	brne	.-10     	; 0x150c <LCD_DisplayString+0xe>
		{
			LCD_DisplayChar(*ptr);
			ptr++;
		}
	}
    1516:	df 91       	pop	r29
    1518:	cf 91       	pop	r28
    151a:	08 95       	ret

0000151c <LCD_Select_RowCol>:
	
			
    void LCD_Select_RowCol(unsigned char Row , unsigned char col)
	{
		char ADDRESS = 0x00;
		switch(Row)
    151c:	81 30       	cpi	r24, 0x01	; 1
    151e:	41 f0       	breq	.+16     	; 0x1530 <LCD_Select_RowCol+0x14>
    1520:	81 30       	cpi	r24, 0x01	; 1
    1522:	78 f0       	brcs	.+30     	; 0x1542 <LCD_Select_RowCol+0x26>
    1524:	82 30       	cpi	r24, 0x02	; 2
    1526:	39 f0       	breq	.+14     	; 0x1536 <LCD_Select_RowCol+0x1a>
    1528:	83 30       	cpi	r24, 0x03	; 3
    152a:	41 f0       	breq	.+16     	; 0x153c <LCD_Select_RowCol+0x20>
	
	
			
    void LCD_Select_RowCol(unsigned char Row , unsigned char col)
	{
		char ADDRESS = 0x00;
    152c:	80 e0       	ldi	r24, 0x00	; 0
    152e:	0a c0       	rjmp	.+20     	; 0x1544 <LCD_Select_RowCol+0x28>
			       /* When Writing To LCD 1st Col The Base Address is 0x00 */
			       ADDRESS= col | LCD_1ST_ROW;
			       break;
			case 1:
			      /* When Writing To LCD 1st Col The Base Address is 0x40 */
			      ADDRESS= col | LCD_2ND_ROW;
    1530:	86 2f       	mov	r24, r22
    1532:	80 64       	ori	r24, 0x40	; 64
			      break;
    1534:	07 c0       	rjmp	.+14     	; 0x1544 <LCD_Select_RowCol+0x28>
			case 2:
			       /* When Writing To LCD 1st Col The Base Address is 0x10 */
			       ADDRESS= col | LCD_3RD_ROW;
    1536:	86 2f       	mov	r24, r22
    1538:	80 61       	ori	r24, 0x10	; 16
			       break;
    153a:	04 c0       	rjmp	.+8      	; 0x1544 <LCD_Select_RowCol+0x28>
			case 3:
			       /* When Writing To LCD 1st Col The Base Address is 0x50 */
			       ADDRESS= col | LCD_4TH_ROW;
    153c:	86 2f       	mov	r24, r22
    153e:	80 65       	ori	r24, 0x50	; 80
			       break;
    1540:	01 c0       	rjmp	.+2      	; 0x1544 <LCD_Select_RowCol+0x28>
		char ADDRESS = 0x00;
		switch(Row)
		{
			case 0: 
			       /* When Writing To LCD 1st Col The Base Address is 0x00 */
			       ADDRESS= col | LCD_1ST_ROW;
    1542:	86 2f       	mov	r24, r22
			       ADDRESS= col | LCD_4TH_ROW;
			       break;
		}
		/* Form The Data Sheet it must Set The Bit 7 Before Send The Address */
		(ADDRESS) |= (1<<7);
		Send_instruction(ADDRESS);
    1544:	80 68       	ori	r24, 0x80	; 128
    1546:	0e 94 e6 09 	call	0x13cc	; 0x13cc <Send_instruction>
	}
    154a:	08 95       	ret

0000154c <LCD_DisplayInt>:
			
    void LCD_DisplayInt(long int data)
	{
    154c:	cf 93       	push	r28
    154e:	df 93       	push	r29
    1550:	cd b7       	in	r28, 0x3d	; 61
    1552:	de b7       	in	r29, 0x3e	; 62
    1554:	65 97       	sbiw	r28, 0x15	; 21
    1556:	0f b6       	in	r0, 0x3f	; 63
    1558:	f8 94       	cli
    155a:	de bf       	out	0x3e, r29	; 62
    155c:	0f be       	out	0x3f, r0	; 63
    155e:	cd bf       	out	0x3d, r28	; 61
    1560:	dc 01       	movw	r26, r24
    1562:	cb 01       	movw	r24, r22
		/* String to hold the ASCI result */
		char Result[21];
		/* 10 for decimal */
		utoa(data,Result,10);
    1564:	be 01       	movw	r22, r28
    1566:	6f 5f       	subi	r22, 0xFF	; 255
    1568:	7f 4f       	sbci	r23, 0xFF	; 255
    156a:	4a e0       	ldi	r20, 0x0A	; 10
    156c:	50 e0       	ldi	r21, 0x00	; 0
    156e:	0e 94 13 14 	call	0x2826	; 0x2826 <utoa>
		/* Display The Result */
		LCD_DisplayString(Result);
    1572:	ce 01       	movw	r24, r28
    1574:	01 96       	adiw	r24, 0x01	; 1
    1576:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
	} 
    157a:	65 96       	adiw	r28, 0x15	; 21
    157c:	0f b6       	in	r0, 0x3f	; 63
    157e:	f8 94       	cli
    1580:	de bf       	out	0x3e, r29	; 62
    1582:	0f be       	out	0x3f, r0	; 63
    1584:	cd bf       	out	0x3d, r28	; 61
    1586:	df 91       	pop	r29
    1588:	cf 91       	pop	r28
    158a:	08 95       	ret

0000158c <LCD_StoreCustomchar>:
	
	void LCD_StoreCustomchar(unsigned char*pattern,unsigned char CGRAM_index)
	{
    158c:	0f 93       	push	r16
    158e:	1f 93       	push	r17
    1590:	cf 93       	push	r28
    1592:	df 93       	push	r29
    1594:	08 2f       	mov	r16, r24
    1596:	19 2f       	mov	r17, r25
		char ADDRESS = 0x00;
		char index;
		if (CGRAM_index < MAX_NWCHAR)
    1598:	68 30       	cpi	r22, 0x08	; 8
    159a:	80 f4       	brcc	.+32     	; 0x15bc <LCD_StoreCustomchar+0x30>
		{
			/* We Need To Move AC To Make it Point To The CGRAM at The Address Config By The User */
			ADDRESS = CGRAM_index;
			ADDRESS |= CGRAM_CONST; /* To Set The Bit Number 6 To point On The CGRAM Address Get From Datasheet */
			Send_instruction(ADDRESS);
    159c:	86 2f       	mov	r24, r22
    159e:	80 64       	ori	r24, 0x40	; 64
    15a0:	0e 94 e6 09 	call	0x13cc	; 0x13cc <Send_instruction>
    15a4:	c0 2f       	mov	r28, r16
    15a6:	d1 2f       	mov	r29, r17
			/* Note That The AC increase Automatically After Write On The Address It Point To */
			for (index = 0; index < 8; index++)
    15a8:	10 e0       	ldi	r17, 0x00	; 0
			{
				LCD_DisplayChar(pattern[index]);
    15aa:	89 91       	ld	r24, Y+
    15ac:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
			/* We Need To Move AC To Make it Point To The CGRAM at The Address Config By The User */
			ADDRESS = CGRAM_index;
			ADDRESS |= CGRAM_CONST; /* To Set The Bit Number 6 To point On The CGRAM Address Get From Datasheet */
			Send_instruction(ADDRESS);
			/* Note That The AC increase Automatically After Write On The Address It Point To */
			for (index = 0; index < 8; index++)
    15b0:	1f 5f       	subi	r17, 0xFF	; 255
    15b2:	18 30       	cpi	r17, 0x08	; 8
    15b4:	d1 f7       	brne	.-12     	; 0x15aa <LCD_StoreCustomchar+0x1e>
			{
				LCD_DisplayChar(pattern[index]);
			}
			/* We Need To Return The AC to point To The DDRAM */
			Send_instruction(RETURN_HOME);
    15b6:	82 e0       	ldi	r24, 0x02	; 2
    15b8:	0e 94 e6 09 	call	0x13cc	; 0x13cc <Send_instruction>
		}
	}   
    15bc:	df 91       	pop	r29
    15be:	cf 91       	pop	r28
    15c0:	1f 91       	pop	r17
    15c2:	0f 91       	pop	r16
    15c4:	08 95       	ret

000015c6 <Led_Setup>:
  }
  
  
  
  void Led_Setup (Led_dataType Led)
  {
    15c6:	0f 93       	push	r16
    15c8:	1f 93       	push	r17
    15ca:	cf 93       	push	r28
    15cc:	df 93       	push	r29
    15ce:	18 2f       	mov	r17, r24
    15d0:	09 2f       	mov	r16, r25
    15d2:	d6 2f       	mov	r29, r22
    15d4:	c7 2f       	mov	r28, r23
	  /* configure The LED pin As An Output Pin */
	  DIO_pinConfiguration(Led.ledPort, Led.ledPin, Output);
    15d6:	86 2f       	mov	r24, r22
    15d8:	97 2f       	mov	r25, r23
    15da:	61 2f       	mov	r22, r17
    15dc:	42 e0       	ldi	r20, 0x02	; 2
    15de:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  /* represent The Initial State Of The LED to Make Portability If The User Connect It Fw / Rv */ 
	  DIO_pinWrite(Led.ledPort, Led.ledPin, Led.ledIntialValue);
    15e2:	8d 2f       	mov	r24, r29
    15e4:	9c 2f       	mov	r25, r28
    15e6:	61 2f       	mov	r22, r17
    15e8:	40 2f       	mov	r20, r16
    15ea:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
  }
    15ee:	df 91       	pop	r29
    15f0:	cf 91       	pop	r28
    15f2:	1f 91       	pop	r17
    15f4:	0f 91       	pop	r16
    15f6:	08 95       	ret

000015f8 <Led_operation>:
  void Led_operation(Led_dataType led, Led_StateType State)
  {
    15f8:	1f 93       	push	r17
    15fa:	cf 93       	push	r28
    15fc:	df 93       	push	r29
    15fe:	c8 2f       	mov	r28, r24
    1600:	86 2f       	mov	r24, r22
    1602:	97 2f       	mov	r25, r23
    1604:	16 2f       	mov	r17, r22
    1606:	d7 2f       	mov	r29, r23
	  *case <FW_ON, Rev_OFF>     <in this two case is the different in the connection of the LED with the Mc but it the same in the Mc deal with in the 2 case it output HIGH>
	  *case <Led_TOGGLE>         < in this case the led is toggling it is state so it read it intial state and toggle it >
	  *case <invalidArrgument>  < in this case the Mc can not define the state send to him so it print an error massege >
	  *
	  */
	  switch(State)
    1608:	42 30       	cpi	r20, 0x02	; 2
    160a:	18 f0       	brcs	.+6      	; 0x1612 <Led_operation+0x1a>
    160c:	43 30       	cpi	r20, 0x03	; 3
    160e:	91 f4       	brne	.+36     	; 0x1634 <Led_operation+0x3c>
    1610:	04 c0       	rjmp	.+8      	; 0x161a <Led_operation+0x22>
		  
	  
	     case HIGH :
	     case LOW  :
	   
	          DIO_pinWrite(led.ledPort, led.ledPin, State);
    1612:	6c 2f       	mov	r22, r28
    1614:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
	          break;
    1618:	0d c0       	rjmp	.+26     	; 0x1634 <Led_operation+0x3c>
	     case Led_TOGGLE :
		 /* Here We Toggle The State Of The Pin */
	          DIO_pinWrite(led.ledPort, led.ledPin, !DIO_pinRead(led.ledPort, led.ledPin));
    161a:	86 2f       	mov	r24, r22
    161c:	97 2f       	mov	r25, r23
    161e:	6c 2f       	mov	r22, r28
    1620:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
    1624:	41 e0       	ldi	r20, 0x01	; 1
    1626:	81 11       	cpse	r24, r1
    1628:	40 e0       	ldi	r20, 0x00	; 0
    162a:	81 2f       	mov	r24, r17
    162c:	9d 2f       	mov	r25, r29
    162e:	6c 2f       	mov	r22, r28
    1630:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
	     default : Led_ErrorIndicatio(invalidArgument);
		       break;
	  }	
    1634:	df 91       	pop	r29
    1636:	cf 91       	pop	r28
    1638:	1f 91       	pop	r17
    163a:	08 95       	ret

0000163c <ErrorIndication>:
		 case invalidArgument:
		      break;
		default:
		       break;
	 }
 }
    163c:	08 95       	ret

0000163e <PIR_setup>:
 
 
 
 void PIR_setup(PIR_dataType PIR)
 {
    163e:	cf 93       	push	r28
    1640:	df 93       	push	r29
    1642:	00 d0       	rcall	.+0      	; 0x1644 <PIR_setup+0x6>
    1644:	0f 92       	push	r0
    1646:	cd b7       	in	r28, 0x3d	; 61
    1648:	de b7       	in	r29, 0x3e	; 62
    164a:	69 83       	std	Y+1, r22	; 0x01
    164c:	7a 83       	std	Y+2, r23	; 0x02
    164e:	68 2f       	mov	r22, r24
    1650:	8b 83       	std	Y+3, r24	; 0x03
	 /* Configuration The Pin Of The Sensor As an Input Float  Pin So It default Is LOW */
	 DIO_pinConfiguration(PIR.PIRport, PIR.PIRpin, InputFloat);
    1652:	89 81       	ldd	r24, Y+1	; 0x01
    1654:	9a 81       	ldd	r25, Y+2	; 0x02
    1656:	40 e0       	ldi	r20, 0x00	; 0
    1658:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
 }
    165c:	0f 90       	pop	r0
    165e:	0f 90       	pop	r0
    1660:	0f 90       	pop	r0
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	08 95       	ret

00001668 <PIR_operate>:
 
 
 
 DigitalValue PIR_operate (PIR_dataType PIR)
 {
    1668:	cf 93       	push	r28
    166a:	df 93       	push	r29
    166c:	00 d0       	rcall	.+0      	; 0x166e <PIR_operate+0x6>
    166e:	0f 92       	push	r0
    1670:	cd b7       	in	r28, 0x3d	; 61
    1672:	de b7       	in	r29, 0x3e	; 62
    1674:	69 83       	std	Y+1, r22	; 0x01
    1676:	7a 83       	std	Y+2, r23	; 0x02
    1678:	68 2f       	mov	r22, r24
    167a:	8b 83       	std	Y+3, r24	; 0x03
	 /* read The Pin State Refer To The Condition Of The sensor If It Indicate Will return High Else Will Return Low */
	 return ( DIO_pinRead(PIR.PIRport, PIR.PIRpin) );	
    167c:	89 81       	ldd	r24, Y+1	; 0x01
    167e:	9a 81       	ldd	r25, Y+2	; 0x02
    1680:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
 }
    1684:	0f 90       	pop	r0
    1686:	0f 90       	pop	r0
    1688:	0f 90       	pop	r0
    168a:	df 91       	pop	r29
    168c:	cf 91       	pop	r28
    168e:	08 95       	ret

00001690 <PushButton_setup>:
   static DigitalValue Push_default_State;



  void PushButton_setup(PushButton_datatype *Pswitch)
  {
    1690:	cf 93       	push	r28
    1692:	df 93       	push	r29
    1694:	ec 01       	movw	r28, r24
	  /* Configuration The Pin Of The Push Button As User State Set  */
	  DIO_pinConfiguration(Pswitch->IO_PORT, Pswitch->IO_PIN, Pswitch->InputMode);
    1696:	88 81       	ld	r24, Y
    1698:	99 81       	ldd	r25, Y+1	; 0x01
    169a:	6a 81       	ldd	r22, Y+2	; 0x02
    169c:	4b 81       	ldd	r20, Y+3	; 0x03
    169e:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  /* Setup The TH Previous State Of The Push Button As A Current State When It Just Configure */
	  Pswitch->PREV_Level = DIO_pinRead(Pswitch->IO_PORT,Pswitch->IO_PIN);
    16a2:	88 81       	ld	r24, Y
    16a4:	99 81       	ldd	r25, Y+1	; 0x01
    16a6:	6a 81       	ldd	r22, Y+2	; 0x02
    16a8:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
    16ac:	8c 83       	std	Y+4, r24	; 0x04
	  //setup the default state of the button to know when it pressed or released 
	  Push_default_State = Pswitch->PREV_Level;  
    16ae:	80 93 65 02 	sts	0x0265, r24
  }
    16b2:	df 91       	pop	r29
    16b4:	cf 91       	pop	r28
    16b6:	08 95       	ret

000016b8 <PushButton_read>:
  
  
  
  
  PUSH_States PushButton_read(PushButton_datatype *Pswitch)
  {
    16b8:	1f 93       	push	r17
    16ba:	cf 93       	push	r28
    16bc:	df 93       	push	r29
    16be:	ec 01       	movw	r28, r24
	  /* If The User do Not Change The PREV_Level that Mean It Do not press The PushButton Yet So It Will Return It Not Pressed State*/ 
	  PUSH_States returnState = PUSH_NOT_PRESSED;
	  if (Pswitch->PREV_Level != DIO_pinRead(Pswitch->IO_PORT,Pswitch->IO_PIN))
    16c0:	1c 81       	ldd	r17, Y+4	; 0x04
    16c2:	88 81       	ld	r24, Y
    16c4:	99 81       	ldd	r25, Y+1	; 0x01
    16c6:	6a 81       	ldd	r22, Y+2	; 0x02
    16c8:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
    16cc:	18 17       	cp	r17, r24
    16ce:	e9 f0       	breq	.+58     	; 0x170a <PushButton_read+0x52>
    16d0:	8f ef       	ldi	r24, 0xFF	; 255
    16d2:	90 e7       	ldi	r25, 0x70	; 112
    16d4:	a2 e0       	ldi	r26, 0x02	; 2
    16d6:	81 50       	subi	r24, 0x01	; 1
    16d8:	90 40       	sbci	r25, 0x00	; 0
    16da:	a0 40       	sbci	r26, 0x00	; 0
    16dc:	e1 f7       	brne	.-8      	; 0x16d6 <PushButton_read+0x1e>
    16de:	00 c0       	rjmp	.+0      	; 0x16e0 <PushButton_read+0x28>
    16e0:	00 00       	nop
	  {
		  // the average pressed of the human is 500 ms to make sure it not ripple 
		  _delay_ms(Push_Bouncing_Periode_mS);       
		  // to make sure that is not a mess signal
		   if (Pswitch->PREV_Level != DIO_pinRead(Pswitch->IO_PORT,Pswitch->IO_PIN)) 
    16e2:	1c 81       	ldd	r17, Y+4	; 0x04
    16e4:	88 81       	ld	r24, Y
    16e6:	99 81       	ldd	r25, Y+1	; 0x01
    16e8:	6a 81       	ldd	r22, Y+2	; 0x02
    16ea:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
    16ee:	18 17       	cp	r17, r24
    16f0:	71 f0       	breq	.+28     	; 0x170e <PushButton_read+0x56>
		   {
			   Pswitch->PREV_Level = DIO_pinRead(Pswitch->IO_PORT,Pswitch->IO_PIN);
    16f2:	88 81       	ld	r24, Y
    16f4:	99 81       	ldd	r25, Y+1	; 0x01
    16f6:	6a 81       	ldd	r22, Y+2	; 0x02
    16f8:	0e 94 38 01 	call	0x270	; 0x270 <DIO_pinRead>
    16fc:	8c 83       	std	Y+4, r24	; 0x04
			   if (Pswitch->PREV_Level != Push_default_State)
    16fe:	90 91 65 02 	lds	r25, 0x0265
    1702:	89 17       	cp	r24, r25
    1704:	31 f0       	breq	.+12     	; 0x1712 <PushButton_read+0x5a>
			   {
				   returnState = PUSH_PRESSED;
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	05 c0       	rjmp	.+10     	; 0x1714 <PushButton_read+0x5c>
  
  
  PUSH_States PushButton_read(PushButton_datatype *Pswitch)
  {
	  /* If The User do Not Change The PREV_Level that Mean It Do not press The PushButton Yet So It Will Return It Not Pressed State*/ 
	  PUSH_States returnState = PUSH_NOT_PRESSED;
    170a:	80 e0       	ldi	r24, 0x00	; 0
    170c:	03 c0       	rjmp	.+6      	; 0x1714 <PushButton_read+0x5c>
    170e:	80 e0       	ldi	r24, 0x00	; 0
    1710:	01 c0       	rjmp	.+2      	; 0x1714 <PushButton_read+0x5c>
				   returnState = PUSH_PRESSED;
			   }
			   else
			   {
				   /* If The PREV_Leve(Pin Current Read ) equal The Default State That Mean That The Push ButtonWas Pressed And Released */
				   returnState = PUSH_RELEASED;
    1712:	82 e0       	ldi	r24, 0x02	; 2
			   }				   
		   }
	  }
	  return returnState;
    1714:	df 91       	pop	r29
    1716:	cf 91       	pop	r28
    1718:	1f 91       	pop	r17
    171a:	08 95       	ret

0000171c <Relay_SETUP>:
   
   
   
   
  void Relay_SETUP (Relay_dataType relay)
  {
    171c:	0f 93       	push	r16
    171e:	1f 93       	push	r17
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	18 2f       	mov	r17, r24
    1726:	09 2f       	mov	r16, r25
    1728:	d6 2f       	mov	r29, r22
    172a:	c7 2f       	mov	r28, r23
	  // if the relay is reversed NO and NC that mean it operate a micro sec then stop because the initial condition of Output is 0 
	  DIO_pinConfiguration(relay.signalPort, relay.signalPin, Output); 
    172c:	86 2f       	mov	r24, r22
    172e:	97 2f       	mov	r25, r23
    1730:	61 2f       	mov	r22, r17
    1732:	42 e0       	ldi	r20, 0x02	; 2
    1734:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	  /* represent The Relay Intial Value */ 
	  DIO_pinWrite(relay.signalPort, relay.signalPin, relay.intialeValue);
    1738:	8d 2f       	mov	r24, r29
    173a:	9c 2f       	mov	r25, r28
    173c:	61 2f       	mov	r22, r17
    173e:	40 2f       	mov	r20, r16
    1740:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
  }
    1744:	df 91       	pop	r29
    1746:	cf 91       	pop	r28
    1748:	1f 91       	pop	r17
    174a:	0f 91       	pop	r16
    174c:	08 95       	ret

0000174e <Relay_Operate>:
  
  
  
  
  void Relay_Operate(Relay_dataType relay, RELAY_STATE signal)
  {
    174e:	28 2f       	mov	r18, r24
	  *case <standardNO, RevNC>     <in this two case is the different in the connection of the Relay with the Mc but it the same in the Mc deal with in the 2 case it output LOW>
	  *case <standardNC, RevNO>     <in this two case is the different in the connection of the Relay with the Mc but it the same in the Mc deal with in the 2 case it output HIGH>
	  *case <invalidArrgument>      <in this case the Mc can not define the state send to him so it print an error massege >
	  *
	  */
	  switch (signal)
    1750:	42 30       	cpi	r20, 0x02	; 2
    1752:	28 f4       	brcc	.+10     	; 0x175e <Relay_Operate+0x10>
	  {
		  case HIGH :
		  case LOW  :
		       DIO_pinWrite(relay.signalPort, relay.signalPin, signal);
    1754:	86 2f       	mov	r24, r22
    1756:	97 2f       	mov	r25, r23
    1758:	62 2f       	mov	r22, r18
    175a:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
    175e:	08 95       	ret

00001760 <SERVO_WRITE>:
     void SERVO_WRITE(double t, unsigned char servo_name)
	 {
		 
		 
		 /* Select the mode fast PWM as ICR1 top decimal 14*/
		 SET_Bit(TCCR1A,WGM11);
    1760:	2f b5       	in	r18, 0x2f	; 47
    1762:	22 60       	ori	r18, 0x02	; 2
    1764:	2f bd       	out	0x2f, r18	; 47
		 SET_Bit(TCCR1B,WGM12);
    1766:	2e b5       	in	r18, 0x2e	; 46
    1768:	28 60       	ori	r18, 0x08	; 8
    176a:	2e bd       	out	0x2e, r18	; 46
		 SET_Bit(TCCR1B,WGM13);
    176c:	2e b5       	in	r18, 0x2e	; 46
    176e:	20 61       	ori	r18, 0x10	; 16
    1770:	2e bd       	out	0x2e, r18	; 46
		 
		 /* LOAD The Value of the ICR1  */
		 
		 /* Store this value on the ICR1 that we make it the timer Top value so when it reach this value that mean that the 20msec is end the timer get overflow */
		 ICR1 = Counts_20msecSignal_Num;
    1772:	28 e8       	ldi	r18, 0x88	; 136
    1774:	33 e1       	ldi	r19, 0x13	; 19
    1776:	37 bd       	out	0x27, r19	; 39
    1778:	26 bd       	out	0x26, r18	; 38
		 
		 /* Set the timer clock as 64 is a prescaler that to avoid make the value of the number float to take more accuracy value */
		 SET_Bit(TCCR1B,CS10);
    177a:	2e b5       	in	r18, 0x2e	; 46
    177c:	21 60       	ori	r18, 0x01	; 1
    177e:	2e bd       	out	0x2e, r18	; 46
		 SET_Bit(TCCR1B,CS11);
    1780:	2e b5       	in	r18, 0x2e	; 46
    1782:	22 60       	ori	r18, 0x02	; 2
    1784:	2e bd       	out	0x2e, r18	; 46
		
		 switch(servo_name)
    1786:	41 34       	cpi	r20, 0x41	; 65
    1788:	19 f0       	breq	.+6      	; 0x1790 <SERVO_WRITE+0x30>
    178a:	42 34       	cpi	r20, 0x42	; 66
    178c:	a1 f5       	brne	.+104    	; 0x17f6 <SERVO_WRITE+0x96>
    178e:	1a c0       	rjmp	.+52     	; 0x17c4 <SERVO_WRITE+0x64>
		 {
			 case 'A':
			       /* The value of the 1msec counts to define the ON time of output signal to decide the place of the Servo*/
			       OCR1A = t * Counts_1msec_Num;
    1790:	20 e0       	ldi	r18, 0x00	; 0
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	4a e7       	ldi	r20, 0x7A	; 122
    1796:	53 e4       	ldi	r21, 0x43	; 67
    1798:	0e 94 b0 13 	call	0x2760	; 0x2760 <__mulsf3>
    179c:	0e 94 f6 12 	call	0x25ec	; 0x25ec <__fixunssfsi>
    17a0:	dc 01       	movw	r26, r24
    17a2:	cb 01       	movw	r24, r22
    17a4:	9b bd       	out	0x2b, r25	; 43
    17a6:	8a bd       	out	0x2a, r24	; 42
				   
				    /* Work at the non inverting Mode */
				    SET_Bit(TCCR1A, COM1A1);
    17a8:	8f b5       	in	r24, 0x2f	; 47
    17aa:	80 68       	ori	r24, 0x80	; 128
    17ac:	8f bd       	out	0x2f, r24	; 47
					/* Set The OC1A as an Output */
					DIO_pinConfiguration(GPIOD, PIN5, Output);
    17ae:	80 e3       	ldi	r24, 0x30	; 48
    17b0:	90 e0       	ldi	r25, 0x00	; 0
    17b2:	65 e0       	ldi	r22, 0x05	; 5
    17b4:	42 e0       	ldi	r20, 0x02	; 2
    17b6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17ba:	85 e3       	ldi	r24, 0x35	; 53
    17bc:	8a 95       	dec	r24
    17be:	f1 f7       	brne	.-4      	; 0x17bc <SERVO_WRITE+0x5c>
    17c0:	00 00       	nop
    17c2:	08 95       	ret
					_delay_us(10);
			 break;
			 case 'B':
			       /* The value of the 1msec counts to define the ON time of output signal to decide the place of the Servo*/
			       OCR1B = t * Counts_1msec_Num;
    17c4:	20 e0       	ldi	r18, 0x00	; 0
    17c6:	30 e0       	ldi	r19, 0x00	; 0
    17c8:	4a e7       	ldi	r20, 0x7A	; 122
    17ca:	53 e4       	ldi	r21, 0x43	; 67
    17cc:	0e 94 b0 13 	call	0x2760	; 0x2760 <__mulsf3>
    17d0:	0e 94 f6 12 	call	0x25ec	; 0x25ec <__fixunssfsi>
    17d4:	dc 01       	movw	r26, r24
    17d6:	cb 01       	movw	r24, r22
    17d8:	99 bd       	out	0x29, r25	; 41
    17da:	88 bd       	out	0x28, r24	; 40
			       
			       /* Work at the non inverting Mode */
			       SET_Bit(TCCR1A, COM1B1);
    17dc:	8f b5       	in	r24, 0x2f	; 47
    17de:	80 62       	ori	r24, 0x20	; 32
    17e0:	8f bd       	out	0x2f, r24	; 47
				   
				   /* Set The OC1A as an Output */
				   DIO_pinConfiguration(GPIOD, PIN4, Output);
    17e2:	80 e3       	ldi	r24, 0x30	; 48
    17e4:	90 e0       	ldi	r25, 0x00	; 0
    17e6:	64 e0       	ldi	r22, 0x04	; 4
    17e8:	42 e0       	ldi	r20, 0x02	; 2
    17ea:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
    17ee:	85 e3       	ldi	r24, 0x35	; 53
    17f0:	8a 95       	dec	r24
    17f2:	f1 f7       	brne	.-4      	; 0x17f0 <SERVO_WRITE+0x90>
    17f4:	00 00       	nop
    17f6:	08 95       	ret

000017f8 <interrupt_Function2>:
	  }
  }
  static void interrupt_Function2(void)
  {
	  unsigned short time_ON;
	  if (flag_2 == 0)
    17f8:	80 91 66 02 	lds	r24, 0x0266
    17fc:	88 23       	and	r24, r24
    17fe:	91 f4       	brne	.+36     	; 0x1824 <interrupt_Function2+0x2c>
	  {
		  TIMER_INTIATE(t_counter2);
    1800:	60 91 60 00 	lds	r22, 0x0060
    1804:	70 91 61 00 	lds	r23, 0x0061
    1808:	80 91 62 00 	lds	r24, 0x0062
    180c:	90 91 63 00 	lds	r25, 0x0063
    1810:	0e 94 d7 02 	call	0x5ae	; 0x5ae <TIMER_INTIATE>
		  EXTINT_InterruptInit(EXINT_INT1, EXINT_FallingEdge);
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	62 e0       	ldi	r22, 0x02	; 2
    1818:	0e 94 ba 01 	call	0x374	; 0x374 <EXTINT_InterruptInit>
		  flag_2 = 1;
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	80 93 66 02 	sts	0x0266, r24
    1822:	08 95       	ret
	  }
	  else if(flag_2 == 1)
    1824:	80 91 66 02 	lds	r24, 0x0266
    1828:	81 30       	cpi	r24, 0x01	; 1
    182a:	d9 f5       	brne	.+118    	; 0x18a2 <interrupt_Function2+0xaa>
	  {
		  TCCR2 = 0;
    182c:	15 bc       	out	0x25, r1	; 37
		  if (READ_Bit(TIFR,TOV2) == 1)
    182e:	08 b6       	in	r0, 0x38	; 56
    1830:	06 fe       	sbrs	r0, 6
    1832:	1c c0       	rjmp	.+56     	; 0x186c <interrupt_Function2+0x74>
		  {
			  /* To solve the Problem of the Overflow the counter before get the maximum distance */
			  Object_distance2 = (TCNT2 + 255) * 1.1072;
    1834:	64 b5       	in	r22, 0x24	; 36
    1836:	70 e0       	ldi	r23, 0x00	; 0
    1838:	61 50       	subi	r22, 0x01	; 1
    183a:	7f 4f       	sbci	r23, 0xFF	; 255
    183c:	88 27       	eor	r24, r24
    183e:	77 fd       	sbrc	r23, 7
    1840:	80 95       	com	r24
    1842:	98 2f       	mov	r25, r24
    1844:	0e 94 24 13 	call	0x2648	; 0x2648 <__floatsisf>
    1848:	2b eb       	ldi	r18, 0xBB	; 187
    184a:	38 eb       	ldi	r19, 0xB8	; 184
    184c:	4d e8       	ldi	r20, 0x8D	; 141
    184e:	5f e3       	ldi	r21, 0x3F	; 63
    1850:	0e 94 b0 13 	call	0x2760	; 0x2760 <__mulsf3>
    1854:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <__fixsfsi>
    1858:	dc 01       	movw	r26, r24
    185a:	cb 01       	movw	r24, r22
    185c:	90 93 75 02 	sts	0x0275, r25
    1860:	80 93 74 02 	sts	0x0274, r24
			  /* CLear the flag Manually by Write a One */
			  SET_Bit(TIFR,TOV2);
    1864:	88 b7       	in	r24, 0x38	; 56
    1866:	80 64       	ori	r24, 0x40	; 64
    1868:	88 bf       	out	0x38, r24	; 56
    186a:	14 c0       	rjmp	.+40     	; 0x1894 <interrupt_Function2+0x9c>
		  }
		  else
		  {
			  Object_distance2 = TCNT2 * 1.1072;
    186c:	64 b5       	in	r22, 0x24	; 36
    186e:	70 e0       	ldi	r23, 0x00	; 0
    1870:	80 e0       	ldi	r24, 0x00	; 0
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	0e 94 24 13 	call	0x2648	; 0x2648 <__floatsisf>
    1878:	2b eb       	ldi	r18, 0xBB	; 187
    187a:	38 eb       	ldi	r19, 0xB8	; 184
    187c:	4d e8       	ldi	r20, 0x8D	; 141
    187e:	5f e3       	ldi	r21, 0x3F	; 63
    1880:	0e 94 b0 13 	call	0x2760	; 0x2760 <__mulsf3>
    1884:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <__fixsfsi>
    1888:	dc 01       	movw	r26, r24
    188a:	cb 01       	movw	r24, r22
    188c:	90 93 75 02 	sts	0x0275, r25
    1890:	80 93 74 02 	sts	0x0274, r24
		  }
		  EXTINT_InterruptInit(EXINT_INT1, EXINT_RisingEdge);
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	63 e0       	ldi	r22, 0x03	; 3
    1898:	0e 94 ba 01 	call	0x374	; 0x374 <EXTINT_InterruptInit>
		  flag_2 = 0;
    189c:	10 92 66 02 	sts	0x0266, r1
		  TCNT2 = 0;
    18a0:	14 bc       	out	0x24, r1	; 36
    18a2:	08 95       	ret

000018a4 <interrupt_Function>:
    short Object_distance2;
  
  static void interrupt_Function(void)
  {
	  unsigned short time_ON;
	  if (flag_1 == 0)
    18a4:	80 91 67 02 	lds	r24, 0x0267
    18a8:	88 23       	and	r24, r24
    18aa:	91 f4       	brne	.+36     	; 0x18d0 <interrupt_Function+0x2c>
	  {
		  TIMER_INTIATE(t_counter1);
    18ac:	60 91 64 00 	lds	r22, 0x0064
    18b0:	70 91 65 00 	lds	r23, 0x0065
    18b4:	80 91 66 00 	lds	r24, 0x0066
    18b8:	90 91 67 00 	lds	r25, 0x0067
    18bc:	0e 94 d7 02 	call	0x5ae	; 0x5ae <TIMER_INTIATE>
		 EXTINT_InterruptInit(EXINT_INT0, EXINT_FallingEdge);
    18c0:	80 e0       	ldi	r24, 0x00	; 0
    18c2:	62 e0       	ldi	r22, 0x02	; 2
    18c4:	0e 94 ba 01 	call	0x374	; 0x374 <EXTINT_InterruptInit>
		  flag_1 = 1;
    18c8:	81 e0       	ldi	r24, 0x01	; 1
    18ca:	80 93 67 02 	sts	0x0267, r24
    18ce:	08 95       	ret
	  }
	  else if(flag_1 == 1)
    18d0:	80 91 67 02 	lds	r24, 0x0267
    18d4:	81 30       	cpi	r24, 0x01	; 1
    18d6:	d9 f5       	brne	.+118    	; 0x194e <interrupt_Function+0xaa>
	  {
		  TCCR0 = 0; 
    18d8:	13 be       	out	0x33, r1	; 51
		  if (READ_Bit(TIFR,TOV0) == 1)
    18da:	08 b6       	in	r0, 0x38	; 56
    18dc:	00 fe       	sbrs	r0, 0
    18de:	1c c0       	rjmp	.+56     	; 0x1918 <interrupt_Function+0x74>
		  {
			  /* To solve the Problem of the Overflow the counter before get the maximum distance */
			  Object_distance1 = (TCNT0 + 255) * 1.1072;
    18e0:	62 b7       	in	r22, 0x32	; 50
    18e2:	70 e0       	ldi	r23, 0x00	; 0
    18e4:	61 50       	subi	r22, 0x01	; 1
    18e6:	7f 4f       	sbci	r23, 0xFF	; 255
    18e8:	88 27       	eor	r24, r24
    18ea:	77 fd       	sbrc	r23, 7
    18ec:	80 95       	com	r24
    18ee:	98 2f       	mov	r25, r24
    18f0:	0e 94 24 13 	call	0x2648	; 0x2648 <__floatsisf>
    18f4:	2b eb       	ldi	r18, 0xBB	; 187
    18f6:	38 eb       	ldi	r19, 0xB8	; 184
    18f8:	4d e8       	ldi	r20, 0x8D	; 141
    18fa:	5f e3       	ldi	r21, 0x3F	; 63
    18fc:	0e 94 b0 13 	call	0x2760	; 0x2760 <__mulsf3>
    1900:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <__fixsfsi>
    1904:	dc 01       	movw	r26, r24
    1906:	cb 01       	movw	r24, r22
    1908:	90 93 73 02 	sts	0x0273, r25
    190c:	80 93 72 02 	sts	0x0272, r24
			  /* CLear the flag Manually by Write a One */
			  SET_Bit(TIFR,TOV0);
    1910:	88 b7       	in	r24, 0x38	; 56
    1912:	81 60       	ori	r24, 0x01	; 1
    1914:	88 bf       	out	0x38, r24	; 56
    1916:	14 c0       	rjmp	.+40     	; 0x1940 <interrupt_Function+0x9c>
		  }
		  else
		  {
			  Object_distance1 = TCNT0 * 1.1072;
    1918:	62 b7       	in	r22, 0x32	; 50
    191a:	70 e0       	ldi	r23, 0x00	; 0
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	0e 94 24 13 	call	0x2648	; 0x2648 <__floatsisf>
    1924:	2b eb       	ldi	r18, 0xBB	; 187
    1926:	38 eb       	ldi	r19, 0xB8	; 184
    1928:	4d e8       	ldi	r20, 0x8D	; 141
    192a:	5f e3       	ldi	r21, 0x3F	; 63
    192c:	0e 94 b0 13 	call	0x2760	; 0x2760 <__mulsf3>
    1930:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <__fixsfsi>
    1934:	dc 01       	movw	r26, r24
    1936:	cb 01       	movw	r24, r22
    1938:	90 93 73 02 	sts	0x0273, r25
    193c:	80 93 72 02 	sts	0x0272, r24
		  }
		  EXTINT_InterruptInit(EXINT_INT0, EXINT_RisingEdge);	
    1940:	80 e0       	ldi	r24, 0x00	; 0
    1942:	63 e0       	ldi	r22, 0x03	; 3
    1944:	0e 94 ba 01 	call	0x374	; 0x374 <EXTINT_InterruptInit>
		  flag_1 = 0;
    1948:	10 92 67 02 	sts	0x0267, r1
		  TCNT0 = 0;
    194c:	12 be       	out	0x32, r1	; 50
    194e:	08 95       	ret

00001950 <ULTRASONIC_Setup>:
		  
	  }
  }
  
     void ULTRASONIC_Setup(ULTRASONIC_DATATYPE U)
	 {
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	26 2f       	mov	r18, r22
    195a:	68 2f       	mov	r22, r24
    195c:	19 2f       	mov	r17, r25
    195e:	d2 2f       	mov	r29, r18
    1960:	c7 2f       	mov	r28, r23
		 /* Make the trigger pin output  */
		 DIO_pinConfiguration(U.ultrasonic_port, U.ultrasonic_Trig, Output);
    1962:	82 2f       	mov	r24, r18
    1964:	97 2f       	mov	r25, r23
    1966:	42 e0       	ldi	r20, 0x02	; 2
    1968:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
		 
		 /* Make the Echo Pin input Note that it must be on of the External interrupt Pin PB2, PD2, PD3 */
		 DIO_pinConfiguration(U.ultrasonic_port, U.ultrasonic_Echo, InputFloat);
    196c:	8d 2f       	mov	r24, r29
    196e:	9c 2f       	mov	r25, r28
    1970:	61 2f       	mov	r22, r17
    1972:	40 e0       	ldi	r20, 0x00	; 0
    1974:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
    1978:	8f ec       	ldi	r24, 0xCF	; 207
    197a:	97 e0       	ldi	r25, 0x07	; 7
    197c:	01 97       	sbiw	r24, 0x01	; 1
    197e:	f1 f7       	brne	.-4      	; 0x197c <ULTRASONIC_Setup+0x2c>
    1980:	00 c0       	rjmp	.+0      	; 0x1982 <ULTRASONIC_Setup+0x32>
    1982:	00 00       	nop
		 
		 _delay_us(500);
		 /* Setup the interrupt pin depend on the user Selection (We Work at INT0, INT1 until handle INT2 ) */
		 switch(U.ultrasonic_Echo)
    1984:	12 30       	cpi	r17, 0x02	; 2
    1986:	19 f0       	breq	.+6      	; 0x198e <ULTRASONIC_Setup+0x3e>
    1988:	13 30       	cpi	r17, 0x03	; 3
    198a:	b1 f4       	brne	.+44     	; 0x19b8 <ULTRASONIC_Setup+0x68>
    198c:	0b c0       	rjmp	.+22     	; 0x19a4 <ULTRASONIC_Setup+0x54>
		 {
			 case PIN2 :
			      /* in this case we Setup the External interrupt Source number 0 */
				  EXTINT_InterruptInit(EXINT_INT0, EXINT_RisingEdge);
    198e:	80 e0       	ldi	r24, 0x00	; 0
    1990:	63 e0       	ldi	r22, 0x03	; 3
    1992:	0e 94 ba 01 	call	0x374	; 0x374 <EXTINT_InterruptInit>
				  /* set the ISR Function depend on the user external interrupt choose */
				  EXTINT0_ISR = interrupt_Function;
    1996:	82 e5       	ldi	r24, 0x52	; 82
    1998:	9c e0       	ldi	r25, 0x0C	; 12
    199a:	90 93 49 02 	sts	0x0249, r25
    199e:	80 93 48 02 	sts	0x0248, r24
			 break;
    19a2:	0a c0       	rjmp	.+20     	; 0x19b8 <ULTRASONIC_Setup+0x68>
			 case PIN3 :
			      /* in this case we Setup the External interrupt Source number 1 */
			      EXTINT_InterruptInit(EXINT_INT1, EXINT_RisingEdge);
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	63 e0       	ldi	r22, 0x03	; 3
    19a8:	0e 94 ba 01 	call	0x374	; 0x374 <EXTINT_InterruptInit>
				  /* set the ISR Function depend on the user external interrupt choose */
				  EXTINT1_ISR = interrupt_Function2;
    19ac:	8c ef       	ldi	r24, 0xFC	; 252
    19ae:	9b e0       	ldi	r25, 0x0B	; 11
    19b0:	90 93 47 02 	sts	0x0247, r25
    19b4:	80 93 46 02 	sts	0x0246, r24
			 /* Handle the error if the user select an Wrong pin to work as Echo pin */
			 break;
		 }
		 	
		 /* Enable the Global Interrupt */
		 SREG |= (1 << 7);		 
    19b8:	8f b7       	in	r24, 0x3f	; 63
    19ba:	80 68       	ori	r24, 0x80	; 128
    19bc:	8f bf       	out	0x3f, r24	; 63
	 }		 
    19be:	df 91       	pop	r29
    19c0:	cf 91       	pop	r28
    19c2:	1f 91       	pop	r17
    19c4:	0f 91       	pop	r16
    19c6:	08 95       	ret

000019c8 <ULTRASONIC_OPERATE>:
     unsigned short ULTRASONIC_OPERATE (ULTRASONIC_DATATYPE U)
	 {
    19c8:	0f 93       	push	r16
    19ca:	1f 93       	push	r17
    19cc:	cf 93       	push	r28
    19ce:	df 93       	push	r29
    19d0:	18 2f       	mov	r17, r24
    19d2:	09 2f       	mov	r16, r25
		 unsigned short distance = 0x00;
    19d4:	d6 2f       	mov	r29, r22
    19d6:	c7 2f       	mov	r28, r23
		 /* start with send the trigger signal */
		 DIO_pinWrite(U.ultrasonic_port,U.ultrasonic_Trig, HIGH);
    19d8:	86 2f       	mov	r24, r22
    19da:	97 2f       	mov	r25, r23
    19dc:	61 2f       	mov	r22, r17
    19de:	41 e0       	ldi	r20, 0x01	; 1
    19e0:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
    19e4:	80 e5       	ldi	r24, 0x50	; 80
    19e6:	8a 95       	dec	r24
    19e8:	f1 f7       	brne	.-4      	; 0x19e6 <ULTRASONIC_OPERATE+0x1e>
		 /* Make The pulse time ON is 10Usec */
		 _delay_us(15);
		 /* Return it to LOW again to be one pulse */
		  DIO_pinWrite(U.ultrasonic_port,U.ultrasonic_Trig, LOW);
    19ea:	8d 2f       	mov	r24, r29
    19ec:	9c 2f       	mov	r25, r28
    19ee:	61 2f       	mov	r22, r17
    19f0:	40 e0       	ldi	r20, 0x00	; 0
    19f2:	0e 94 18 01 	call	0x230	; 0x230 <DIO_pinWrite>
		  switch(U.ultrasonic_Echo)
    19f6:	02 30       	cpi	r16, 0x02	; 2
    19f8:	19 f0       	breq	.+6      	; 0x1a00 <ULTRASONIC_OPERATE+0x38>
    19fa:	03 30       	cpi	r16, 0x03	; 3
    19fc:	59 f4       	brne	.+22     	; 0x1a14 <ULTRASONIC_OPERATE+0x4c>
    19fe:	05 c0       	rjmp	.+10     	; 0x1a0a <ULTRASONIC_OPERATE+0x42>
		  {
			  case PIN2:
			  distance = Object_distance1 ;
    1a00:	80 91 72 02 	lds	r24, 0x0272
    1a04:	90 91 73 02 	lds	r25, 0x0273
			  break;
    1a08:	07 c0       	rjmp	.+14     	; 0x1a18 <ULTRASONIC_OPERATE+0x50>
			  case PIN3:
			  distance = Object_distance2;
    1a0a:	80 91 74 02 	lds	r24, 0x0274
    1a0e:	90 91 75 02 	lds	r25, 0x0275
			  break;
    1a12:	02 c0       	rjmp	.+4      	; 0x1a18 <ULTRASONIC_OPERATE+0x50>
		 /* Enable the Global Interrupt */
		 SREG |= (1 << 7);		 
	 }		 
     unsigned short ULTRASONIC_OPERATE (ULTRASONIC_DATATYPE U)
	 {
		 unsigned short distance = 0x00;
    1a14:	80 e0       	ldi	r24, 0x00	; 0
    1a16:	90 e0       	ldi	r25, 0x00	; 0
			  break;
			  default:
			  break;
		  }
		  return distance;
	 }
    1a18:	df 91       	pop	r29
    1a1a:	cf 91       	pop	r28
    1a1c:	1f 91       	pop	r17
    1a1e:	0f 91       	pop	r16
    1a20:	08 95       	ret

00001a22 <Delay>:
unsigned char TurnOffCode;

static void Delay (int Waitting_Time)
{
	/* Reset the Value of the OneSec we reset the value at the first because we make the WAIT_TIME at the same timer so to make sure it count from 0 */
	OneSec = 0;
    1a22:	10 92 70 02 	sts	0x0270, r1
    1a26:	10 92 6f 02 	sts	0x026F, r1
	GLOBAL_INT_ENABLE();
    1a2a:	2f b7       	in	r18, 0x3f	; 63
    1a2c:	20 68       	ori	r18, 0x80	; 128
    1a2e:	2f bf       	out	0x3f, r18	; 63
	while(OneSec <= Waitting_Time){/* wait */};
    1a30:	20 91 6f 02 	lds	r18, 0x026F
    1a34:	30 91 70 02 	lds	r19, 0x0270
    1a38:	82 17       	cp	r24, r18
    1a3a:	93 07       	cpc	r25, r19
    1a3c:	c8 f7       	brcc	.-14     	; 0x1a30 <Delay+0xe>
	GLOBAL_INT_DISABLE();
    1a3e:	8f b7       	in	r24, 0x3f	; 63
    1a40:	8f 77       	andi	r24, 0x7F	; 127
    1a42:	8f bf       	out	0x3f, r24	; 63
}
    1a44:	08 95       	ret

00001a46 <EnteredData_Display>:

/* Read user input Data From keypad and Display it on the LCD */
static void EnteredData_Display(void)
{
    1a46:	0f 93       	push	r16
    1a48:	1f 93       	push	r17
	do
	{
		Data_Enter = keypad_Read(keypad0);
    1a4a:	00 91 29 02 	lds	r16, 0x0229
    1a4e:	10 91 2a 02 	lds	r17, 0x022A
    1a52:	20 91 2b 02 	lds	r18, 0x022B
    1a56:	30 91 2c 02 	lds	r19, 0x022C
    1a5a:	40 91 2d 02 	lds	r20, 0x022D
    1a5e:	50 91 2e 02 	lds	r21, 0x022E
    1a62:	60 91 2f 02 	lds	r22, 0x022F
    1a66:	70 91 30 02 	lds	r23, 0x0230
    1a6a:	80 91 31 02 	lds	r24, 0x0231
    1a6e:	90 91 32 02 	lds	r25, 0x0232
    1a72:	0e 94 a2 07 	call	0xf44	; 0xf44 <keypad_Read>
    1a76:	80 93 76 02 	sts	0x0276, r24
	} while (Data_Enter == 0);
    1a7a:	88 23       	and	r24, r24
    1a7c:	31 f3       	breq	.-52     	; 0x1a4a <EnteredData_Display+0x4>
	
	/* Display the real char typed for 200msec */
	LCD_DisplayChar(Data_Enter);
    1a7e:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
	Delay(20);
    1a82:	84 e1       	ldi	r24, 0x14	; 20
    1a84:	90 e0       	ldi	r25, 0x00	; 0
    1a86:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
	
	/* store the Owner password on it is place in the memory */
	LCD_Select_RowCol(1, i+5);
    1a8a:	60 91 71 02 	lds	r22, 0x0271
    1a8e:	6b 5f       	subi	r22, 0xFB	; 251
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
	LCD_DisplayChar('*');
    1a96:	8a e2       	ldi	r24, 0x2A	; 42
    1a98:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
}
    1a9c:	1f 91       	pop	r17
    1a9e:	0f 91       	pop	r16
    1aa0:	08 95       	ret

00001aa2 <RoomsControl_Display>:
	}
	
}

static void RoomsControl_Display(void)
{
    1aa2:	2f 92       	push	r2
    1aa4:	3f 92       	push	r3
    1aa6:	4f 92       	push	r4
    1aa8:	5f 92       	push	r5
    1aaa:	6f 92       	push	r6
    1aac:	7f 92       	push	r7
    1aae:	8f 92       	push	r8
    1ab0:	9f 92       	push	r9
    1ab2:	af 92       	push	r10
    1ab4:	bf 92       	push	r11
    1ab6:	cf 92       	push	r12
    1ab8:	df 92       	push	r13
    1aba:	ef 92       	push	r14
    1abc:	ff 92       	push	r15
    1abe:	0f 93       	push	r16
    1ac0:	1f 93       	push	r17
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
	do 
	{
		LCD_Clear();
		/*Display the Control settings in the Owner Mode */
		LCD_DisplayString("1-Room1  2-Room2");
    1ac6:	0f 2e       	mov	r0, r31
    1ac8:	f8 e6       	ldi	r31, 0x68	; 104
    1aca:	cf 2e       	mov	r12, r31
    1acc:	f0 e0       	ldi	r31, 0x00	; 0
    1ace:	df 2e       	mov	r13, r31
    1ad0:	f0 2d       	mov	r31, r0
		}
		/* Stuck until user enter data in this case the data entered not displayed on the LCD so we do not use EnteredData_Display function*/
		do
		{
			Data_Enter = keypad_Read(keypad0);
		} while (Data_Enter == 0 && WAIT_TIME <= ((OPR_MODE == GUEST_MODE) ? GUEST_LIMITEDTIME : OWNER_LIMITEDTIME));
    1ad2:	cc eb       	ldi	r28, 0xBC	; 188
    1ad4:	d2 e0       	ldi	r29, 0x02	; 2
    1ad6:	0f 2e       	mov	r0, r31
    1ad8:	f8 ec       	ldi	r31, 0xC8	; 200
    1ada:	ef 2e       	mov	r14, r31
    1adc:	ff 24       	eor	r15, r15
    1ade:	f0 2d       	mov	r31, r0
			TurnOffCode = ROOM3_OFF;
			Exchange_Byte_Blocking(ROOM3);
			break;
			case '4':
			/* control the Light on the room 4 so we display the current state of the light in the room one and the option ON/OFF/RETURN */
			LCD_DisplayString("Room4   S:");
    1ae0:	0f 2e       	mov	r0, r31
    1ae2:	fd ed       	ldi	r31, 0xDD	; 221
    1ae4:	af 2e       	mov	r10, r31
    1ae6:	f0 e0       	ldi	r31, 0x00	; 0
    1ae8:	bf 2e       	mov	r11, r31
    1aea:	f0 2d       	mov	r31, r0
			case 0:
			/* in this case the user do not enter any data and the time limit is finish */
			break;
			default:
			LCD_Clear();
			LCD_DisplayString("Wrong Input");
    1aec:	0f 2e       	mov	r0, r31
    1aee:	f2 ef       	ldi	r31, 0xF2	; 242
    1af0:	8f 2e       	mov	r8, r31
    1af2:	f0 e0       	ldi	r31, 0x00	; 0
    1af4:	9f 2e       	mov	r9, r31
    1af6:	f0 2d       	mov	r31, r0
			TurnOffCode = ROOM4_OFF;
			Exchange_Byte_Blocking(ROOM4);
			break;
			case '5':
			/* control the operation of the TV so we display the current state of the operation and the option ON/OFF/RETURN */
			LCD_DisplayString("TV     S:");
    1af8:	0f 2e       	mov	r0, r31
    1afa:	f8 ee       	ldi	r31, 0xE8	; 232
    1afc:	6f 2e       	mov	r6, r31
    1afe:	f0 e0       	ldi	r31, 0x00	; 0
    1b00:	7f 2e       	mov	r7, r31
    1b02:	f0 2d       	mov	r31, r0
			TurnOffCode = ROOM1_OFF;
			Exchange_Byte_Blocking(ROOM1);
			break;
			case '2':
			/* control the Light on the room 2 so we display the current state of the light in the room one and the option ON/OFF/RETURN */
			LCD_DisplayString("Room2   S:");
    1b04:	0f 2e       	mov	r0, r31
    1b06:	f7 ec       	ldi	r31, 0xC7	; 199
    1b08:	4f 2e       	mov	r4, r31
    1b0a:	f0 e0       	ldi	r31, 0x00	; 0
    1b0c:	5f 2e       	mov	r5, r31
    1b0e:	f0 2d       	mov	r31, r0
			TurnOffCode = ROOM2_OFF;
			Exchange_Byte_Blocking(ROOM2);
			break;
			case '3':
			/* control the Light on the room 3 so we display the current state of the light in the room one and the option ON/OFF/RETURN */
			LCD_DisplayString("Room3   S:");
    1b10:	0f 2e       	mov	r0, r31
    1b12:	f2 ed       	ldi	r31, 0xD2	; 210
    1b14:	2f 2e       	mov	r2, r31
    1b16:	f0 e0       	ldi	r31, 0x00	; 0
    1b18:	3f 2e       	mov	r3, r31
    1b1a:	f0 2d       	mov	r31, r0

static void RoomsControl_Display(void)
{
	do 
	{
		LCD_Clear();
    1b1c:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
		/*Display the Control settings in the Owner Mode */
		LCD_DisplayString("1-Room1  2-Room2");
    1b20:	c6 01       	movw	r24, r12
    1b22:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		LCD_Select_RowCol(1,0);
    1b26:	81 e0       	ldi	r24, 0x01	; 1
    1b28:	60 e0       	ldi	r22, 0x00	; 0
    1b2a:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		if (OPR_MODE == GUEST_MODE)
    1b2e:	80 91 6c 02 	lds	r24, 0x026C
    1b32:	82 33       	cpi	r24, 0x32	; 50
    1b34:	29 f4       	brne	.+10     	; 0x1b40 <RoomsControl_Display+0x9e>
		{
			LCD_DisplayString("3-Room3  4-Room4");
    1b36:	89 e7       	ldi	r24, 0x79	; 121
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
    1b3e:	06 c0       	rjmp	.+12     	; 0x1b4c <RoomsControl_Display+0xaa>
		}
		else if (OPR_MODE == OWNER_MODE)
    1b40:	81 33       	cpi	r24, 0x31	; 49
    1b42:	21 f4       	brne	.+8      	; 0x1b4c <RoomsControl_Display+0xaa>
		{
			LCD_DisplayString("3-Room3  4-More");
    1b44:	8a e8       	ldi	r24, 0x8A	; 138
    1b46:	90 e0       	ldi	r25, 0x00	; 0
    1b48:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		}
		/* Stuck until user enter data in this case the data entered not displayed on the LCD so we do not use EnteredData_Display function*/
		do
		{
			Data_Enter = keypad_Read(keypad0);
    1b4c:	00 91 29 02 	lds	r16, 0x0229
    1b50:	10 91 2a 02 	lds	r17, 0x022A
    1b54:	20 91 2b 02 	lds	r18, 0x022B
    1b58:	30 91 2c 02 	lds	r19, 0x022C
    1b5c:	40 91 2d 02 	lds	r20, 0x022D
    1b60:	50 91 2e 02 	lds	r21, 0x022E
    1b64:	60 91 2f 02 	lds	r22, 0x022F
    1b68:	70 91 30 02 	lds	r23, 0x0230
    1b6c:	80 91 31 02 	lds	r24, 0x0231
    1b70:	90 91 32 02 	lds	r25, 0x0232
    1b74:	0e 94 a2 07 	call	0xf44	; 0xf44 <keypad_Read>
    1b78:	80 93 76 02 	sts	0x0276, r24
		} while (Data_Enter == 0 && WAIT_TIME <= ((OPR_MODE == GUEST_MODE) ? GUEST_LIMITEDTIME : OWNER_LIMITEDTIME));
    1b7c:	88 23       	and	r24, r24
    1b7e:	71 f4       	brne	.+28     	; 0x1b9c <RoomsControl_Display+0xfa>
    1b80:	90 91 6c 02 	lds	r25, 0x026C
    1b84:	92 33       	cpi	r25, 0x32	; 50
    1b86:	11 f4       	brne	.+4      	; 0x1b8c <RoomsControl_Display+0xea>
    1b88:	a7 01       	movw	r20, r14
    1b8a:	01 c0       	rjmp	.+2      	; 0x1b8e <RoomsControl_Display+0xec>
    1b8c:	ae 01       	movw	r20, r28
    1b8e:	20 91 69 02 	lds	r18, 0x0269
    1b92:	30 91 6a 02 	lds	r19, 0x026A
    1b96:	42 17       	cp	r20, r18
    1b98:	53 07       	cpc	r21, r19
    1b9a:	c0 f6       	brcc	.-80     	; 0x1b4c <RoomsControl_Display+0xaa>
		
		/* Case Of the Owner More Option Display Screen */
		if (Data_Enter == '4' && OPR_MODE == OWNER_MODE)
    1b9c:	84 33       	cpi	r24, 0x34	; 52
    1b9e:	a1 f5       	brne	.+104    	; 0x1c08 <RoomsControl_Display+0x166>
    1ba0:	80 91 6c 02 	lds	r24, 0x026C
    1ba4:	81 33       	cpi	r24, 0x31	; 49
    1ba6:	81 f5       	brne	.+96     	; 0x1c08 <RoomsControl_Display+0x166>
		{
			LCD_Clear();
    1ba8:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
			LCD_DisplayString("4-Room4     5-TV");
    1bac:	8a e9       	ldi	r24, 0x9A	; 154
    1bae:	90 e0       	ldi	r25, 0x00	; 0
    1bb0:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			LCD_Select_RowCol(1,0);
    1bb4:	81 e0       	ldi	r24, 0x01	; 1
    1bb6:	60 e0       	ldi	r22, 0x00	; 0
    1bb8:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
			LCD_DisplayString("6-Air Cond.7-RET");
    1bbc:	8b ea       	ldi	r24, 0xAB	; 171
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			/* Stuck until user enter data in this case the data entered not displayed on the LCD so we do not use EnteredData_Display function*/
			do
			{
				Data_Enter = keypad_Read(keypad0);
    1bc4:	00 91 29 02 	lds	r16, 0x0229
    1bc8:	10 91 2a 02 	lds	r17, 0x022A
    1bcc:	20 91 2b 02 	lds	r18, 0x022B
    1bd0:	30 91 2c 02 	lds	r19, 0x022C
    1bd4:	40 91 2d 02 	lds	r20, 0x022D
    1bd8:	50 91 2e 02 	lds	r21, 0x022E
    1bdc:	60 91 2f 02 	lds	r22, 0x022F
    1be0:	70 91 30 02 	lds	r23, 0x0230
    1be4:	80 91 31 02 	lds	r24, 0x0231
    1be8:	90 91 32 02 	lds	r25, 0x0232
    1bec:	0e 94 a2 07 	call	0xf44	; 0xf44 <keypad_Read>
    1bf0:	80 93 76 02 	sts	0x0276, r24
			} while (Data_Enter == 0 && WAIT_TIME <=  OWNER_LIMITEDTIME);
    1bf4:	88 23       	and	r24, r24
    1bf6:	41 f4       	brne	.+16     	; 0x1c08 <RoomsControl_Display+0x166>
    1bf8:	80 91 69 02 	lds	r24, 0x0269
    1bfc:	90 91 6a 02 	lds	r25, 0x026A
    1c00:	22 e0       	ldi	r18, 0x02	; 2
    1c02:	8d 3b       	cpi	r24, 0xBD	; 189
    1c04:	92 07       	cpc	r25, r18
    1c06:	f0 f2       	brcs	.-68     	; 0x1bc4 <RoomsControl_Display+0x122>
		}
		
		/*depend on the guest user input we select which room we control */
		LCD_Clear();
    1c08:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
		switch(Data_Enter)
    1c0c:	80 91 76 02 	lds	r24, 0x0276
    1c10:	84 33       	cpi	r24, 0x34	; 52
    1c12:	d9 f1       	breq	.+118    	; 0x1c8a <RoomsControl_Display+0x1e8>
    1c14:	85 33       	cpi	r24, 0x35	; 53
    1c16:	58 f4       	brcc	.+22     	; 0x1c2e <RoomsControl_Display+0x18c>
    1c18:	82 33       	cpi	r24, 0x32	; 50
    1c1a:	e9 f0       	breq	.+58     	; 0x1c56 <RoomsControl_Display+0x1b4>
    1c1c:	83 33       	cpi	r24, 0x33	; 51
    1c1e:	40 f5       	brcc	.+80     	; 0x1c70 <RoomsControl_Display+0x1ce>
    1c20:	88 23       	and	r24, r24
    1c22:	09 f4       	brne	.+2      	; 0x1c26 <RoomsControl_Display+0x184>
    1c24:	55 c0       	rjmp	.+170    	; 0x1cd0 <RoomsControl_Display+0x22e>
    1c26:	81 33       	cpi	r24, 0x31	; 49
    1c28:	09 f0       	breq	.+2      	; 0x1c2c <RoomsControl_Display+0x18a>
    1c2a:	49 c0       	rjmp	.+146    	; 0x1cbe <RoomsControl_Display+0x21c>
    1c2c:	06 c0       	rjmp	.+12     	; 0x1c3a <RoomsControl_Display+0x198>
    1c2e:	85 33       	cpi	r24, 0x35	; 53
    1c30:	c9 f1       	breq	.+114    	; 0x1ca4 <RoomsControl_Display+0x202>
    1c32:	88 33       	cpi	r24, 0x38	; 56
    1c34:	08 f0       	brcs	.+2      	; 0x1c38 <RoomsControl_Display+0x196>
    1c36:	43 c0       	rjmp	.+134    	; 0x1cbe <RoomsControl_Display+0x21c>
    1c38:	4b c0       	rjmp	.+150    	; 0x1cd0 <RoomsControl_Display+0x22e>
		{
			case '1':
			/* control the Light on the room 1 so we display the current state of the light in the room one and the option ON/OFF/RETURN */
			LCD_DisplayString("Room1   S:");
    1c3a:	8c eb       	ldi	r24, 0xBC	; 188
    1c3c:	90 e0       	ldi	r25, 0x00	; 0
    1c3e:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			TurnOnCode  = ROOM1_ON;
    1c42:	88 e0       	ldi	r24, 0x08	; 8
    1c44:	80 93 78 02 	sts	0x0278, r24
			TurnOffCode = ROOM1_OFF;
    1c48:	89 e0       	ldi	r24, 0x09	; 9
    1c4a:	80 93 77 02 	sts	0x0277, r24
			Exchange_Byte_Blocking(ROOM1);
    1c4e:	81 e0       	ldi	r24, 0x01	; 1
    1c50:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
			break;
    1c54:	3d c0       	rjmp	.+122    	; 0x1cd0 <RoomsControl_Display+0x22e>
			case '2':
			/* control the Light on the room 2 so we display the current state of the light in the room one and the option ON/OFF/RETURN */
			LCD_DisplayString("Room2   S:");
    1c56:	c2 01       	movw	r24, r4
    1c58:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			TurnOnCode  = ROOM2_ON;
    1c5c:	80 e1       	ldi	r24, 0x10	; 16
    1c5e:	80 93 78 02 	sts	0x0278, r24
			TurnOffCode = ROOM2_OFF;
    1c62:	81 e1       	ldi	r24, 0x11	; 17
    1c64:	80 93 77 02 	sts	0x0277, r24
			Exchange_Byte_Blocking(ROOM2);
    1c68:	82 e0       	ldi	r24, 0x02	; 2
    1c6a:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
			break;
    1c6e:	30 c0       	rjmp	.+96     	; 0x1cd0 <RoomsControl_Display+0x22e>
			case '3':
			/* control the Light on the room 3 so we display the current state of the light in the room one and the option ON/OFF/RETURN */
			LCD_DisplayString("Room3   S:");
    1c70:	c1 01       	movw	r24, r2
    1c72:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			TurnOnCode  = ROOM3_ON;
    1c76:	82 e1       	ldi	r24, 0x12	; 18
    1c78:	80 93 78 02 	sts	0x0278, r24
			TurnOffCode = ROOM3_OFF;
    1c7c:	83 e1       	ldi	r24, 0x13	; 19
    1c7e:	80 93 77 02 	sts	0x0277, r24
			Exchange_Byte_Blocking(ROOM3);
    1c82:	83 e0       	ldi	r24, 0x03	; 3
    1c84:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
			break;
    1c88:	23 c0       	rjmp	.+70     	; 0x1cd0 <RoomsControl_Display+0x22e>
			case '4':
			/* control the Light on the room 4 so we display the current state of the light in the room one and the option ON/OFF/RETURN */
			LCD_DisplayString("Room4   S:");
    1c8a:	c5 01       	movw	r24, r10
    1c8c:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			TurnOnCode  = ROOM4_ON;
    1c90:	84 e1       	ldi	r24, 0x14	; 20
    1c92:	80 93 78 02 	sts	0x0278, r24
			TurnOffCode = ROOM4_OFF;
    1c96:	85 e1       	ldi	r24, 0x15	; 21
    1c98:	80 93 77 02 	sts	0x0277, r24
			Exchange_Byte_Blocking(ROOM4);
    1c9c:	84 e0       	ldi	r24, 0x04	; 4
    1c9e:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
			break;
    1ca2:	16 c0       	rjmp	.+44     	; 0x1cd0 <RoomsControl_Display+0x22e>
			case '5':
			/* control the operation of the TV so we display the current state of the operation and the option ON/OFF/RETURN */
			LCD_DisplayString("TV     S:");
    1ca4:	c3 01       	movw	r24, r6
    1ca6:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			TurnOnCode  = TV_ON;
    1caa:	86 e1       	ldi	r24, 0x16	; 22
    1cac:	80 93 78 02 	sts	0x0278, r24
			TurnOffCode = TV_OFF;
    1cb0:	87 e1       	ldi	r24, 0x17	; 23
    1cb2:	80 93 77 02 	sts	0x0277, r24
			Exchange_Byte_Blocking(TV);
    1cb6:	80 e2       	ldi	r24, 0x20	; 32
    1cb8:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
			break;
    1cbc:	09 c0       	rjmp	.+18     	; 0x1cd0 <RoomsControl_Display+0x22e>
			break;
			case 0:
			/* in this case the user do not enter any data and the time limit is finish */
			break;
			default:
			LCD_Clear();
    1cbe:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
			LCD_DisplayString("Wrong Input");
    1cc2:	c4 01       	movw	r24, r8
    1cc4:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			Delay(50);
    1cc8:	82 e3       	ldi	r24, 0x32	; 50
    1cca:	90 e0       	ldi	r25, 0x00	; 0
    1ccc:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
			break;
		}
		/* If the Data_Enter Equal to '7' that mean the user ask to return to the last screen in this case it will loop again in this function */ 
	} while (Data_Enter == '7' && WAIT_TIME <= OWNER_LIMITEDTIME);
    1cd0:	80 91 76 02 	lds	r24, 0x0276
    1cd4:	87 33       	cpi	r24, 0x37	; 55
    1cd6:	49 f4       	brne	.+18     	; 0x1cea <RoomsControl_Display+0x248>
    1cd8:	80 91 69 02 	lds	r24, 0x0269
    1cdc:	90 91 6a 02 	lds	r25, 0x026A
    1ce0:	22 e0       	ldi	r18, 0x02	; 2
    1ce2:	8d 3b       	cpi	r24, 0xBD	; 189
    1ce4:	92 07       	cpc	r25, r18
    1ce6:	08 f4       	brcc	.+2      	; 0x1cea <RoomsControl_Display+0x248>
    1ce8:	19 cf       	rjmp	.-462    	; 0x1b1c <RoomsControl_Display+0x7a>
}
    1cea:	df 91       	pop	r29
    1cec:	cf 91       	pop	r28
    1cee:	1f 91       	pop	r17
    1cf0:	0f 91       	pop	r16
    1cf2:	ff 90       	pop	r15
    1cf4:	ef 90       	pop	r14
    1cf6:	df 90       	pop	r13
    1cf8:	cf 90       	pop	r12
    1cfa:	bf 90       	pop	r11
    1cfc:	af 90       	pop	r10
    1cfe:	9f 90       	pop	r9
    1d00:	8f 90       	pop	r8
    1d02:	7f 90       	pop	r7
    1d04:	6f 90       	pop	r6
    1d06:	5f 90       	pop	r5
    1d08:	4f 90       	pop	r4
    1d0a:	3f 90       	pop	r3
    1d0c:	2f 90       	pop	r2
    1d0e:	08 95       	ret

00001d10 <SmartHome_INT>:
	
}


void SmartHome_INT(void)
{
    1d10:	0f 93       	push	r16
    1d12:	1f 93       	push	r17
	LCD_init();
    1d14:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_init>
	keypad_Intiat(keypad0);
    1d18:	00 91 29 02 	lds	r16, 0x0229
    1d1c:	10 91 2a 02 	lds	r17, 0x022A
    1d20:	20 91 2b 02 	lds	r18, 0x022B
    1d24:	30 91 2c 02 	lds	r19, 0x022C
    1d28:	40 91 2d 02 	lds	r20, 0x022D
    1d2c:	50 91 2e 02 	lds	r21, 0x022E
    1d30:	60 91 2f 02 	lds	r22, 0x022F
    1d34:	70 91 30 02 	lds	r23, 0x0230
    1d38:	80 91 31 02 	lds	r24, 0x0231
    1d3c:	90 91 32 02 	lds	r25, 0x0232
    1d40:	0e 94 77 07 	call	0xeee	; 0xeee <keypad_Intiat>
	
	/* operate the count of the Timer */
	TIMER_INTIATE(counter);
    1d44:	60 91 25 02 	lds	r22, 0x0225
    1d48:	70 91 26 02 	lds	r23, 0x0226
    1d4c:	80 91 27 02 	lds	r24, 0x0227
    1d50:	90 91 28 02 	lds	r25, 0x0228
    1d54:	0e 94 d7 02 	call	0x5ae	; 0x5ae <TIMER_INTIATE>
	/* set up the CTC top value on it is register */
	TIMER_DELAY(counter, TOP_CTC_VALUE);
    1d58:	60 91 25 02 	lds	r22, 0x0225
    1d5c:	70 91 26 02 	lds	r23, 0x0226
    1d60:	80 91 27 02 	lds	r24, 0x0227
    1d64:	90 91 28 02 	lds	r25, 0x0228
    1d68:	4c e9       	ldi	r20, 0x9C	; 156
    1d6a:	0e 94 67 03 	call	0x6ce	; 0x6ce <TIMER_DELAY>
	
	/* set up the SPI communication to send and receive the data from the Slave */
	SPI_communcation.EnableControl = SPI_Enable;
    1d6e:	81 e0       	ldi	r24, 0x01	; 1
    1d70:	80 93 4a 02 	sts	0x024A, r24
	SPI_communcation.DataOreder = SPI_MSB;
    1d74:	10 92 4d 02 	sts	0x024D, r1
	SPI_communcation.ModeSelect = SPI_MASTER;
    1d78:	80 93 4b 02 	sts	0x024B, r24
	SPI_communcation.ClkMode = SPI_ClkMode0;
    1d7c:	10 92 4e 02 	sts	0x024E, r1
	SPI_communcation.InterruptState = SPI_InterruptDisable;
    1d80:	10 92 4c 02 	sts	0x024C, r1
	SPI_communcation.SCKFreq = SPI_FCPU_By_2;
    1d84:	10 92 51 02 	sts	0x0251, r1
	SPI_Intiat();
    1d88:	0e 94 4b 02 	call	0x496	; 0x496 <SPI_Intiat>
	/* Config  a Chip Select Pin As Output */
	DIO_pinConfiguration(CHIP_SELECT_PORT, CHIP_SELECT_PIN, Output);
    1d8c:	86 e3       	ldi	r24, 0x36	; 54
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	64 e0       	ldi	r22, 0x04	; 4
    1d92:	42 e0       	ldi	r20, 0x02	; 2
    1d94:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIO_pinConfiguration>
	GLOBAL_INT_ENABLE();
    1d98:	8f b7       	in	r24, 0x3f	; 63
    1d9a:	80 68       	ori	r24, 0x80	; 128
    1d9c:	8f bf       	out	0x3f, r24	; 63
	
}
    1d9e:	1f 91       	pop	r17
    1da0:	0f 91       	pop	r16
    1da2:	08 95       	ret

00001da4 <SmartHome_OPR>:


void SmartHome_OPR(void)
{
    1da4:	2f 92       	push	r2
    1da6:	3f 92       	push	r3
    1da8:	4f 92       	push	r4
    1daa:	5f 92       	push	r5
    1dac:	6f 92       	push	r6
    1dae:	7f 92       	push	r7
    1db0:	8f 92       	push	r8
    1db2:	9f 92       	push	r9
    1db4:	af 92       	push	r10
    1db6:	bf 92       	push	r11
    1db8:	cf 92       	push	r12
    1dba:	df 92       	push	r13
    1dbc:	ef 92       	push	r14
    1dbe:	ff 92       	push	r15
    1dc0:	0f 93       	push	r16
    1dc2:	1f 93       	push	r17
    1dc4:	cf 93       	push	r28
    1dc6:	df 93       	push	r29
	
	/* the Initial value of the EEPROM place is 0xFF so if it Still on that case that mean it is first time and we need Setup */
	if (EEPEOM_Read(State_address) == 0xFF)
    1dc8:	81 e0       	ldi	r24, 0x01	; 1
    1dca:	90 e0       	ldi	r25, 0x00	; 0
    1dcc:	0e 94 61 01 	call	0x2c2	; 0x2c2 <EEPEOM_Read>
    1dd0:	8f 3f       	cpi	r24, 0xFF	; 255
    1dd2:	09 f0       	breq	.+2      	; 0x1dd6 <SmartHome_OPR+0x32>
    1dd4:	52 c0       	rjmp	.+164    	; 0x1e7a <SmartHome_OPR+0xd6>
	{
		LCD_Clear();
    1dd6:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
		/* we Want to the welcome screen is display for 500msec so the OneSec counter is increase each 10msec pass so we wait until it reach 50 */
		LCD_DisplayString("Welcome to Smart ");
    1dda:	8e ef       	ldi	r24, 0xFE	; 254
    1ddc:	90 e0       	ldi	r25, 0x00	; 0
    1dde:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		LCD_Select_RowCol(1,0);
    1de2:	81 e0       	ldi	r24, 0x01	; 1
    1de4:	60 e0       	ldi	r22, 0x00	; 0
    1de6:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		LCD_DisplayString("  Home System   ");
    1dea:	80 e1       	ldi	r24, 0x10	; 16
    1dec:	91 e0       	ldi	r25, 0x01	; 1
    1dee:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		/* Display the opening Screen for 1sec */
		Delay(100);
    1df2:	84 e6       	ldi	r24, 0x64	; 100
    1df4:	90 e0       	ldi	r25, 0x00	; 0
    1df6:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
		
		/* Set the Owner Password */
		LCD_Clear();
    1dfa:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
		LCD_DisplayString(" Set Owner Pass : ");
    1dfe:	81 e2       	ldi	r24, 0x21	; 33
    1e00:	91 e0       	ldi	r25, 0x01	; 1
    1e02:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		LCD_Select_RowCol(1,5);
    1e06:	81 e0       	ldi	r24, 0x01	; 1
    1e08:	65 e0       	ldi	r22, 0x05	; 5
    1e0a:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		for (i = 0; i < 5; i++)
    1e0e:	10 92 71 02 	sts	0x0271, r1
		{
			EnteredData_Display();
    1e12:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <EnteredData_Display>
			EEPROM_Write(OwnerPass_address+i, Data_Enter);
    1e16:	80 91 71 02 	lds	r24, 0x0271
    1e1a:	90 e0       	ldi	r25, 0x00	; 0
    1e1c:	02 96       	adiw	r24, 0x02	; 2
    1e1e:	60 91 76 02 	lds	r22, 0x0276
    1e22:	0e 94 56 01 	call	0x2ac	; 0x2ac <EEPROM_Write>
		
		/* Set the Owner Password */
		LCD_Clear();
		LCD_DisplayString(" Set Owner Pass : ");
		LCD_Select_RowCol(1,5);
		for (i = 0; i < 5; i++)
    1e26:	80 91 71 02 	lds	r24, 0x0271
    1e2a:	8f 5f       	subi	r24, 0xFF	; 255
    1e2c:	80 93 71 02 	sts	0x0271, r24
    1e30:	85 30       	cpi	r24, 0x05	; 5
    1e32:	78 f3       	brcs	.-34     	; 0x1e12 <SmartHome_OPR+0x6e>
			EnteredData_Display();
			EEPROM_Write(OwnerPass_address+i, Data_Enter);
		}
		
		/* Set the Guest Password */
		LCD_Clear();
    1e34:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
		LCD_DisplayString(" Set Guest Pass : ");
    1e38:	84 e3       	ldi	r24, 0x34	; 52
    1e3a:	91 e0       	ldi	r25, 0x01	; 1
    1e3c:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		LCD_Select_RowCol(1,5);
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	65 e0       	ldi	r22, 0x05	; 5
    1e44:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		for (i = 0; i < 5; i++)
    1e48:	10 92 71 02 	sts	0x0271, r1
		{
			EnteredData_Display();
    1e4c:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <EnteredData_Display>
			EEPROM_Write(GuestPass_address+i, Data_Enter);
    1e50:	80 91 71 02 	lds	r24, 0x0271
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	08 96       	adiw	r24, 0x08	; 8
    1e58:	60 91 76 02 	lds	r22, 0x0276
    1e5c:	0e 94 56 01 	call	0x2ac	; 0x2ac <EEPROM_Write>
		
		/* Set the Guest Password */
		LCD_Clear();
		LCD_DisplayString(" Set Guest Pass : ");
		LCD_Select_RowCol(1,5);
		for (i = 0; i < 5; i++)
    1e60:	80 91 71 02 	lds	r24, 0x0271
    1e64:	8f 5f       	subi	r24, 0xFF	; 255
    1e66:	80 93 71 02 	sts	0x0271, r24
    1e6a:	85 30       	cpi	r24, 0x05	; 5
    1e6c:	78 f3       	brcs	.-34     	; 0x1e4c <SmartHome_OPR+0xa8>
			EnteredData_Display();
			EEPROM_Write(GuestPass_address+i, Data_Enter);
		}
		
		/* change the EEPROM State place value to mention that the setup configuration is finish */
		EEPROM_Write(State_address, 0x00);
    1e6e:	81 e0       	ldi	r24, 0x01	; 1
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	60 e0       	ldi	r22, 0x00	; 0
    1e74:	0e 94 56 01 	call	0x2ac	; 0x2ac <EEPROM_Write>
    1e78:	af c2       	rjmp	.+1374   	; 0x23d8 <SmartHome_OPR+0x634>
	}
	else if (EEPEOM_Read(State_address) == 0x00)
    1e7a:	81 e0       	ldi	r24, 0x01	; 1
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <EEPEOM_Read>
    1e82:	88 23       	and	r24, r24
    1e84:	09 f0       	breq	.+2      	; 0x1e88 <SmartHome_OPR+0xe4>
    1e86:	90 c2       	rjmp	.+1312   	; 0x23a8 <SmartHome_OPR+0x604>
	{
		LCD_Clear();
    1e88:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
		LCD_DisplayString("Select Mode :");
    1e8c:	87 e4       	ldi	r24, 0x47	; 71
    1e8e:	91 e0       	ldi	r25, 0x01	; 1
    1e90:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		LCD_Select_RowCol(1,0);
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	60 e0       	ldi	r22, 0x00	; 0
    1e98:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		LCD_DisplayString("1-Owner  2-Guest");
    1e9c:	85 e5       	ldi	r24, 0x55	; 85
    1e9e:	91 e0       	ldi	r25, 0x01	; 1
    1ea0:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		
		/* Stuck until user enter data in this case the data entered not displayed on the LCD so we do not use EnteredData_Display function*/
		do
		{
			Data_Enter = keypad_Read(keypad0);
    1ea4:	00 91 29 02 	lds	r16, 0x0229
    1ea8:	10 91 2a 02 	lds	r17, 0x022A
    1eac:	20 91 2b 02 	lds	r18, 0x022B
    1eb0:	30 91 2c 02 	lds	r19, 0x022C
    1eb4:	40 91 2d 02 	lds	r20, 0x022D
    1eb8:	50 91 2e 02 	lds	r21, 0x022E
    1ebc:	60 91 2f 02 	lds	r22, 0x022F
    1ec0:	70 91 30 02 	lds	r23, 0x0230
    1ec4:	80 91 31 02 	lds	r24, 0x0231
    1ec8:	90 91 32 02 	lds	r25, 0x0232
    1ecc:	0e 94 a2 07 	call	0xf44	; 0xf44 <keypad_Read>
    1ed0:	80 93 76 02 	sts	0x0276, r24
		} while (Data_Enter == 0);
    1ed4:	88 23       	and	r24, r24
    1ed6:	31 f3       	breq	.-52     	; 0x1ea4 <SmartHome_OPR+0x100>
		/* checked the entered password depend on the user enter data 1/2 for checked guest or owner Mode */
		OPR_MODE = Data_Enter;
    1ed8:	80 93 6c 02 	sts	0x026C, r24
			LCD_Clear();
    1edc:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
			
			/* check the Enter from the user */
			if (OPR_MODE == OWNER_MODE || OPR_MODE == GUEST_MODE)
    1ee0:	80 91 6c 02 	lds	r24, 0x026C
    1ee4:	98 2f       	mov	r25, r24
    1ee6:	91 53       	subi	r25, 0x31	; 49
    1ee8:	92 30       	cpi	r25, 0x02	; 2
    1eea:	08 f0       	brcs	.+2      	; 0x1eee <SmartHome_OPR+0x14a>
    1eec:	52 c2       	rjmp	.+1188   	; 0x2392 <SmartHome_OPR+0x5ee>
			{
				if (TRAILS_NUM == '0')
    1eee:	90 91 24 02 	lds	r25, 0x0224
    1ef2:	90 33       	cpi	r25, 0x30	; 48
    1ef4:	31 f4       	brne	.+12     	; 0x1f02 <SmartHome_OPR+0x15e>
				{
					/* refer to the locked Mode */
					EEPROM_Write(State_address, '*');
    1ef6:	81 e0       	ldi	r24, 0x01	; 1
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	6a e2       	ldi	r22, 0x2A	; 42
    1efc:	0e 94 56 01 	call	0x2ac	; 0x2ac <EEPROM_Write>
    1f00:	6b c2       	rjmp	.+1238   	; 0x23d8 <SmartHome_OPR+0x634>
}


static void Check_Password(char Mode)
{
	if (Mode == OWNER_MODE)
    1f02:	81 33       	cpi	r24, 0x31	; 49
    1f04:	19 f5       	brne	.+70     	; 0x1f4c <SmartHome_OPR+0x1a8>
	{
		LCD_DisplayString("Enter Owner Pass");
    1f06:	86 e6       	ldi	r24, 0x66	; 102
    1f08:	91 e0       	ldi	r25, 0x01	; 1
    1f0a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		LCD_Select_RowCol(1,5);
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	65 e0       	ldi	r22, 0x05	; 5
    1f12:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		for (i = 0; i < 5; i++)
    1f16:	10 92 71 02 	sts	0x0271, r1
			EnteredData_Display();
			DATA_CHECKED = EEPEOM_Read(OwnerPass_address+i);
			if (DATA_CHECKED != Data_Enter)
			{
				/* if the data input not equal the data stored in memory that mean the password is wrong so make flag = 1 */
				CheckedPass_Flag = 1;
    1f1a:	c1 e0       	ldi	r28, 0x01	; 1
	{
		LCD_DisplayString("Enter Owner Pass");
		LCD_Select_RowCol(1,5);
		for (i = 0; i < 5; i++)
		{
			EnteredData_Display();
    1f1c:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <EnteredData_Display>
			DATA_CHECKED = EEPEOM_Read(OwnerPass_address+i);
    1f20:	80 91 71 02 	lds	r24, 0x0271
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	02 96       	adiw	r24, 0x02	; 2
    1f28:	0e 94 61 01 	call	0x2c2	; 0x2c2 <EEPEOM_Read>
    1f2c:	80 93 6d 02 	sts	0x026D, r24
			if (DATA_CHECKED != Data_Enter)
    1f30:	90 91 76 02 	lds	r25, 0x0276
    1f34:	89 17       	cp	r24, r25
    1f36:	11 f0       	breq	.+4      	; 0x1f3c <SmartHome_OPR+0x198>
			{
				/* if the data input not equal the data stored in memory that mean the password is wrong so make flag = 1 */
				CheckedPass_Flag = 1;
    1f38:	c0 93 6e 02 	sts	0x026E, r28
{
	if (Mode == OWNER_MODE)
	{
		LCD_DisplayString("Enter Owner Pass");
		LCD_Select_RowCol(1,5);
		for (i = 0; i < 5; i++)
    1f3c:	80 91 71 02 	lds	r24, 0x0271
    1f40:	8f 5f       	subi	r24, 0xFF	; 255
    1f42:	80 93 71 02 	sts	0x0271, r24
    1f46:	85 30       	cpi	r24, 0x05	; 5
    1f48:	48 f3       	brcs	.-46     	; 0x1f1c <SmartHome_OPR+0x178>
    1f4a:	24 c0       	rjmp	.+72     	; 0x1f94 <SmartHome_OPR+0x1f0>
				/* if the data input not equal the data stored in memory that mean the password is wrong so make flag = 1 */
				CheckedPass_Flag = 1;
			}
		}
	}
	else if (Mode == GUEST_MODE)
    1f4c:	82 33       	cpi	r24, 0x32	; 50
    1f4e:	11 f5       	brne	.+68     	; 0x1f94 <SmartHome_OPR+0x1f0>
	{
		LCD_DisplayString("Enter Guest Pass");
    1f50:	87 e7       	ldi	r24, 0x77	; 119
    1f52:	91 e0       	ldi	r25, 0x01	; 1
    1f54:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		LCD_Select_RowCol(1,5);
    1f58:	81 e0       	ldi	r24, 0x01	; 1
    1f5a:	65 e0       	ldi	r22, 0x05	; 5
    1f5c:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		for (i = 0; i < 5; i++)
    1f60:	10 92 71 02 	sts	0x0271, r1
			EnteredData_Display();
			DATA_CHECKED = EEPEOM_Read(GuestPass_address+i);
			if (DATA_CHECKED != Data_Enter)
			{
				/* if the data input not equal the data stored in memory that mean the password is wrong so make flag = 1 */
				CheckedPass_Flag = 1;
    1f64:	c1 e0       	ldi	r28, 0x01	; 1
	{
		LCD_DisplayString("Enter Guest Pass");
		LCD_Select_RowCol(1,5);
		for (i = 0; i < 5; i++)
		{
			EnteredData_Display();
    1f66:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <EnteredData_Display>
			DATA_CHECKED = EEPEOM_Read(GuestPass_address+i);
    1f6a:	80 91 71 02 	lds	r24, 0x0271
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
    1f70:	08 96       	adiw	r24, 0x08	; 8
    1f72:	0e 94 61 01 	call	0x2c2	; 0x2c2 <EEPEOM_Read>
    1f76:	80 93 6d 02 	sts	0x026D, r24
			if (DATA_CHECKED != Data_Enter)
    1f7a:	90 91 76 02 	lds	r25, 0x0276
    1f7e:	89 17       	cp	r24, r25
    1f80:	11 f0       	breq	.+4      	; 0x1f86 <SmartHome_OPR+0x1e2>
			{
				/* if the data input not equal the data stored in memory that mean the password is wrong so make flag = 1 */
				CheckedPass_Flag = 1;
    1f82:	c0 93 6e 02 	sts	0x026E, r28
	}
	else if (Mode == GUEST_MODE)
	{
		LCD_DisplayString("Enter Guest Pass");
		LCD_Select_RowCol(1,5);
		for (i = 0; i < 5; i++)
    1f86:	80 91 71 02 	lds	r24, 0x0271
    1f8a:	8f 5f       	subi	r24, 0xFF	; 255
    1f8c:	80 93 71 02 	sts	0x0271, r24
    1f90:	85 30       	cpi	r24, 0x05	; 5
    1f92:	48 f3       	brcs	.-46     	; 0x1f66 <SmartHome_OPR+0x1c2>
					EEPROM_Write(State_address, '*');
				}
				else
				{
					Check_Password(OPR_MODE);
					if(CheckedPass_Flag == 1)
    1f94:	80 91 6e 02 	lds	r24, 0x026E
    1f98:	81 30       	cpi	r24, 0x01	; 1
    1f9a:	e1 f4       	brne	.+56     	; 0x1fd4 <SmartHome_OPR+0x230>
					{
						LCD_Clear();
    1f9c:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
						LCD_DisplayString("Wrong Password");
    1fa0:	88 e8       	ldi	r24, 0x88	; 136
    1fa2:	91 e0       	ldi	r25, 0x01	; 1
    1fa4:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
						LCD_Select_RowCol(1,0);
    1fa8:	81 e0       	ldi	r24, 0x01	; 1
    1faa:	60 e0       	ldi	r22, 0x00	; 0
    1fac:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
						LCD_DisplayString("remain trails ");
    1fb0:	87 e9       	ldi	r24, 0x97	; 151
    1fb2:	91 e0       	ldi	r25, 0x01	; 1
    1fb4:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
						LCD_DisplayChar(TRAILS_NUM);
    1fb8:	80 91 24 02 	lds	r24, 0x0224
    1fbc:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
						Delay(400);
    1fc0:	80 e9       	ldi	r24, 0x90	; 144
    1fc2:	91 e0       	ldi	r25, 0x01	; 1
    1fc4:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
						TRAILS_NUM--;
    1fc8:	80 91 24 02 	lds	r24, 0x0224
    1fcc:	81 50       	subi	r24, 0x01	; 1
    1fce:	80 93 24 02 	sts	0x0224, r24
    1fd2:	02 c2       	rjmp	.+1028   	; 0x23d8 <SmartHome_OPR+0x634>
					}
					else
					{
						LCD_Clear();
    1fd4:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
						if (OPR_MODE == OWNER_MODE)
    1fd8:	80 91 6c 02 	lds	r24, 0x026C
    1fdc:	81 33       	cpi	r24, 0x31	; 49
    1fde:	09 f0       	breq	.+2      	; 0x1fe2 <SmartHome_OPR+0x23e>
    1fe0:	b6 c1       	rjmp	.+876    	; 0x234e <SmartHome_OPR+0x5aa>
						{
							/***************************************************Display the Control settings in the Owner Mode **********************************************/
							GLOBAL_INT_ENABLE();
    1fe2:	8f b7       	in	r24, 0x3f	; 63
    1fe4:	80 68       	ori	r24, 0x80	; 128
    1fe6:	8f bf       	out	0x3f, r24	; 63
							WAIT_TIME = 0;
    1fe8:	10 92 6a 02 	sts	0x026A, r1
    1fec:	10 92 69 02 	sts	0x0269, r1
{
	do 
	{
		/* air condition choice must the user select between the operation of the device or set the temperature */
		LCD_Clear();
		LCD_DisplayString("1-Temp Control");
    1ff0:	0f 2e       	mov	r0, r31
    1ff2:	f6 ea       	ldi	r31, 0xA6	; 166
    1ff4:	cf 2e       	mov	r12, r31
    1ff6:	f1 e0       	ldi	r31, 0x01	; 1
    1ff8:	df 2e       	mov	r13, r31
    1ffa:	f0 2d       	mov	r31, r0
		LCD_Select_RowCol(1,0);
		LCD_DisplayString("2-State  0-RET");
    1ffc:	0f 2e       	mov	r0, r31
    1ffe:	f5 eb       	ldi	r31, 0xB5	; 181
    2000:	af 2e       	mov	r10, r31
    2002:	f1 e0       	ldi	r31, 0x01	; 1
    2004:	bf 2e       	mov	r11, r31
    2006:	f0 2d       	mov	r31, r0
			break;
		}
		else
		{
			LCD_Clear();
			LCD_DisplayString("Wrong Input");
    2008:	0f 2e       	mov	r0, r31
    200a:	f2 ef       	ldi	r31, 0xF2	; 242
    200c:	8f 2e       	mov	r8, r31
    200e:	f0 e0       	ldi	r31, 0x00	; 0
    2010:	9f 2e       	mov	r9, r31
    2012:	f0 2d       	mov	r31, r0
			Data_Enter = keypad_Read(keypad0);
		} while (Data_Enter == 0 && WAIT_TIME <=  OWNER_LIMITEDTIME);
		if (Data_Enter == '1')
		{
			LCD_Clear();
			LCD_DisplayString("Set temp.: __");
    2014:	0f 2e       	mov	r0, r31
    2016:	f4 ec       	ldi	r31, 0xC4	; 196
    2018:	4f 2e       	mov	r4, r31
    201a:	f1 e0       	ldi	r31, 0x01	; 1
    201c:	5f 2e       	mov	r5, r31
    201e:	f0 2d       	mov	r31, r0
		/* Get the Data From the slave of the current State of the Device */
		SLAVE_DATA = Exchange_Byte_Blocking(Dummy);
		switch(SLAVE_DATA)
		{
			case OFF:
			LCD_DisplayString("OFF");
    2020:	0f 2e       	mov	r0, r31
    2022:	f0 ee       	ldi	r31, 0xE0	; 224
    2024:	2f 2e       	mov	r2, r31
    2026:	f1 e0       	ldi	r31, 0x01	; 1
    2028:	3f 2e       	mov	r3, r31
    202a:	f0 2d       	mov	r31, r0
{
	Data_Enter = 0;
	if ((WAIT_TIME <= ((OPR_MODE == GUEST_MODE) ? GUEST_LIMITEDTIME : OWNER_LIMITEDTIME)) && (SLAVE_DATA != Temp_Mode))
	{
		LCD_Select_RowCol(1,0);
		LCD_DisplayString("1-ON 2-OFF 0-RET");
    202c:	0f 2e       	mov	r0, r31
    202e:	f6 ef       	ldi	r31, 0xF6	; 246
    2030:	6f 2e       	mov	r6, r31
    2032:	f1 e0       	ldi	r31, 0x01	; 1
    2034:	7f 2e       	mov	r7, r31
    2036:	f0 2d       	mov	r31, r0
							/***************************************************Display the Control settings in the Owner Mode **********************************************/
							GLOBAL_INT_ENABLE();
							WAIT_TIME = 0;
							do
							{
								RoomsControl_Display();
    2038:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <RoomsControl_Display>
								if (Data_Enter == '6')
    203c:	80 91 76 02 	lds	r24, 0x0276
    2040:	86 33       	cpi	r24, 0x36	; 54
    2042:	09 f0       	breq	.+2      	; 0x2046 <SmartHome_OPR+0x2a2>
    2044:	cd c0       	rjmp	.+410    	; 0x21e0 <SmartHome_OPR+0x43c>
static AirCondition_ControlDisplay(void)
{
	do 
	{
		/* air condition choice must the user select between the operation of the device or set the temperature */
		LCD_Clear();
    2046:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
		LCD_DisplayString("1-Temp Control");
    204a:	c6 01       	movw	r24, r12
    204c:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		LCD_Select_RowCol(1,0);
    2050:	81 e0       	ldi	r24, 0x01	; 1
    2052:	60 e0       	ldi	r22, 0x00	; 0
    2054:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		LCD_DisplayString("2-State  0-RET");
    2058:	c5 01       	movw	r24, r10
    205a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		/* Stuck until user enter data in this case the data entered not displayed on the LCD so we do not use EnteredData_Display function*/
		do
		{
			Data_Enter = keypad_Read(keypad0);
    205e:	00 91 29 02 	lds	r16, 0x0229
    2062:	10 91 2a 02 	lds	r17, 0x022A
    2066:	20 91 2b 02 	lds	r18, 0x022B
    206a:	30 91 2c 02 	lds	r19, 0x022C
    206e:	40 91 2d 02 	lds	r20, 0x022D
    2072:	50 91 2e 02 	lds	r21, 0x022E
    2076:	60 91 2f 02 	lds	r22, 0x022F
    207a:	70 91 30 02 	lds	r23, 0x0230
    207e:	80 91 31 02 	lds	r24, 0x0231
    2082:	90 91 32 02 	lds	r25, 0x0232
    2086:	0e 94 a2 07 	call	0xf44	; 0xf44 <keypad_Read>
    208a:	80 93 76 02 	sts	0x0276, r24
		} while (Data_Enter == 0 && WAIT_TIME <=  OWNER_LIMITEDTIME);
    208e:	88 23       	and	r24, r24
    2090:	49 f4       	brne	.+18     	; 0x20a4 <SmartHome_OPR+0x300>
    2092:	20 91 69 02 	lds	r18, 0x0269
    2096:	30 91 6a 02 	lds	r19, 0x026A
    209a:	92 e0       	ldi	r25, 0x02	; 2
    209c:	2d 3b       	cpi	r18, 0xBD	; 189
    209e:	39 07       	cpc	r19, r25
    20a0:	f0 f2       	brcs	.-68     	; 0x205e <SmartHome_OPR+0x2ba>
    20a2:	78 c0       	rjmp	.+240    	; 0x2194 <SmartHome_OPR+0x3f0>
		if (Data_Enter == '1')
    20a4:	81 33       	cpi	r24, 0x31	; 49
    20a6:	09 f0       	breq	.+2      	; 0x20aa <SmartHome_OPR+0x306>
    20a8:	75 c0       	rjmp	.+234    	; 0x2194 <SmartHome_OPR+0x3f0>
		{
			LCD_Clear();
    20aa:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
			LCD_DisplayString("Set temp.: __");
    20ae:	c2 01       	movw	r24, r4
    20b0:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			LCD_DisplayChar(0xDF); /* The Address Value Of The '' stored in the LCD */
    20b4:	8f ed       	ldi	r24, 0xDF	; 223
    20b6:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
			LCD_DisplayChar('C');
    20ba:	83 e4       	ldi	r24, 0x43	; 67
    20bc:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
			LCD_Select_RowCol(0,11);
    20c0:	80 e0       	ldi	r24, 0x00	; 0
    20c2:	6b e0       	ldi	r22, 0x0B	; 11
    20c4:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
			/* Display the number of the temperature user set level */
			do
			{
				Data_Enter = keypad_Read(keypad0);
    20c8:	00 91 29 02 	lds	r16, 0x0229
    20cc:	10 91 2a 02 	lds	r17, 0x022A
    20d0:	20 91 2b 02 	lds	r18, 0x022B
    20d4:	30 91 2c 02 	lds	r19, 0x022C
    20d8:	40 91 2d 02 	lds	r20, 0x022D
    20dc:	50 91 2e 02 	lds	r21, 0x022E
    20e0:	60 91 2f 02 	lds	r22, 0x022F
    20e4:	70 91 30 02 	lds	r23, 0x0230
    20e8:	80 91 31 02 	lds	r24, 0x0231
    20ec:	90 91 32 02 	lds	r25, 0x0232
    20f0:	0e 94 a2 07 	call	0xf44	; 0xf44 <keypad_Read>
    20f4:	80 93 76 02 	sts	0x0276, r24
			} while (Data_Enter == 0 && WAIT_TIME <=  OWNER_LIMITEDTIME);
    20f8:	88 23       	and	r24, r24
    20fa:	41 f4       	brne	.+16     	; 0x210c <SmartHome_OPR+0x368>
    20fc:	20 91 69 02 	lds	r18, 0x0269
    2100:	30 91 6a 02 	lds	r19, 0x026A
    2104:	92 e0       	ldi	r25, 0x02	; 2
    2106:	2d 3b       	cpi	r18, 0xBD	; 189
    2108:	39 07       	cpc	r19, r25
    210a:	f0 f2       	brcs	.-68     	; 0x20c8 <SmartHome_OPR+0x324>
			LCD_DisplayChar(Data_Enter);
    210c:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
			/* convert the data enter into an integer number */
			TEMP_LEVEL = (Data_Enter-48)*10;
    2110:	80 91 76 02 	lds	r24, 0x0276
    2114:	88 0f       	add	r24, r24
    2116:	98 2f       	mov	r25, r24
    2118:	99 0f       	add	r25, r25
    211a:	99 0f       	add	r25, r25
    211c:	89 0f       	add	r24, r25
    211e:	80 5e       	subi	r24, 0xE0	; 224
    2120:	80 93 68 02 	sts	0x0268, r24
			do
			{
				Data_Enter = keypad_Read(keypad0);
    2124:	00 91 29 02 	lds	r16, 0x0229
    2128:	10 91 2a 02 	lds	r17, 0x022A
    212c:	20 91 2b 02 	lds	r18, 0x022B
    2130:	30 91 2c 02 	lds	r19, 0x022C
    2134:	40 91 2d 02 	lds	r20, 0x022D
    2138:	50 91 2e 02 	lds	r21, 0x022E
    213c:	60 91 2f 02 	lds	r22, 0x022F
    2140:	70 91 30 02 	lds	r23, 0x0230
    2144:	80 91 31 02 	lds	r24, 0x0231
    2148:	90 91 32 02 	lds	r25, 0x0232
    214c:	0e 94 a2 07 	call	0xf44	; 0xf44 <keypad_Read>
    2150:	80 93 76 02 	sts	0x0276, r24
			} while (Data_Enter == 0 && WAIT_TIME <=  OWNER_LIMITEDTIME);
    2154:	88 23       	and	r24, r24
    2156:	41 f4       	brne	.+16     	; 0x2168 <SmartHome_OPR+0x3c4>
    2158:	20 91 69 02 	lds	r18, 0x0269
    215c:	30 91 6a 02 	lds	r19, 0x026A
    2160:	92 e0       	ldi	r25, 0x02	; 2
    2162:	2d 3b       	cpi	r18, 0xBD	; 189
    2164:	39 07       	cpc	r19, r25
    2166:	f0 f2       	brcs	.-68     	; 0x2124 <SmartHome_OPR+0x380>
			LCD_DisplayChar(Data_Enter);
    2168:	0e 94 3e 0a 	call	0x147c	; 0x147c <LCD_DisplayChar>
			TEMP_LEVEL += (Data_Enter -48);
    216c:	90 91 76 02 	lds	r25, 0x0276
    2170:	80 91 68 02 	lds	r24, 0x0268
    2174:	89 0f       	add	r24, r25
    2176:	80 53       	subi	r24, 0x30	; 48
    2178:	80 93 68 02 	sts	0x0268, r24
			Delay(20);
    217c:	84 e1       	ldi	r24, 0x14	; 20
    217e:	90 e0       	ldi	r25, 0x00	; 0
    2180:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
			Exchange_Byte_Blocking(Temp_Mode);
    2184:	83 e3       	ldi	r24, 0x33	; 51
    2186:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
			Exchange_Byte_Blocking(TEMP_LEVEL);
    218a:	80 91 68 02 	lds	r24, 0x0268
    218e:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
    2192:	1d c0       	rjmp	.+58     	; 0x21ce <SmartHome_OPR+0x42a>
			
		}
		else if (Data_Enter == '2')
    2194:	82 33       	cpi	r24, 0x32	; 50
    2196:	81 f4       	brne	.+32     	; 0x21b8 <SmartHome_OPR+0x414>
		{
			LCD_Clear();
    2198:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
			/* control the operation of the air condition so we display the current state of the operation and the option ON/OFF/RETURN */
			LCD_DisplayString("AirCond    S:");
    219c:	82 ed       	ldi	r24, 0xD2	; 210
    219e:	91 e0       	ldi	r25, 0x01	; 1
    21a0:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			TurnOnCode  = AirCond_ON;
    21a4:	88 e1       	ldi	r24, 0x18	; 24
    21a6:	80 93 78 02 	sts	0x0278, r24
			TurnOffCode = AirCond_OFF;
    21aa:	89 e1       	ldi	r24, 0x19	; 25
    21ac:	80 93 77 02 	sts	0x0277, r24
			Exchange_Byte_Blocking(AirCondition);
    21b0:	81 e2       	ldi	r24, 0x21	; 33
    21b2:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
    21b6:	14 c0       	rjmp	.+40     	; 0x21e0 <SmartHome_OPR+0x43c>
			break;
		}
		else if (Data_Enter == '0')
    21b8:	80 33       	cpi	r24, 0x30	; 48
    21ba:	91 f0       	breq	.+36     	; 0x21e0 <SmartHome_OPR+0x43c>
			/* this return choice so we break the current loop */
			break;
		}
		else
		{
			LCD_Clear();
    21bc:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
			LCD_DisplayString("Wrong Input");
    21c0:	c4 01       	movw	r24, r8
    21c2:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			Delay(50);
    21c6:	82 e3       	ldi	r24, 0x32	; 50
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
		}
	} while (WAIT_TIME <= OWNER_LIMITEDTIME);
    21ce:	80 91 69 02 	lds	r24, 0x0269
    21d2:	90 91 6a 02 	lds	r25, 0x026A
    21d6:	22 e0       	ldi	r18, 0x02	; 2
    21d8:	8d 3b       	cpi	r24, 0xBD	; 189
    21da:	92 07       	cpc	r25, r18
    21dc:	08 f4       	brcc	.+2      	; 0x21e0 <SmartHome_OPR+0x43c>
    21de:	33 cf       	rjmp	.-410    	; 0x2046 <SmartHome_OPR+0x2a2>


static DeviceCurrent_stateDisplay(void)
{
	/* To make sure that this function is not going to operate if the time out */
	if (WAIT_TIME <= ((OPR_MODE == GUEST_MODE) ? GUEST_LIMITEDTIME : OWNER_LIMITEDTIME))
    21e0:	80 91 6c 02 	lds	r24, 0x026C
    21e4:	82 33       	cpi	r24, 0x32	; 50
    21e6:	19 f4       	brne	.+6      	; 0x21ee <SmartHome_OPR+0x44a>
    21e8:	28 ec       	ldi	r18, 0xC8	; 200
    21ea:	30 e0       	ldi	r19, 0x00	; 0
    21ec:	02 c0       	rjmp	.+4      	; 0x21f2 <SmartHome_OPR+0x44e>
    21ee:	2c eb       	ldi	r18, 0xBC	; 188
    21f0:	32 e0       	ldi	r19, 0x02	; 2
    21f2:	80 91 69 02 	lds	r24, 0x0269
    21f6:	90 91 6a 02 	lds	r25, 0x026A
    21fa:	28 17       	cp	r18, r24
    21fc:	39 07       	cpc	r19, r25
    21fe:	f8 f0       	brcs	.+62     	; 0x223e <SmartHome_OPR+0x49a>
	{
		/* display the current state of room light or electric device selected */
		/* Stable Delay to SPI System */
		Delay(10);
    2200:	8a e0       	ldi	r24, 0x0A	; 10
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
		/* Get the Data From the slave of the current State of the Device */
		SLAVE_DATA = Exchange_Byte_Blocking(Dummy);
    2208:	80 e0       	ldi	r24, 0x00	; 0
    220a:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
    220e:	80 93 6b 02 	sts	0x026B, r24
		switch(SLAVE_DATA)
    2212:	86 30       	cpi	r24, 0x06	; 6
    2214:	29 f0       	breq	.+10     	; 0x2220 <SmartHome_OPR+0x47c>
    2216:	83 33       	cpi	r24, 0x33	; 51
    2218:	91 f0       	breq	.+36     	; 0x223e <SmartHome_OPR+0x49a>
    221a:	85 30       	cpi	r24, 0x05	; 5
    221c:	51 f4       	brne	.+20     	; 0x2232 <SmartHome_OPR+0x48e>
    221e:	04 c0       	rjmp	.+8      	; 0x2228 <SmartHome_OPR+0x484>
		{
			case OFF:
			LCD_DisplayString("OFF");
    2220:	c1 01       	movw	r24, r2
    2222:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
    2226:	0b c0       	rjmp	.+22     	; 0x223e <SmartHome_OPR+0x49a>
			break;
			case ON:
			LCD_DisplayString("ON");
    2228:	84 ee       	ldi	r24, 0xE4	; 228
    222a:	91 e0       	ldi	r25, 0x01	; 1
    222c:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
    2230:	06 c0       	rjmp	.+12     	; 0x223e <SmartHome_OPR+0x49a>
			break;
			case Temp_Mode:
			/* in this case we do not use this function */
			break;
			default:
			LCD_Clear();
    2232:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
			LCD_DisplayString("Error in Slave");
    2236:	87 ee       	ldi	r24, 0xE7	; 231
    2238:	91 e0       	ldi	r25, 0x01	; 1
    223a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
	}
}

static TurnOnOff_ControlDisplay(void)
{
	Data_Enter = 0;
    223e:	10 92 76 02 	sts	0x0276, r1
	if ((WAIT_TIME <= ((OPR_MODE == GUEST_MODE) ? GUEST_LIMITEDTIME : OWNER_LIMITEDTIME)) && (SLAVE_DATA != Temp_Mode))
    2242:	80 91 6c 02 	lds	r24, 0x026C
    2246:	82 33       	cpi	r24, 0x32	; 50
    2248:	19 f4       	brne	.+6      	; 0x2250 <SmartHome_OPR+0x4ac>
    224a:	28 ec       	ldi	r18, 0xC8	; 200
    224c:	30 e0       	ldi	r19, 0x00	; 0
    224e:	02 c0       	rjmp	.+4      	; 0x2254 <SmartHome_OPR+0x4b0>
    2250:	2c eb       	ldi	r18, 0xBC	; 188
    2252:	32 e0       	ldi	r19, 0x02	; 2
    2254:	80 91 69 02 	lds	r24, 0x0269
    2258:	90 91 6a 02 	lds	r25, 0x026A
    225c:	28 17       	cp	r18, r24
    225e:	39 07       	cpc	r19, r25
    2260:	08 f4       	brcc	.+2      	; 0x2264 <SmartHome_OPR+0x4c0>
    2262:	5a c0       	rjmp	.+180    	; 0x2318 <SmartHome_OPR+0x574>
    2264:	80 91 6b 02 	lds	r24, 0x026B
    2268:	83 33       	cpi	r24, 0x33	; 51
    226a:	09 f4       	brne	.+2      	; 0x226e <SmartHome_OPR+0x4ca>
    226c:	55 c0       	rjmp	.+170    	; 0x2318 <SmartHome_OPR+0x574>
	{
		LCD_Select_RowCol(1,0);
    226e:	81 e0       	ldi	r24, 0x01	; 1
    2270:	60 e0       	ldi	r22, 0x00	; 0
    2272:	0e 94 8e 0a 	call	0x151c	; 0x151c <LCD_Select_RowCol>
		LCD_DisplayString("1-ON 2-OFF 0-RET");
    2276:	c3 01       	movw	r24, r6
    2278:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		/* get the order state from the user */
		do
		{
			Data_Enter = keypad_Read(keypad0);
		} while (Data_Enter == 0 && (WAIT_TIME <= ((OPR_MODE == GUEST_MODE) ? GUEST_LIMITEDTIME : OWNER_LIMITEDTIME)));
    227c:	cc eb       	ldi	r28, 0xBC	; 188
    227e:	d2 e0       	ldi	r29, 0x02	; 2
    2280:	0f 2e       	mov	r0, r31
    2282:	f8 ec       	ldi	r31, 0xC8	; 200
    2284:	ef 2e       	mov	r14, r31
    2286:	ff 24       	eor	r15, r15
    2288:	f0 2d       	mov	r31, r0
		LCD_Select_RowCol(1,0);
		LCD_DisplayString("1-ON 2-OFF 0-RET");
		/* get the order state from the user */
		do
		{
			Data_Enter = keypad_Read(keypad0);
    228a:	00 91 29 02 	lds	r16, 0x0229
    228e:	10 91 2a 02 	lds	r17, 0x022A
    2292:	20 91 2b 02 	lds	r18, 0x022B
    2296:	30 91 2c 02 	lds	r19, 0x022C
    229a:	40 91 2d 02 	lds	r20, 0x022D
    229e:	50 91 2e 02 	lds	r21, 0x022E
    22a2:	60 91 2f 02 	lds	r22, 0x022F
    22a6:	70 91 30 02 	lds	r23, 0x0230
    22aa:	80 91 31 02 	lds	r24, 0x0231
    22ae:	90 91 32 02 	lds	r25, 0x0232
    22b2:	0e 94 a2 07 	call	0xf44	; 0xf44 <keypad_Read>
    22b6:	80 93 76 02 	sts	0x0276, r24
		} while (Data_Enter == 0 && (WAIT_TIME <= ((OPR_MODE == GUEST_MODE) ? GUEST_LIMITEDTIME : OWNER_LIMITEDTIME)));
    22ba:	88 23       	and	r24, r24
    22bc:	71 f4       	brne	.+28     	; 0x22da <SmartHome_OPR+0x536>
    22be:	90 91 6c 02 	lds	r25, 0x026C
    22c2:	92 33       	cpi	r25, 0x32	; 50
    22c4:	11 f4       	brne	.+4      	; 0x22ca <SmartHome_OPR+0x526>
    22c6:	a7 01       	movw	r20, r14
    22c8:	01 c0       	rjmp	.+2      	; 0x22cc <SmartHome_OPR+0x528>
    22ca:	ae 01       	movw	r20, r28
    22cc:	20 91 69 02 	lds	r18, 0x0269
    22d0:	30 91 6a 02 	lds	r19, 0x026A
    22d4:	42 17       	cp	r20, r18
    22d6:	53 07       	cpc	r21, r19
    22d8:	c0 f6       	brcc	.-80     	; 0x228a <SmartHome_OPR+0x4e6>
		
		switch(Data_Enter)
    22da:	81 33       	cpi	r24, 0x31	; 49
    22dc:	51 f0       	breq	.+20     	; 0x22f2 <SmartHome_OPR+0x54e>
    22de:	82 33       	cpi	r24, 0x32	; 50
    22e0:	28 f4       	brcc	.+10     	; 0x22ec <SmartHome_OPR+0x548>
    22e2:	88 23       	and	r24, r24
    22e4:	c9 f0       	breq	.+50     	; 0x2318 <SmartHome_OPR+0x574>
    22e6:	80 33       	cpi	r24, 0x30	; 48
    22e8:	71 f4       	brne	.+28     	; 0x2306 <SmartHome_OPR+0x562>
    22ea:	16 c0       	rjmp	.+44     	; 0x2318 <SmartHome_OPR+0x574>
    22ec:	82 33       	cpi	r24, 0x32	; 50
    22ee:	59 f4       	brne	.+22     	; 0x2306 <SmartHome_OPR+0x562>
    22f0:	05 c0       	rjmp	.+10     	; 0x22fc <SmartHome_OPR+0x558>
		{
			case '1':
			Exchange_Byte_Blocking(TurnOnCode);
    22f2:	80 91 78 02 	lds	r24, 0x0278
    22f6:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
    22fa:	0e c0       	rjmp	.+28     	; 0x2318 <SmartHome_OPR+0x574>
			break;
			case '2':
			Exchange_Byte_Blocking(TurnOffCode);
    22fc:	80 91 77 02 	lds	r24, 0x0277
    2300:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
    2304:	09 c0       	rjmp	.+18     	; 0x2318 <SmartHome_OPR+0x574>
			break;
			case 0:
			/* in this case the user do not enter any data and the time limit is finish */
			break;
			default:
			LCD_Clear();
    2306:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
			LCD_DisplayString("Wrong Input");
    230a:	c4 01       	movw	r24, r8
    230c:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
			Delay(50);
    2310:	82 e3       	ldi	r24, 0x32	; 50
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
									AirCondition_ControlDisplay();
								} 
								DeviceCurrent_stateDisplay();
								TurnOnOff_ControlDisplay();
								
							}while (WAIT_TIME <= OWNER_LIMITEDTIME);
    2318:	80 91 69 02 	lds	r24, 0x0269
    231c:	90 91 6a 02 	lds	r25, 0x026A
    2320:	22 e0       	ldi	r18, 0x02	; 2
    2322:	8d 3b       	cpi	r24, 0xBD	; 189
    2324:	92 07       	cpc	r25, r18
    2326:	08 f4       	brcc	.+2      	; 0x232a <SmartHome_OPR+0x586>
    2328:	87 ce       	rjmp	.-754    	; 0x2038 <SmartHome_OPR+0x294>
							LCD_Clear();
    232a:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
							LCD_DisplayString("    Time Out");
    232e:	87 e0       	ldi	r24, 0x07	; 7
    2330:	92 e0       	ldi	r25, 0x02	; 2
    2332:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
							Delay(50);
    2336:	82 e3       	ldi	r24, 0x32	; 50
    2338:	90 e0       	ldi	r25, 0x00	; 0
    233a:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
							GLOBAL_INT_DISABLE();
    233e:	8f b7       	in	r24, 0x3f	; 63
    2340:	8f 77       	andi	r24, 0x7F	; 127
    2342:	8f bf       	out	0x3f, r24	; 63
							/* Reset the Value of the OneSec */
							WAIT_TIME = 0;
    2344:	10 92 6a 02 	sts	0x026A, r1
    2348:	10 92 69 02 	sts	0x0269, r1
    234c:	45 c0       	rjmp	.+138    	; 0x23d8 <SmartHome_OPR+0x634>
						}
						else
						{
							/***************************************************** Guest Control Display ***************************************************/
							/* we give the guest limited time to control 2min */
							GLOBAL_INT_ENABLE();
    234e:	8f b7       	in	r24, 0x3f	; 63
    2350:	80 68       	ori	r24, 0x80	; 128
    2352:	8f bf       	out	0x3f, r24	; 63
							WAIT_TIME = 0;
    2354:	10 92 6a 02 	sts	0x026A, r1
    2358:	10 92 69 02 	sts	0x0269, r1
							do
							{
								RoomsControl_Display();
    235c:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <RoomsControl_Display>
								
							}while (WAIT_TIME <= GUEST_LIMITEDTIME);
    2360:	80 91 69 02 	lds	r24, 0x0269
    2364:	90 91 6a 02 	lds	r25, 0x026A
    2368:	89 3c       	cpi	r24, 0xC9	; 201
    236a:	91 05       	cpc	r25, r1
    236c:	b8 f3       	brcs	.-18     	; 0x235c <SmartHome_OPR+0x5b8>
							LCD_Clear();
    236e:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
							LCD_DisplayString("    Time Out");
    2372:	87 e0       	ldi	r24, 0x07	; 7
    2374:	92 e0       	ldi	r25, 0x02	; 2
    2376:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
							Delay(50);
    237a:	82 e3       	ldi	r24, 0x32	; 50
    237c:	90 e0       	ldi	r25, 0x00	; 0
    237e:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
							GLOBAL_INT_DISABLE();
    2382:	8f b7       	in	r24, 0x3f	; 63
    2384:	8f 77       	andi	r24, 0x7F	; 127
    2386:	8f bf       	out	0x3f, r24	; 63
							/* Reset the Value of the OneSec */
							WAIT_TIME = 0;
    2388:	10 92 6a 02 	sts	0x026A, r1
    238c:	10 92 69 02 	sts	0x0269, r1
    2390:	23 c0       	rjmp	.+70     	; 0x23d8 <SmartHome_OPR+0x634>
					}
				}
			}
			else
			{
				LCD_Clear();
    2392:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
				LCD_DisplayString("Wrong Input");
    2396:	82 ef       	ldi	r24, 0xF2	; 242
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
				Delay(50);
    239e:	82 e3       	ldi	r24, 0x32	; 50
    23a0:	90 e0       	ldi	r25, 0x00	; 0
    23a2:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
    23a6:	18 c0       	rjmp	.+48     	; 0x23d8 <SmartHome_OPR+0x634>
			}
		
	}
	/* this mean that the user enter the wrong password more than 3 time so it will go to block mode */
	else if (EEPEOM_Read(State_address) == '*')
    23a8:	81 e0       	ldi	r24, 0x01	; 1
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	0e 94 61 01 	call	0x2c2	; 0x2c2 <EEPEOM_Read>
    23b0:	8a 32       	cpi	r24, 0x2A	; 42
    23b2:	91 f4       	brne	.+36     	; 0x23d8 <SmartHome_OPR+0x634>
	{	
		/* we send to lock off all the home devices */	
		Exchange_Byte_Blocking(BLOCK_STATE);
    23b4:	87 e0       	ldi	r24, 0x07	; 7
    23b6:	0e 94 c5 02 	call	0x58a	; 0x58a <Exchange_Byte_Blocking>
		LCD_Clear();
    23ba:	0e 94 3a 0a 	call	0x1474	; 0x1474 <LCD_Clear>
		LCD_DisplayString("Home Block Mode");
    23be:	84 e1       	ldi	r24, 0x14	; 20
    23c0:	92 e0       	ldi	r25, 0x02	; 2
    23c2:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <LCD_DisplayString>
		Delay(1000);
    23c6:	88 ee       	ldi	r24, 0xE8	; 232
    23c8:	93 e0       	ldi	r25, 0x03	; 3
    23ca:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <Delay>
		/* return after 10sec to ask for password */
		EEPROM_Write(State_address, 0x00);
    23ce:	81 e0       	ldi	r24, 0x01	; 1
    23d0:	90 e0       	ldi	r25, 0x00	; 0
    23d2:	60 e0       	ldi	r22, 0x00	; 0
    23d4:	0e 94 56 01 	call	0x2ac	; 0x2ac <EEPROM_Write>
	}
			
}
    23d8:	df 91       	pop	r29
    23da:	cf 91       	pop	r28
    23dc:	1f 91       	pop	r17
    23de:	0f 91       	pop	r16
    23e0:	ff 90       	pop	r15
    23e2:	ef 90       	pop	r14
    23e4:	df 90       	pop	r13
    23e6:	cf 90       	pop	r12
    23e8:	bf 90       	pop	r11
    23ea:	af 90       	pop	r10
    23ec:	9f 90       	pop	r9
    23ee:	8f 90       	pop	r8
    23f0:	7f 90       	pop	r7
    23f2:	6f 90       	pop	r6
    23f4:	5f 90       	pop	r5
    23f6:	4f 90       	pop	r4
    23f8:	3f 90       	pop	r3
    23fa:	2f 90       	pop	r2
    23fc:	08 95       	ret

000023fe <__vector_10>:

/* this definition we get from the ATmega32A_intrrupt Library we implement */
ISR (TIMER0_COMP_vect)
{
    23fe:	1f 92       	push	r1
    2400:	0f 92       	push	r0
    2402:	0f b6       	in	r0, 0x3f	; 63
    2404:	0f 92       	push	r0
    2406:	11 24       	eor	r1, r1
    2408:	8f 93       	push	r24
    240a:	9f 93       	push	r25
	OneSec++;
    240c:	80 91 6f 02 	lds	r24, 0x026F
    2410:	90 91 70 02 	lds	r25, 0x0270
    2414:	01 96       	adiw	r24, 0x01	; 1
    2416:	90 93 70 02 	sts	0x0270, r25
    241a:	80 93 6f 02 	sts	0x026F, r24
	WAIT_TIME++;
    241e:	80 91 69 02 	lds	r24, 0x0269
    2422:	90 91 6a 02 	lds	r25, 0x026A
    2426:	01 96       	adiw	r24, 0x01	; 1
    2428:	90 93 6a 02 	sts	0x026A, r25
    242c:	80 93 69 02 	sts	0x0269, r24
}
    2430:	9f 91       	pop	r25
    2432:	8f 91       	pop	r24
    2434:	0f 90       	pop	r0
    2436:	0f be       	out	0x3f, r0	; 63
    2438:	0f 90       	pop	r0
    243a:	1f 90       	pop	r1
    243c:	18 95       	reti

0000243e <main>:



int main(void)
{
	SmartHome_INT();
    243e:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <SmartHome_INT>
	
    while(1)
    {
		SmartHome_OPR();	
    2442:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <SmartHome_OPR>
    2446:	fd cf       	rjmp	.-6      	; 0x2442 <main+0x4>

00002448 <__subsf3>:
    2448:	50 58       	subi	r21, 0x80	; 128

0000244a <__addsf3>:
    244a:	bb 27       	eor	r27, r27
    244c:	aa 27       	eor	r26, r26
    244e:	0e d0       	rcall	.+28     	; 0x246c <__addsf3x>
    2450:	4d c1       	rjmp	.+666    	; 0x26ec <__fp_round>
    2452:	3e d1       	rcall	.+636    	; 0x26d0 <__fp_pscA>
    2454:	30 f0       	brcs	.+12     	; 0x2462 <__addsf3+0x18>
    2456:	43 d1       	rcall	.+646    	; 0x26de <__fp_pscB>
    2458:	20 f0       	brcs	.+8      	; 0x2462 <__addsf3+0x18>
    245a:	31 f4       	brne	.+12     	; 0x2468 <__addsf3+0x1e>
    245c:	9f 3f       	cpi	r25, 0xFF	; 255
    245e:	11 f4       	brne	.+4      	; 0x2464 <__addsf3+0x1a>
    2460:	1e f4       	brtc	.+6      	; 0x2468 <__addsf3+0x1e>
    2462:	33 c1       	rjmp	.+614    	; 0x26ca <__fp_nan>
    2464:	0e f4       	brtc	.+2      	; 0x2468 <__addsf3+0x1e>
    2466:	e0 95       	com	r30
    2468:	e7 fb       	bst	r30, 7
    246a:	29 c1       	rjmp	.+594    	; 0x26be <__fp_inf>

0000246c <__addsf3x>:
    246c:	e9 2f       	mov	r30, r25
    246e:	4f d1       	rcall	.+670    	; 0x270e <__fp_split3>
    2470:	80 f3       	brcs	.-32     	; 0x2452 <__addsf3+0x8>
    2472:	ba 17       	cp	r27, r26
    2474:	62 07       	cpc	r22, r18
    2476:	73 07       	cpc	r23, r19
    2478:	84 07       	cpc	r24, r20
    247a:	95 07       	cpc	r25, r21
    247c:	18 f0       	brcs	.+6      	; 0x2484 <__addsf3x+0x18>
    247e:	71 f4       	brne	.+28     	; 0x249c <__addsf3x+0x30>
    2480:	9e f5       	brtc	.+102    	; 0x24e8 <__addsf3x+0x7c>
    2482:	67 c1       	rjmp	.+718    	; 0x2752 <__fp_zero>
    2484:	0e f4       	brtc	.+2      	; 0x2488 <__addsf3x+0x1c>
    2486:	e0 95       	com	r30
    2488:	0b 2e       	mov	r0, r27
    248a:	ba 2f       	mov	r27, r26
    248c:	a0 2d       	mov	r26, r0
    248e:	0b 01       	movw	r0, r22
    2490:	b9 01       	movw	r22, r18
    2492:	90 01       	movw	r18, r0
    2494:	0c 01       	movw	r0, r24
    2496:	ca 01       	movw	r24, r20
    2498:	a0 01       	movw	r20, r0
    249a:	11 24       	eor	r1, r1
    249c:	ff 27       	eor	r31, r31
    249e:	59 1b       	sub	r21, r25
    24a0:	99 f0       	breq	.+38     	; 0x24c8 <__addsf3x+0x5c>
    24a2:	59 3f       	cpi	r21, 0xF9	; 249
    24a4:	50 f4       	brcc	.+20     	; 0x24ba <__addsf3x+0x4e>
    24a6:	50 3e       	cpi	r21, 0xE0	; 224
    24a8:	68 f1       	brcs	.+90     	; 0x2504 <__addsf3x+0x98>
    24aa:	1a 16       	cp	r1, r26
    24ac:	f0 40       	sbci	r31, 0x00	; 0
    24ae:	a2 2f       	mov	r26, r18
    24b0:	23 2f       	mov	r18, r19
    24b2:	34 2f       	mov	r19, r20
    24b4:	44 27       	eor	r20, r20
    24b6:	58 5f       	subi	r21, 0xF8	; 248
    24b8:	f3 cf       	rjmp	.-26     	; 0x24a0 <__addsf3x+0x34>
    24ba:	46 95       	lsr	r20
    24bc:	37 95       	ror	r19
    24be:	27 95       	ror	r18
    24c0:	a7 95       	ror	r26
    24c2:	f0 40       	sbci	r31, 0x00	; 0
    24c4:	53 95       	inc	r21
    24c6:	c9 f7       	brne	.-14     	; 0x24ba <__addsf3x+0x4e>
    24c8:	7e f4       	brtc	.+30     	; 0x24e8 <__addsf3x+0x7c>
    24ca:	1f 16       	cp	r1, r31
    24cc:	ba 0b       	sbc	r27, r26
    24ce:	62 0b       	sbc	r22, r18
    24d0:	73 0b       	sbc	r23, r19
    24d2:	84 0b       	sbc	r24, r20
    24d4:	ba f0       	brmi	.+46     	; 0x2504 <__addsf3x+0x98>
    24d6:	91 50       	subi	r25, 0x01	; 1
    24d8:	a1 f0       	breq	.+40     	; 0x2502 <__addsf3x+0x96>
    24da:	ff 0f       	add	r31, r31
    24dc:	bb 1f       	adc	r27, r27
    24de:	66 1f       	adc	r22, r22
    24e0:	77 1f       	adc	r23, r23
    24e2:	88 1f       	adc	r24, r24
    24e4:	c2 f7       	brpl	.-16     	; 0x24d6 <__addsf3x+0x6a>
    24e6:	0e c0       	rjmp	.+28     	; 0x2504 <__addsf3x+0x98>
    24e8:	ba 0f       	add	r27, r26
    24ea:	62 1f       	adc	r22, r18
    24ec:	73 1f       	adc	r23, r19
    24ee:	84 1f       	adc	r24, r20
    24f0:	48 f4       	brcc	.+18     	; 0x2504 <__addsf3x+0x98>
    24f2:	87 95       	ror	r24
    24f4:	77 95       	ror	r23
    24f6:	67 95       	ror	r22
    24f8:	b7 95       	ror	r27
    24fa:	f7 95       	ror	r31
    24fc:	9e 3f       	cpi	r25, 0xFE	; 254
    24fe:	08 f0       	brcs	.+2      	; 0x2502 <__addsf3x+0x96>
    2500:	b3 cf       	rjmp	.-154    	; 0x2468 <__addsf3+0x1e>
    2502:	93 95       	inc	r25
    2504:	88 0f       	add	r24, r24
    2506:	08 f0       	brcs	.+2      	; 0x250a <__addsf3x+0x9e>
    2508:	99 27       	eor	r25, r25
    250a:	ee 0f       	add	r30, r30
    250c:	97 95       	ror	r25
    250e:	87 95       	ror	r24
    2510:	08 95       	ret

00002512 <__divsf3>:
    2512:	0c d0       	rcall	.+24     	; 0x252c <__divsf3x>
    2514:	eb c0       	rjmp	.+470    	; 0x26ec <__fp_round>
    2516:	e3 d0       	rcall	.+454    	; 0x26de <__fp_pscB>
    2518:	40 f0       	brcs	.+16     	; 0x252a <__divsf3+0x18>
    251a:	da d0       	rcall	.+436    	; 0x26d0 <__fp_pscA>
    251c:	30 f0       	brcs	.+12     	; 0x252a <__divsf3+0x18>
    251e:	21 f4       	brne	.+8      	; 0x2528 <__divsf3+0x16>
    2520:	5f 3f       	cpi	r21, 0xFF	; 255
    2522:	19 f0       	breq	.+6      	; 0x252a <__divsf3+0x18>
    2524:	cc c0       	rjmp	.+408    	; 0x26be <__fp_inf>
    2526:	51 11       	cpse	r21, r1
    2528:	15 c1       	rjmp	.+554    	; 0x2754 <__fp_szero>
    252a:	cf c0       	rjmp	.+414    	; 0x26ca <__fp_nan>

0000252c <__divsf3x>:
    252c:	f0 d0       	rcall	.+480    	; 0x270e <__fp_split3>
    252e:	98 f3       	brcs	.-26     	; 0x2516 <__divsf3+0x4>

00002530 <__divsf3_pse>:
    2530:	99 23       	and	r25, r25
    2532:	c9 f3       	breq	.-14     	; 0x2526 <__divsf3+0x14>
    2534:	55 23       	and	r21, r21
    2536:	b1 f3       	breq	.-20     	; 0x2524 <__divsf3+0x12>
    2538:	95 1b       	sub	r25, r21
    253a:	55 0b       	sbc	r21, r21
    253c:	bb 27       	eor	r27, r27
    253e:	aa 27       	eor	r26, r26
    2540:	62 17       	cp	r22, r18
    2542:	73 07       	cpc	r23, r19
    2544:	84 07       	cpc	r24, r20
    2546:	38 f0       	brcs	.+14     	; 0x2556 <__divsf3_pse+0x26>
    2548:	9f 5f       	subi	r25, 0xFF	; 255
    254a:	5f 4f       	sbci	r21, 0xFF	; 255
    254c:	22 0f       	add	r18, r18
    254e:	33 1f       	adc	r19, r19
    2550:	44 1f       	adc	r20, r20
    2552:	aa 1f       	adc	r26, r26
    2554:	a9 f3       	breq	.-22     	; 0x2540 <__divsf3_pse+0x10>
    2556:	33 d0       	rcall	.+102    	; 0x25be <__divsf3_pse+0x8e>
    2558:	0e 2e       	mov	r0, r30
    255a:	3a f0       	brmi	.+14     	; 0x256a <__divsf3_pse+0x3a>
    255c:	e0 e8       	ldi	r30, 0x80	; 128
    255e:	30 d0       	rcall	.+96     	; 0x25c0 <__divsf3_pse+0x90>
    2560:	91 50       	subi	r25, 0x01	; 1
    2562:	50 40       	sbci	r21, 0x00	; 0
    2564:	e6 95       	lsr	r30
    2566:	00 1c       	adc	r0, r0
    2568:	ca f7       	brpl	.-14     	; 0x255c <__divsf3_pse+0x2c>
    256a:	29 d0       	rcall	.+82     	; 0x25be <__divsf3_pse+0x8e>
    256c:	fe 2f       	mov	r31, r30
    256e:	27 d0       	rcall	.+78     	; 0x25be <__divsf3_pse+0x8e>
    2570:	66 0f       	add	r22, r22
    2572:	77 1f       	adc	r23, r23
    2574:	88 1f       	adc	r24, r24
    2576:	bb 1f       	adc	r27, r27
    2578:	26 17       	cp	r18, r22
    257a:	37 07       	cpc	r19, r23
    257c:	48 07       	cpc	r20, r24
    257e:	ab 07       	cpc	r26, r27
    2580:	b0 e8       	ldi	r27, 0x80	; 128
    2582:	09 f0       	breq	.+2      	; 0x2586 <__divsf3_pse+0x56>
    2584:	bb 0b       	sbc	r27, r27
    2586:	80 2d       	mov	r24, r0
    2588:	bf 01       	movw	r22, r30
    258a:	ff 27       	eor	r31, r31
    258c:	93 58       	subi	r25, 0x83	; 131
    258e:	5f 4f       	sbci	r21, 0xFF	; 255
    2590:	2a f0       	brmi	.+10     	; 0x259c <__divsf3_pse+0x6c>
    2592:	9e 3f       	cpi	r25, 0xFE	; 254
    2594:	51 05       	cpc	r21, r1
    2596:	68 f0       	brcs	.+26     	; 0x25b2 <__divsf3_pse+0x82>
    2598:	92 c0       	rjmp	.+292    	; 0x26be <__fp_inf>
    259a:	dc c0       	rjmp	.+440    	; 0x2754 <__fp_szero>
    259c:	5f 3f       	cpi	r21, 0xFF	; 255
    259e:	ec f3       	brlt	.-6      	; 0x259a <__divsf3_pse+0x6a>
    25a0:	98 3e       	cpi	r25, 0xE8	; 232
    25a2:	dc f3       	brlt	.-10     	; 0x259a <__divsf3_pse+0x6a>
    25a4:	86 95       	lsr	r24
    25a6:	77 95       	ror	r23
    25a8:	67 95       	ror	r22
    25aa:	b7 95       	ror	r27
    25ac:	f7 95       	ror	r31
    25ae:	9f 5f       	subi	r25, 0xFF	; 255
    25b0:	c9 f7       	brne	.-14     	; 0x25a4 <__divsf3_pse+0x74>
    25b2:	88 0f       	add	r24, r24
    25b4:	91 1d       	adc	r25, r1
    25b6:	96 95       	lsr	r25
    25b8:	87 95       	ror	r24
    25ba:	97 f9       	bld	r25, 7
    25bc:	08 95       	ret
    25be:	e1 e0       	ldi	r30, 0x01	; 1
    25c0:	66 0f       	add	r22, r22
    25c2:	77 1f       	adc	r23, r23
    25c4:	88 1f       	adc	r24, r24
    25c6:	bb 1f       	adc	r27, r27
    25c8:	62 17       	cp	r22, r18
    25ca:	73 07       	cpc	r23, r19
    25cc:	84 07       	cpc	r24, r20
    25ce:	ba 07       	cpc	r27, r26
    25d0:	20 f0       	brcs	.+8      	; 0x25da <__divsf3_pse+0xaa>
    25d2:	62 1b       	sub	r22, r18
    25d4:	73 0b       	sbc	r23, r19
    25d6:	84 0b       	sbc	r24, r20
    25d8:	ba 0b       	sbc	r27, r26
    25da:	ee 1f       	adc	r30, r30
    25dc:	88 f7       	brcc	.-30     	; 0x25c0 <__divsf3_pse+0x90>
    25de:	e0 95       	com	r30
    25e0:	08 95       	ret

000025e2 <__fixsfsi>:
    25e2:	04 d0       	rcall	.+8      	; 0x25ec <__fixunssfsi>
    25e4:	68 94       	set
    25e6:	b1 11       	cpse	r27, r1
    25e8:	b5 c0       	rjmp	.+362    	; 0x2754 <__fp_szero>
    25ea:	08 95       	ret

000025ec <__fixunssfsi>:
    25ec:	98 d0       	rcall	.+304    	; 0x271e <__fp_splitA>
    25ee:	88 f0       	brcs	.+34     	; 0x2612 <__fixunssfsi+0x26>
    25f0:	9f 57       	subi	r25, 0x7F	; 127
    25f2:	90 f0       	brcs	.+36     	; 0x2618 <__fixunssfsi+0x2c>
    25f4:	b9 2f       	mov	r27, r25
    25f6:	99 27       	eor	r25, r25
    25f8:	b7 51       	subi	r27, 0x17	; 23
    25fa:	a0 f0       	brcs	.+40     	; 0x2624 <__fixunssfsi+0x38>
    25fc:	d1 f0       	breq	.+52     	; 0x2632 <__fixunssfsi+0x46>
    25fe:	66 0f       	add	r22, r22
    2600:	77 1f       	adc	r23, r23
    2602:	88 1f       	adc	r24, r24
    2604:	99 1f       	adc	r25, r25
    2606:	1a f0       	brmi	.+6      	; 0x260e <__fixunssfsi+0x22>
    2608:	ba 95       	dec	r27
    260a:	c9 f7       	brne	.-14     	; 0x25fe <__fixunssfsi+0x12>
    260c:	12 c0       	rjmp	.+36     	; 0x2632 <__fixunssfsi+0x46>
    260e:	b1 30       	cpi	r27, 0x01	; 1
    2610:	81 f0       	breq	.+32     	; 0x2632 <__fixunssfsi+0x46>
    2612:	9f d0       	rcall	.+318    	; 0x2752 <__fp_zero>
    2614:	b1 e0       	ldi	r27, 0x01	; 1
    2616:	08 95       	ret
    2618:	9c c0       	rjmp	.+312    	; 0x2752 <__fp_zero>
    261a:	67 2f       	mov	r22, r23
    261c:	78 2f       	mov	r23, r24
    261e:	88 27       	eor	r24, r24
    2620:	b8 5f       	subi	r27, 0xF8	; 248
    2622:	39 f0       	breq	.+14     	; 0x2632 <__fixunssfsi+0x46>
    2624:	b9 3f       	cpi	r27, 0xF9	; 249
    2626:	cc f3       	brlt	.-14     	; 0x261a <__fixunssfsi+0x2e>
    2628:	86 95       	lsr	r24
    262a:	77 95       	ror	r23
    262c:	67 95       	ror	r22
    262e:	b3 95       	inc	r27
    2630:	d9 f7       	brne	.-10     	; 0x2628 <__fixunssfsi+0x3c>
    2632:	3e f4       	brtc	.+14     	; 0x2642 <__fixunssfsi+0x56>
    2634:	90 95       	com	r25
    2636:	80 95       	com	r24
    2638:	70 95       	com	r23
    263a:	61 95       	neg	r22
    263c:	7f 4f       	sbci	r23, 0xFF	; 255
    263e:	8f 4f       	sbci	r24, 0xFF	; 255
    2640:	9f 4f       	sbci	r25, 0xFF	; 255
    2642:	08 95       	ret

00002644 <__floatunsisf>:
    2644:	e8 94       	clt
    2646:	09 c0       	rjmp	.+18     	; 0x265a <__floatsisf+0x12>

00002648 <__floatsisf>:
    2648:	97 fb       	bst	r25, 7
    264a:	3e f4       	brtc	.+14     	; 0x265a <__floatsisf+0x12>
    264c:	90 95       	com	r25
    264e:	80 95       	com	r24
    2650:	70 95       	com	r23
    2652:	61 95       	neg	r22
    2654:	7f 4f       	sbci	r23, 0xFF	; 255
    2656:	8f 4f       	sbci	r24, 0xFF	; 255
    2658:	9f 4f       	sbci	r25, 0xFF	; 255
    265a:	99 23       	and	r25, r25
    265c:	a9 f0       	breq	.+42     	; 0x2688 <__floatsisf+0x40>
    265e:	f9 2f       	mov	r31, r25
    2660:	96 e9       	ldi	r25, 0x96	; 150
    2662:	bb 27       	eor	r27, r27
    2664:	93 95       	inc	r25
    2666:	f6 95       	lsr	r31
    2668:	87 95       	ror	r24
    266a:	77 95       	ror	r23
    266c:	67 95       	ror	r22
    266e:	b7 95       	ror	r27
    2670:	f1 11       	cpse	r31, r1
    2672:	f8 cf       	rjmp	.-16     	; 0x2664 <__floatsisf+0x1c>
    2674:	fa f4       	brpl	.+62     	; 0x26b4 <__floatsisf+0x6c>
    2676:	bb 0f       	add	r27, r27
    2678:	11 f4       	brne	.+4      	; 0x267e <__floatsisf+0x36>
    267a:	60 ff       	sbrs	r22, 0
    267c:	1b c0       	rjmp	.+54     	; 0x26b4 <__floatsisf+0x6c>
    267e:	6f 5f       	subi	r22, 0xFF	; 255
    2680:	7f 4f       	sbci	r23, 0xFF	; 255
    2682:	8f 4f       	sbci	r24, 0xFF	; 255
    2684:	9f 4f       	sbci	r25, 0xFF	; 255
    2686:	16 c0       	rjmp	.+44     	; 0x26b4 <__floatsisf+0x6c>
    2688:	88 23       	and	r24, r24
    268a:	11 f0       	breq	.+4      	; 0x2690 <__floatsisf+0x48>
    268c:	96 e9       	ldi	r25, 0x96	; 150
    268e:	11 c0       	rjmp	.+34     	; 0x26b2 <__floatsisf+0x6a>
    2690:	77 23       	and	r23, r23
    2692:	21 f0       	breq	.+8      	; 0x269c <__floatsisf+0x54>
    2694:	9e e8       	ldi	r25, 0x8E	; 142
    2696:	87 2f       	mov	r24, r23
    2698:	76 2f       	mov	r23, r22
    269a:	05 c0       	rjmp	.+10     	; 0x26a6 <__floatsisf+0x5e>
    269c:	66 23       	and	r22, r22
    269e:	71 f0       	breq	.+28     	; 0x26bc <__floatsisf+0x74>
    26a0:	96 e8       	ldi	r25, 0x86	; 134
    26a2:	86 2f       	mov	r24, r22
    26a4:	70 e0       	ldi	r23, 0x00	; 0
    26a6:	60 e0       	ldi	r22, 0x00	; 0
    26a8:	2a f0       	brmi	.+10     	; 0x26b4 <__floatsisf+0x6c>
    26aa:	9a 95       	dec	r25
    26ac:	66 0f       	add	r22, r22
    26ae:	77 1f       	adc	r23, r23
    26b0:	88 1f       	adc	r24, r24
    26b2:	da f7       	brpl	.-10     	; 0x26aa <__floatsisf+0x62>
    26b4:	88 0f       	add	r24, r24
    26b6:	96 95       	lsr	r25
    26b8:	87 95       	ror	r24
    26ba:	97 f9       	bld	r25, 7
    26bc:	08 95       	ret

000026be <__fp_inf>:
    26be:	97 f9       	bld	r25, 7
    26c0:	9f 67       	ori	r25, 0x7F	; 127
    26c2:	80 e8       	ldi	r24, 0x80	; 128
    26c4:	70 e0       	ldi	r23, 0x00	; 0
    26c6:	60 e0       	ldi	r22, 0x00	; 0
    26c8:	08 95       	ret

000026ca <__fp_nan>:
    26ca:	9f ef       	ldi	r25, 0xFF	; 255
    26cc:	80 ec       	ldi	r24, 0xC0	; 192
    26ce:	08 95       	ret

000026d0 <__fp_pscA>:
    26d0:	00 24       	eor	r0, r0
    26d2:	0a 94       	dec	r0
    26d4:	16 16       	cp	r1, r22
    26d6:	17 06       	cpc	r1, r23
    26d8:	18 06       	cpc	r1, r24
    26da:	09 06       	cpc	r0, r25
    26dc:	08 95       	ret

000026de <__fp_pscB>:
    26de:	00 24       	eor	r0, r0
    26e0:	0a 94       	dec	r0
    26e2:	12 16       	cp	r1, r18
    26e4:	13 06       	cpc	r1, r19
    26e6:	14 06       	cpc	r1, r20
    26e8:	05 06       	cpc	r0, r21
    26ea:	08 95       	ret

000026ec <__fp_round>:
    26ec:	09 2e       	mov	r0, r25
    26ee:	03 94       	inc	r0
    26f0:	00 0c       	add	r0, r0
    26f2:	11 f4       	brne	.+4      	; 0x26f8 <__fp_round+0xc>
    26f4:	88 23       	and	r24, r24
    26f6:	52 f0       	brmi	.+20     	; 0x270c <__fp_round+0x20>
    26f8:	bb 0f       	add	r27, r27
    26fa:	40 f4       	brcc	.+16     	; 0x270c <__fp_round+0x20>
    26fc:	bf 2b       	or	r27, r31
    26fe:	11 f4       	brne	.+4      	; 0x2704 <__fp_round+0x18>
    2700:	60 ff       	sbrs	r22, 0
    2702:	04 c0       	rjmp	.+8      	; 0x270c <__fp_round+0x20>
    2704:	6f 5f       	subi	r22, 0xFF	; 255
    2706:	7f 4f       	sbci	r23, 0xFF	; 255
    2708:	8f 4f       	sbci	r24, 0xFF	; 255
    270a:	9f 4f       	sbci	r25, 0xFF	; 255
    270c:	08 95       	ret

0000270e <__fp_split3>:
    270e:	57 fd       	sbrc	r21, 7
    2710:	90 58       	subi	r25, 0x80	; 128
    2712:	44 0f       	add	r20, r20
    2714:	55 1f       	adc	r21, r21
    2716:	59 f0       	breq	.+22     	; 0x272e <__fp_splitA+0x10>
    2718:	5f 3f       	cpi	r21, 0xFF	; 255
    271a:	71 f0       	breq	.+28     	; 0x2738 <__fp_splitA+0x1a>
    271c:	47 95       	ror	r20

0000271e <__fp_splitA>:
    271e:	88 0f       	add	r24, r24
    2720:	97 fb       	bst	r25, 7
    2722:	99 1f       	adc	r25, r25
    2724:	61 f0       	breq	.+24     	; 0x273e <__fp_splitA+0x20>
    2726:	9f 3f       	cpi	r25, 0xFF	; 255
    2728:	79 f0       	breq	.+30     	; 0x2748 <__fp_splitA+0x2a>
    272a:	87 95       	ror	r24
    272c:	08 95       	ret
    272e:	12 16       	cp	r1, r18
    2730:	13 06       	cpc	r1, r19
    2732:	14 06       	cpc	r1, r20
    2734:	55 1f       	adc	r21, r21
    2736:	f2 cf       	rjmp	.-28     	; 0x271c <__fp_split3+0xe>
    2738:	46 95       	lsr	r20
    273a:	f1 df       	rcall	.-30     	; 0x271e <__fp_splitA>
    273c:	08 c0       	rjmp	.+16     	; 0x274e <__fp_splitA+0x30>
    273e:	16 16       	cp	r1, r22
    2740:	17 06       	cpc	r1, r23
    2742:	18 06       	cpc	r1, r24
    2744:	99 1f       	adc	r25, r25
    2746:	f1 cf       	rjmp	.-30     	; 0x272a <__fp_splitA+0xc>
    2748:	86 95       	lsr	r24
    274a:	71 05       	cpc	r23, r1
    274c:	61 05       	cpc	r22, r1
    274e:	08 94       	sec
    2750:	08 95       	ret

00002752 <__fp_zero>:
    2752:	e8 94       	clt

00002754 <__fp_szero>:
    2754:	bb 27       	eor	r27, r27
    2756:	66 27       	eor	r22, r22
    2758:	77 27       	eor	r23, r23
    275a:	cb 01       	movw	r24, r22
    275c:	97 f9       	bld	r25, 7
    275e:	08 95       	ret

00002760 <__mulsf3>:
    2760:	0b d0       	rcall	.+22     	; 0x2778 <__mulsf3x>
    2762:	c4 cf       	rjmp	.-120    	; 0x26ec <__fp_round>
    2764:	b5 df       	rcall	.-150    	; 0x26d0 <__fp_pscA>
    2766:	28 f0       	brcs	.+10     	; 0x2772 <__mulsf3+0x12>
    2768:	ba df       	rcall	.-140    	; 0x26de <__fp_pscB>
    276a:	18 f0       	brcs	.+6      	; 0x2772 <__mulsf3+0x12>
    276c:	95 23       	and	r25, r21
    276e:	09 f0       	breq	.+2      	; 0x2772 <__mulsf3+0x12>
    2770:	a6 cf       	rjmp	.-180    	; 0x26be <__fp_inf>
    2772:	ab cf       	rjmp	.-170    	; 0x26ca <__fp_nan>
    2774:	11 24       	eor	r1, r1
    2776:	ee cf       	rjmp	.-36     	; 0x2754 <__fp_szero>

00002778 <__mulsf3x>:
    2778:	ca df       	rcall	.-108    	; 0x270e <__fp_split3>
    277a:	a0 f3       	brcs	.-24     	; 0x2764 <__mulsf3+0x4>

0000277c <__mulsf3_pse>:
    277c:	95 9f       	mul	r25, r21
    277e:	d1 f3       	breq	.-12     	; 0x2774 <__mulsf3+0x14>
    2780:	95 0f       	add	r25, r21
    2782:	50 e0       	ldi	r21, 0x00	; 0
    2784:	55 1f       	adc	r21, r21
    2786:	62 9f       	mul	r22, r18
    2788:	f0 01       	movw	r30, r0
    278a:	72 9f       	mul	r23, r18
    278c:	bb 27       	eor	r27, r27
    278e:	f0 0d       	add	r31, r0
    2790:	b1 1d       	adc	r27, r1
    2792:	63 9f       	mul	r22, r19
    2794:	aa 27       	eor	r26, r26
    2796:	f0 0d       	add	r31, r0
    2798:	b1 1d       	adc	r27, r1
    279a:	aa 1f       	adc	r26, r26
    279c:	64 9f       	mul	r22, r20
    279e:	66 27       	eor	r22, r22
    27a0:	b0 0d       	add	r27, r0
    27a2:	a1 1d       	adc	r26, r1
    27a4:	66 1f       	adc	r22, r22
    27a6:	82 9f       	mul	r24, r18
    27a8:	22 27       	eor	r18, r18
    27aa:	b0 0d       	add	r27, r0
    27ac:	a1 1d       	adc	r26, r1
    27ae:	62 1f       	adc	r22, r18
    27b0:	73 9f       	mul	r23, r19
    27b2:	b0 0d       	add	r27, r0
    27b4:	a1 1d       	adc	r26, r1
    27b6:	62 1f       	adc	r22, r18
    27b8:	83 9f       	mul	r24, r19
    27ba:	a0 0d       	add	r26, r0
    27bc:	61 1d       	adc	r22, r1
    27be:	22 1f       	adc	r18, r18
    27c0:	74 9f       	mul	r23, r20
    27c2:	33 27       	eor	r19, r19
    27c4:	a0 0d       	add	r26, r0
    27c6:	61 1d       	adc	r22, r1
    27c8:	23 1f       	adc	r18, r19
    27ca:	84 9f       	mul	r24, r20
    27cc:	60 0d       	add	r22, r0
    27ce:	21 1d       	adc	r18, r1
    27d0:	82 2f       	mov	r24, r18
    27d2:	76 2f       	mov	r23, r22
    27d4:	6a 2f       	mov	r22, r26
    27d6:	11 24       	eor	r1, r1
    27d8:	9f 57       	subi	r25, 0x7F	; 127
    27da:	50 40       	sbci	r21, 0x00	; 0
    27dc:	8a f0       	brmi	.+34     	; 0x2800 <__mulsf3_pse+0x84>
    27de:	e1 f0       	breq	.+56     	; 0x2818 <__mulsf3_pse+0x9c>
    27e0:	88 23       	and	r24, r24
    27e2:	4a f0       	brmi	.+18     	; 0x27f6 <__mulsf3_pse+0x7a>
    27e4:	ee 0f       	add	r30, r30
    27e6:	ff 1f       	adc	r31, r31
    27e8:	bb 1f       	adc	r27, r27
    27ea:	66 1f       	adc	r22, r22
    27ec:	77 1f       	adc	r23, r23
    27ee:	88 1f       	adc	r24, r24
    27f0:	91 50       	subi	r25, 0x01	; 1
    27f2:	50 40       	sbci	r21, 0x00	; 0
    27f4:	a9 f7       	brne	.-22     	; 0x27e0 <__mulsf3_pse+0x64>
    27f6:	9e 3f       	cpi	r25, 0xFE	; 254
    27f8:	51 05       	cpc	r21, r1
    27fa:	70 f0       	brcs	.+28     	; 0x2818 <__mulsf3_pse+0x9c>
    27fc:	60 cf       	rjmp	.-320    	; 0x26be <__fp_inf>
    27fe:	aa cf       	rjmp	.-172    	; 0x2754 <__fp_szero>
    2800:	5f 3f       	cpi	r21, 0xFF	; 255
    2802:	ec f3       	brlt	.-6      	; 0x27fe <__mulsf3_pse+0x82>
    2804:	98 3e       	cpi	r25, 0xE8	; 232
    2806:	dc f3       	brlt	.-10     	; 0x27fe <__mulsf3_pse+0x82>
    2808:	86 95       	lsr	r24
    280a:	77 95       	ror	r23
    280c:	67 95       	ror	r22
    280e:	b7 95       	ror	r27
    2810:	f7 95       	ror	r31
    2812:	e7 95       	ror	r30
    2814:	9f 5f       	subi	r25, 0xFF	; 255
    2816:	c1 f7       	brne	.-16     	; 0x2808 <__mulsf3_pse+0x8c>
    2818:	fe 2b       	or	r31, r30
    281a:	88 0f       	add	r24, r24
    281c:	91 1d       	adc	r25, r1
    281e:	96 95       	lsr	r25
    2820:	87 95       	ror	r24
    2822:	97 f9       	bld	r25, 7
    2824:	08 95       	ret

00002826 <utoa>:
    2826:	fb 01       	movw	r30, r22
    2828:	9f 01       	movw	r18, r30
    282a:	42 30       	cpi	r20, 0x02	; 2
    282c:	74 f0       	brlt	.+28     	; 0x284a <utoa+0x24>
    282e:	45 32       	cpi	r20, 0x25	; 37
    2830:	64 f4       	brge	.+24     	; 0x284a <utoa+0x24>
    2832:	64 2f       	mov	r22, r20
    2834:	77 27       	eor	r23, r23
    2836:	0e 94 39 14 	call	0x2872	; 0x2872 <__udivmodhi4>
    283a:	80 5d       	subi	r24, 0xD0	; 208
    283c:	8a 33       	cpi	r24, 0x3A	; 58
    283e:	0c f0       	brlt	.+2      	; 0x2842 <utoa+0x1c>
    2840:	89 5d       	subi	r24, 0xD9	; 217
    2842:	81 93       	st	Z+, r24
    2844:	cb 01       	movw	r24, r22
    2846:	00 97       	sbiw	r24, 0x00	; 0
    2848:	a1 f7       	brne	.-24     	; 0x2832 <utoa+0xc>
    284a:	10 82       	st	Z, r1
    284c:	c9 01       	movw	r24, r18
    284e:	0c 94 29 14 	jmp	0x2852	; 0x2852 <strrev>

00002852 <strrev>:
    2852:	dc 01       	movw	r26, r24
    2854:	fc 01       	movw	r30, r24
    2856:	67 2f       	mov	r22, r23
    2858:	71 91       	ld	r23, Z+
    285a:	77 23       	and	r23, r23
    285c:	e1 f7       	brne	.-8      	; 0x2856 <strrev+0x4>
    285e:	32 97       	sbiw	r30, 0x02	; 2
    2860:	04 c0       	rjmp	.+8      	; 0x286a <strrev+0x18>
    2862:	7c 91       	ld	r23, X
    2864:	6d 93       	st	X+, r22
    2866:	70 83       	st	Z, r23
    2868:	62 91       	ld	r22, -Z
    286a:	ae 17       	cp	r26, r30
    286c:	bf 07       	cpc	r27, r31
    286e:	c8 f3       	brcs	.-14     	; 0x2862 <strrev+0x10>
    2870:	08 95       	ret

00002872 <__udivmodhi4>:
    2872:	aa 1b       	sub	r26, r26
    2874:	bb 1b       	sub	r27, r27
    2876:	51 e1       	ldi	r21, 0x11	; 17
    2878:	07 c0       	rjmp	.+14     	; 0x2888 <__udivmodhi4_ep>

0000287a <__udivmodhi4_loop>:
    287a:	aa 1f       	adc	r26, r26
    287c:	bb 1f       	adc	r27, r27
    287e:	a6 17       	cp	r26, r22
    2880:	b7 07       	cpc	r27, r23
    2882:	10 f0       	brcs	.+4      	; 0x2888 <__udivmodhi4_ep>
    2884:	a6 1b       	sub	r26, r22
    2886:	b7 0b       	sbc	r27, r23

00002888 <__udivmodhi4_ep>:
    2888:	88 1f       	adc	r24, r24
    288a:	99 1f       	adc	r25, r25
    288c:	5a 95       	dec	r21
    288e:	a9 f7       	brne	.-22     	; 0x287a <__udivmodhi4_loop>
    2890:	80 95       	com	r24
    2892:	90 95       	com	r25
    2894:	bc 01       	movw	r22, r24
    2896:	cd 01       	movw	r24, r26
    2898:	08 95       	ret

0000289a <_exit>:
    289a:	f8 94       	cli

0000289c <__stop_program>:
    289c:	ff cf       	rjmp	.-2      	; 0x289c <__stop_program>
