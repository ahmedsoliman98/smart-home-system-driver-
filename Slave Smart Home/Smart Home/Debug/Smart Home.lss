
Smart Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000221e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000012  00800060  0000221e  000022b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003d  00800072  00800072  000022c4  2**0
                  ALLOC
  3 .stab         00002370  00000000  00000000  000022c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000770  00000000  00000000  00004634  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000320  00000000  00000000  00004da8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004210  00000000  00000000  000050c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015fe  00000000  00000000  000092d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001fd4  00000000  00000000  0000a8d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a38  00000000  00000000  0000c8ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000018d7  00000000  00000000  0000d2e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000024af  00000000  00000000  0000ebbb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5d 00 	jmp	0xba	; 0xba <__ctors_end>
       4:	0c 94 9b 01 	jmp	0x336	; 0x336 <__vector_1>
       8:	0c 94 c4 01 	jmp	0x388	; 0x388 <__vector_2>
       c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      10:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      14:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      18:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      1c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      20:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      24:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      28:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      2c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      30:	0c 94 55 02 	jmp	0x4aa	; 0x4aa <__vector_12>
      34:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      38:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      3c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      40:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      44:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      48:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      4c:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      50:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__bad_interrupt>
      54:	ba 0d       	add	r27, r10
      56:	c9 0d       	add	r28, r9
      58:	d8 0d       	add	r29, r8
      5a:	e7 0d       	add	r30, r7
      5c:	76 0e       	add	r7, r22
      5e:	76 0e       	add	r7, r22
      60:	76 0e       	add	r7, r22
      62:	1d 0e       	add	r1, r29
      64:	24 0e       	add	r2, r20
      66:	76 0e       	add	r7, r22
      68:	76 0e       	add	r7, r22
      6a:	76 0e       	add	r7, r22
      6c:	76 0e       	add	r7, r22
      6e:	76 0e       	add	r7, r22
      70:	76 0e       	add	r7, r22
      72:	2b 0e       	add	r2, r27
      74:	32 0e       	add	r3, r18
      76:	39 0e       	add	r3, r25
      78:	40 0e       	add	r4, r16
      7a:	47 0e       	add	r4, r23
      7c:	4e 0e       	add	r4, r30
      7e:	55 0e       	add	r5, r21
      80:	5c 0e       	add	r5, r28
      82:	63 0e       	add	r6, r19
      84:	6d 0e       	add	r6, r29
      86:	76 0e       	add	r7, r22
      88:	76 0e       	add	r7, r22
      8a:	76 0e       	add	r7, r22
      8c:	76 0e       	add	r7, r22
      8e:	76 0e       	add	r7, r22
      90:	76 0e       	add	r7, r22
      92:	f6 0d       	add	r31, r6
      94:	05 0e       	add	r0, r21
      96:	76 0e       	add	r7, r22
      98:	76 0e       	add	r7, r22
      9a:	76 0e       	add	r7, r22
      9c:	76 0e       	add	r7, r22
      9e:	76 0e       	add	r7, r22
      a0:	76 0e       	add	r7, r22
      a2:	76 0e       	add	r7, r22
      a4:	76 0e       	add	r7, r22
      a6:	76 0e       	add	r7, r22
      a8:	76 0e       	add	r7, r22
      aa:	76 0e       	add	r7, r22
      ac:	76 0e       	add	r7, r22
      ae:	76 0e       	add	r7, r22
      b0:	76 0e       	add	r7, r22
      b2:	76 0e       	add	r7, r22
      b4:	76 0e       	add	r7, r22
      b6:	76 0e       	add	r7, r22
      b8:	14 0e       	add	r1, r20

000000ba <__ctors_end>:
      ba:	11 24       	eor	r1, r1
      bc:	1f be       	out	0x3f, r1	; 63
      be:	cf e5       	ldi	r28, 0x5F	; 95
      c0:	d8 e0       	ldi	r29, 0x08	; 8
      c2:	de bf       	out	0x3e, r29	; 62
      c4:	cd bf       	out	0x3d, r28	; 61

000000c6 <__do_copy_data>:
      c6:	10 e0       	ldi	r17, 0x00	; 0
      c8:	a0 e6       	ldi	r26, 0x60	; 96
      ca:	b0 e0       	ldi	r27, 0x00	; 0
      cc:	ee e1       	ldi	r30, 0x1E	; 30
      ce:	f2 e2       	ldi	r31, 0x22	; 34
      d0:	02 c0       	rjmp	.+4      	; 0xd6 <__do_copy_data+0x10>
      d2:	05 90       	lpm	r0, Z+
      d4:	0d 92       	st	X+, r0
      d6:	a2 37       	cpi	r26, 0x72	; 114
      d8:	b1 07       	cpc	r27, r17
      da:	d9 f7       	brne	.-10     	; 0xd2 <__do_copy_data+0xc>

000000dc <__do_clear_bss>:
      dc:	10 e0       	ldi	r17, 0x00	; 0
      de:	a2 e7       	ldi	r26, 0x72	; 114
      e0:	b0 e0       	ldi	r27, 0x00	; 0
      e2:	01 c0       	rjmp	.+2      	; 0xe6 <.do_clear_bss_start>

000000e4 <.do_clear_bss_loop>:
      e4:	1d 92       	st	X+, r1

000000e6 <.do_clear_bss_start>:
      e6:	af 3a       	cpi	r26, 0xAF	; 175
      e8:	b1 07       	cpc	r27, r17
      ea:	e1 f7       	brne	.-8      	; 0xe4 <.do_clear_bss_loop>
      ec:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <main>
      f0:	0c 94 0d 11 	jmp	0x221a	; 0x221a <_exit>

000000f4 <__bad_interrupt>:
      f4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f8 <ADC_INTIATE>:

#define LEVEL_NUM    (1024)


void ADC_INTIATE(ANALOG_DATATYPE ADC_signal)
{
      f8:	0f 93       	push	r16
      fa:	1f 93       	push	r17
      fc:	cf 93       	push	r28
      fe:	df 93       	push	r29
     100:	00 d0       	rcall	.+0      	; 0x102 <ADC_INTIATE+0xa>
     102:	00 d0       	rcall	.+0      	; 0x104 <ADC_INTIATE+0xc>
     104:	00 d0       	rcall	.+0      	; 0x106 <ADC_INTIATE+0xe>
     106:	cd b7       	in	r28, 0x3d	; 61
     108:	de b7       	in	r29, 0x3e	; 62
     10a:	14 2f       	mov	r17, r20
     10c:	49 83       	std	Y+1, r20	; 0x01
     10e:	5a 83       	std	Y+2, r21	; 0x02
     110:	6b 83       	std	Y+3, r22	; 0x03
     112:	7c 83       	std	Y+4, r23	; 0x04
     114:	8d 83       	std	Y+5, r24	; 0x05
     116:	9e 83       	std	Y+6, r25	; 0x06
	char ADCSRA_temp = 0x00;
	char ADCMUX_temp = 0x00;
	
	/* Set The Clock input Frequency */
	switch(ADC_signal.ADC_CLK_In)
     118:	72 30       	cpi	r23, 0x02	; 2
     11a:	99 f0       	breq	.+38     	; 0x142 <ADC_INTIATE+0x4a>
     11c:	73 30       	cpi	r23, 0x03	; 3
     11e:	28 f4       	brcc	.+10     	; 0x12a <ADC_INTIATE+0x32>
     120:	77 23       	and	r23, r23
     122:	99 f0       	breq	.+38     	; 0x14a <ADC_INTIATE+0x52>
     124:	71 30       	cpi	r23, 0x01	; 1
     126:	39 f4       	brne	.+14     	; 0x136 <ADC_INTIATE+0x3e>
     128:	0e c0       	rjmp	.+28     	; 0x146 <ADC_INTIATE+0x4e>
     12a:	74 30       	cpi	r23, 0x04	; 4
     12c:	31 f0       	breq	.+12     	; 0x13a <ADC_INTIATE+0x42>
     12e:	74 30       	cpi	r23, 0x04	; 4
     130:	30 f0       	brcs	.+12     	; 0x13e <ADC_INTIATE+0x46>
     132:	75 30       	cpi	r23, 0x05	; 5
     134:	61 f0       	breq	.+24     	; 0x14e <ADC_INTIATE+0x56>
#define LEVEL_NUM    (1024)


void ADC_INTIATE(ANALOG_DATATYPE ADC_signal)
{
	char ADCSRA_temp = 0x00;
     136:	00 e0       	ldi	r16, 0x00	; 0
     138:	0b c0       	rjmp	.+22     	; 0x150 <ADC_INTIATE+0x58>
		case FCPU_DIV4:
		     SET_Bit(ADCSRA_temp,ADPS1);
		break;
		case FCPU_DIV8:
		     SET_Bit(ADCSRA_temp,ADPS0);
			 SET_Bit(ADCSRA_temp,ADPS1);
     13a:	03 e0       	ldi	r16, 0x03	; 3
		break;
     13c:	09 c0       	rjmp	.+18     	; 0x150 <ADC_INTIATE+0x58>
		case FCPU_DIV16:
			 SET_Bit(ADCSRA_temp,ADPS2);
     13e:	04 e0       	ldi	r16, 0x04	; 4
		break;
     140:	07 c0       	rjmp	.+14     	; 0x150 <ADC_INTIATE+0x58>
		case FCPU_DIV32:
		     SET_Bit(ADCSRA_temp,ADPS0);
		     SET_Bit(ADCSRA_temp,ADPS2);
     142:	05 e0       	ldi	r16, 0x05	; 5
		break;
     144:	05 c0       	rjmp	.+10     	; 0x150 <ADC_INTIATE+0x58>
		case FCPU_DIV64:
		     SET_Bit(ADCSRA_temp,ADPS1);
		     SET_Bit(ADCSRA_temp,ADPS2);
     146:	06 e0       	ldi	r16, 0x06	; 6
		break;
     148:	03 c0       	rjmp	.+6      	; 0x150 <ADC_INTIATE+0x58>
		case FCPU_DIV128:
		     SET_Bit(ADCSRA_temp,ADPS0);
			 SET_Bit(ADCSRA_temp,ADPS1);
		     SET_Bit(ADCSRA_temp,ADPS2);
     14a:	07 e0       	ldi	r16, 0x07	; 7
		break;
     14c:	01 c0       	rjmp	.+2      	; 0x150 <ADC_INTIATE+0x58>
	{
		case FCPU_DIV2:
		     /* it the default case when all the bit became 0*/
		break;
		case FCPU_DIV4:
		     SET_Bit(ADCSRA_temp,ADPS1);
     14e:	02 e0       	ldi	r16, 0x02	; 2
		     SET_Bit(ADCSRA_temp,ADPS2);
		break;
	}
	
	/* Set The Configuration of The Pin As An Input Pin */
	DIO_pinConfiguration(GPIOA, ADC_signal.ADC_PIN, InputFloat);
     150:	89 e3       	ldi	r24, 0x39	; 57
     152:	90 e0       	ldi	r25, 0x00	; 0
     154:	61 2f       	mov	r22, r17
     156:	40 e0       	ldi	r20, 0x00	; 0
     158:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	
	/* Set the pin of the Multiplexer to make it sample */
	switch(ADC_signal.ADC_PIN)
     15c:	14 30       	cpi	r17, 0x04	; 4
     15e:	a9 f0       	breq	.+42     	; 0x18a <ADC_INTIATE+0x92>
     160:	15 30       	cpi	r17, 0x05	; 5
     162:	38 f4       	brcc	.+14     	; 0x172 <ADC_INTIATE+0x7a>
     164:	12 30       	cpi	r17, 0x02	; 2
     166:	69 f0       	breq	.+26     	; 0x182 <ADC_INTIATE+0x8a>
     168:	13 30       	cpi	r17, 0x03	; 3
     16a:	68 f4       	brcc	.+26     	; 0x186 <ADC_INTIATE+0x8e>
     16c:	11 30       	cpi	r17, 0x01	; 1
     16e:	39 f4       	brne	.+14     	; 0x17e <ADC_INTIATE+0x86>
     170:	14 c0       	rjmp	.+40     	; 0x19a <ADC_INTIATE+0xa2>
     172:	16 30       	cpi	r17, 0x06	; 6
     174:	71 f0       	breq	.+28     	; 0x192 <ADC_INTIATE+0x9a>
     176:	16 30       	cpi	r17, 0x06	; 6
     178:	50 f0       	brcs	.+20     	; 0x18e <ADC_INTIATE+0x96>
     17a:	17 30       	cpi	r17, 0x07	; 7
     17c:	61 f0       	breq	.+24     	; 0x196 <ADC_INTIATE+0x9e>


void ADC_INTIATE(ANALOG_DATATYPE ADC_signal)
{
	char ADCSRA_temp = 0x00;
	char ADCMUX_temp = 0x00;
     17e:	80 e0       	ldi	r24, 0x00	; 0
     180:	0d c0       	rjmp	.+26     	; 0x19c <ADC_INTIATE+0xa4>
		break;
		case PIN1:
		     SET_Bit(ADCMUX_temp, MUX0);
		break;
		case PIN2:
		     SET_Bit(ADCMUX_temp, MUX1);
     182:	82 e0       	ldi	r24, 0x02	; 2
		break;
     184:	0b c0       	rjmp	.+22     	; 0x19c <ADC_INTIATE+0xa4>
		case PIN3:
		     SET_Bit(ADCMUX_temp, MUX0);
			 SET_Bit(ADCMUX_temp, MUX1);
     186:	83 e0       	ldi	r24, 0x03	; 3
		break;
     188:	09 c0       	rjmp	.+18     	; 0x19c <ADC_INTIATE+0xa4>
		case PIN4:
		     SET_Bit(ADCMUX_temp,MUX2);
     18a:	84 e0       	ldi	r24, 0x04	; 4
		break;
     18c:	07 c0       	rjmp	.+14     	; 0x19c <ADC_INTIATE+0xa4>
		case PIN5:
		     SET_Bit(ADCMUX_temp, MUX0);
			 SET_Bit(ADCMUX_temp,MUX2);
     18e:	85 e0       	ldi	r24, 0x05	; 5
		break;
     190:	05 c0       	rjmp	.+10     	; 0x19c <ADC_INTIATE+0xa4>
		case PIN6:
		     SET_Bit(ADCMUX_temp, MUX1);
			 SET_Bit(ADCMUX_temp,MUX2);
     192:	86 e0       	ldi	r24, 0x06	; 6
		break;
     194:	03 c0       	rjmp	.+6      	; 0x19c <ADC_INTIATE+0xa4>
		case PIN7:
		     SET_Bit(ADCMUX_temp, MUX0);
			 SET_Bit(ADCMUX_temp, MUX1);
			 SET_Bit(ADCMUX_temp,MUX2);
     196:	87 e0       	ldi	r24, 0x07	; 7
		break;
     198:	01 c0       	rjmp	.+2      	; 0x19c <ADC_INTIATE+0xa4>
	{
		case PIN0:
		     /* it The Default State */
		break;
		case PIN1:
		     SET_Bit(ADCMUX_temp, MUX0);
     19a:	81 e0       	ldi	r24, 0x01	; 1
			 SET_Bit(ADCMUX_temp,MUX2);
		break;
	}
	
	/* Interrupt State */
	switch(ADC_signal.INT)
     19c:	9b 81       	ldd	r25, Y+3	; 0x03
     19e:	91 30       	cpi	r25, 0x01	; 1
     1a0:	09 f4       	brne	.+2      	; 0x1a4 <ADC_INTIATE+0xac>
	{
	   case ADC_INT_DISABLE:
	        /* It The Default State */
	   break;
	   case ADC_INT_ENABLE:
	        SET_Bit(ADCSRA_temp, ADIE);
     1a2:	08 60       	ori	r16, 0x08	; 8
	   break;
	}
	
	/* Set The Voltage Reference Of The ADC */
	switch(ADC_signal.REF_Voltage)
     1a4:	9a 81       	ldd	r25, Y+2	; 0x02
     1a6:	99 23       	and	r25, r25
     1a8:	19 f0       	breq	.+6      	; 0x1b0 <ADC_INTIATE+0xb8>
     1aa:	92 30       	cpi	r25, 0x02	; 2
     1ac:	21 f4       	brne	.+8      	; 0x1b6 <ADC_INTIATE+0xbe>
     1ae:	02 c0       	rjmp	.+4      	; 0x1b4 <ADC_INTIATE+0xbc>
		case AREF:
		     /* it The Default State The 2 Bits Is 0 */
		break;
		case AVCC:
		/* Note at This Case the AREF Connect With a capacitor to Ground */
		     SET_Bit(ADCMUX_temp,REF0);
     1b0:	80 64       	ori	r24, 0x40	; 64
		break;
     1b2:	01 c0       	rjmp	.+2      	; 0x1b6 <ADC_INTIATE+0xbe>
		case INTERNV:
		/* The Value Of The internal Voltage is 2.56 V */
		    SET_Bit(ADCMUX_temp,REF0);
			SET_Bit(ADCMUX_temp,REF1);
     1b4:	80 6c       	ori	r24, 0xC0	; 192
		break;
	}
	
	/* The Data Sort In The ADCL , ADCH Register State */
	switch(ADC_signal.ADC_SORT)
     1b6:	9e 81       	ldd	r25, Y+6	; 0x06
     1b8:	91 30       	cpi	r25, 0x01	; 1
     1ba:	09 f4       	brne	.+2      	; 0x1be <ADC_INTIATE+0xc6>
	{
		case ADJUST_RIGHT:
		/* it The Default State The 2 Bits Is 0 */
		break;
		case ADJUST_LEFT:
		     SET_Bit(ADCMUX_temp,ADLAR);
     1bc:	80 62       	ori	r24, 0x20	; 32
		case TIMERCO0_CAPEVENT:
		break;
		/* it Will Handle When it Needed */
	}
	
	ADCMUX = ADCMUX_temp;
     1be:	87 b9       	out	0x07, r24	; 7
	ADCSRA = ADCSRA_temp;
     1c0:	06 b9       	out	0x06, r16	; 6
	/* Enable The ADC Bit */
	SET_Bit(ADCSRA, ADEN);
     1c2:	37 9a       	sbi	0x06, 7	; 6
}
     1c4:	26 96       	adiw	r28, 0x06	; 6
     1c6:	0f b6       	in	r0, 0x3f	; 63
     1c8:	f8 94       	cli
     1ca:	de bf       	out	0x3e, r29	; 62
     1cc:	0f be       	out	0x3f, r0	; 63
     1ce:	cd bf       	out	0x3d, r28	; 61
     1d0:	df 91       	pop	r29
     1d2:	cf 91       	pop	r28
     1d4:	1f 91       	pop	r17
     1d6:	0f 91       	pop	r16
     1d8:	08 95       	ret

000001da <analogRead>:




int analogRead(ANALOG_DATATYPE signal)
{
     1da:	cf 93       	push	r28
     1dc:	df 93       	push	r29
     1de:	00 d0       	rcall	.+0      	; 0x1e0 <analogRead+0x6>
     1e0:	00 d0       	rcall	.+0      	; 0x1e2 <analogRead+0x8>
     1e2:	00 d0       	rcall	.+0      	; 0x1e4 <analogRead+0xa>
     1e4:	cd b7       	in	r28, 0x3d	; 61
     1e6:	de b7       	in	r29, 0x3e	; 62
     1e8:	49 83       	std	Y+1, r20	; 0x01
     1ea:	5a 83       	std	Y+2, r21	; 0x02
     1ec:	6b 83       	std	Y+3, r22	; 0x03
     1ee:	7c 83       	std	Y+4, r23	; 0x04
     1f0:	8d 83       	std	Y+5, r24	; 0x05
     1f2:	9e 83       	std	Y+6, r25	; 0x06
	unsigned int DataRead = 0x00;
	/*  as A default We in the Single Conversion Mode */
	/* Set Bit ADSC to Start The Conversion */
	SET_Bit(ADCSRA, ADSC); 
     1f4:	36 9a       	sbi	0x06, 6	; 6
	while (READ_Bit(ADCSRA,ADSC) == 0);
     1f6:	36 9b       	sbis	0x06, 6	; 6
     1f8:	fe cf       	rjmp	.-4      	; 0x1f6 <analogRead+0x1c>
	/* it Must in THe Right Adjust Mode Read The ADCL register Before The ADCH */
	DataRead = ADCL; 
     1fa:	84 b1       	in	r24, 0x04	; 4
     1fc:	90 e0       	ldi	r25, 0x00	; 0
	DataRead |= (ADCH << 8);
     1fe:	45 b1       	in	r20, 0x05	; 5
     200:	34 2f       	mov	r19, r20
     202:	20 e0       	ldi	r18, 0x00	; 0
     204:	82 2b       	or	r24, r18
     206:	93 2b       	or	r25, r19
	
	return DataRead;
	
     208:	26 96       	adiw	r28, 0x06	; 6
     20a:	0f b6       	in	r0, 0x3f	; 63
     20c:	f8 94       	cli
     20e:	de bf       	out	0x3e, r29	; 62
     210:	0f be       	out	0x3f, r0	; 63
     212:	cd bf       	out	0x3d, r28	; 61
     214:	df 91       	pop	r29
     216:	cf 91       	pop	r28
     218:	08 95       	ret

0000021a <DIO_pinConfiguration>:




void DIO_pinConfiguration(GPIO * pinC, pinNumber pin_num, pinMode pin_M)
{
     21a:	fc 01       	movw	r30, r24
	switch (pin_M)
     21c:	41 30       	cpi	r20, 0x01	; 1
     21e:	29 f0       	breq	.+10     	; 0x22a <DIO_pinConfiguration+0x10>
     220:	41 30       	cpi	r20, 0x01	; 1
     222:	a8 f0       	brcs	.+42     	; 0x24e <DIO_pinConfiguration+0x34>
     224:	42 30       	cpi	r20, 0x02	; 2
     226:	b1 f5       	brne	.+108    	; 0x294 <DIO_pinConfiguration+0x7a>
     228:	24 c0       	rjmp	.+72     	; 0x272 <DIO_pinConfiguration+0x58>
	{
		case InputPullup:
		/* In This Case We Make The Pin Input By Get Low in The DDR And Make It Default State (idle) HIgh By Set The Port */
		RESET_Bit(pinC -> DDR, pin_num);
     22a:	21 81       	ldd	r18, Z+1	; 0x01
     22c:	81 e0       	ldi	r24, 0x01	; 1
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	ac 01       	movw	r20, r24
     232:	02 c0       	rjmp	.+4      	; 0x238 <DIO_pinConfiguration+0x1e>
     234:	44 0f       	add	r20, r20
     236:	55 1f       	adc	r21, r21
     238:	6a 95       	dec	r22
     23a:	e2 f7       	brpl	.-8      	; 0x234 <DIO_pinConfiguration+0x1a>
     23c:	ba 01       	movw	r22, r20
     23e:	84 2f       	mov	r24, r20
     240:	80 95       	com	r24
     242:	82 23       	and	r24, r18
     244:	81 83       	std	Z+1, r24	; 0x01
		SET_Bit(pinC -> PORT, pin_num);
     246:	82 81       	ldd	r24, Z+2	; 0x02
     248:	68 2b       	or	r22, r24
     24a:	62 83       	std	Z+2, r22	; 0x02
		break;
     24c:	08 95       	ret
		case InputFloat:
		/* In This Case We Make The Pin Input By Get Low in The DDR And Make It Default State (idle) LOW By RESET The Port And Make A Pull down Resistance  */
		RESET_Bit(pinC -> DDR,pin_num);
     24e:	21 81       	ldd	r18, Z+1	; 0x01
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	ac 01       	movw	r20, r24
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_pinConfiguration+0x42>
     258:	44 0f       	add	r20, r20
     25a:	55 1f       	adc	r21, r21
     25c:	6a 95       	dec	r22
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_pinConfiguration+0x3e>
     260:	ba 01       	movw	r22, r20
     262:	60 95       	com	r22
     264:	86 2f       	mov	r24, r22
     266:	82 23       	and	r24, r18
     268:	81 83       	std	Z+1, r24	; 0x01
		RESET_Bit(pinC -> PORT,pin_num);
     26a:	82 81       	ldd	r24, Z+2	; 0x02
     26c:	68 23       	and	r22, r24
     26e:	62 83       	std	Z+2, r22	; 0x02
		break;
     270:	08 95       	ret
		case Output:
		/* In This Case We Make The Pin Output By  SET The DDR And Make It Default State (idle) LOW By Set The Port TO Make It reverse Connection Sink Source to Avoid Error Value When The Number Of The Output Increace */
		SET_Bit(pinC -> DDR, pin_num);
     272:	21 81       	ldd	r18, Z+1	; 0x01
     274:	81 e0       	ldi	r24, 0x01	; 1
     276:	90 e0       	ldi	r25, 0x00	; 0
     278:	ac 01       	movw	r20, r24
     27a:	02 c0       	rjmp	.+4      	; 0x280 <DIO_pinConfiguration+0x66>
     27c:	44 0f       	add	r20, r20
     27e:	55 1f       	adc	r21, r21
     280:	6a 95       	dec	r22
     282:	e2 f7       	brpl	.-8      	; 0x27c <DIO_pinConfiguration+0x62>
     284:	ba 01       	movw	r22, r20
     286:	82 2f       	mov	r24, r18
     288:	84 2b       	or	r24, r20
     28a:	81 83       	std	Z+1, r24	; 0x01
		RESET_Bit(pinC -> PORT,pin_num);
     28c:	82 81       	ldd	r24, Z+2	; 0x02
     28e:	60 95       	com	r22
     290:	68 23       	and	r22, r24
     292:	62 83       	std	Z+2, r22	; 0x02
     294:	08 95       	ret

00000296 <DIO_pinWrite>:




 void DIO_pinWrite(GPIO * pinC, pinNumber pin_num, DigitalValue state)
 {
     296:	fc 01       	movw	r30, r24
	 switch(state)
     298:	44 23       	and	r20, r20
     29a:	79 f0       	breq	.+30     	; 0x2ba <DIO_pinWrite+0x24>
     29c:	41 30       	cpi	r20, 0x01	; 1
     29e:	d1 f4       	brne	.+52     	; 0x2d4 <DIO_pinWrite+0x3e>
	 {
		 case HIGH:
		 /* The Pin Get Output High State */
		 SET_Bit(pinC -> PORT, pin_num);
     2a0:	22 81       	ldd	r18, Z+2	; 0x02
     2a2:	81 e0       	ldi	r24, 0x01	; 1
     2a4:	90 e0       	ldi	r25, 0x00	; 0
     2a6:	ac 01       	movw	r20, r24
     2a8:	02 c0       	rjmp	.+4      	; 0x2ae <DIO_pinWrite+0x18>
     2aa:	44 0f       	add	r20, r20
     2ac:	55 1f       	adc	r21, r21
     2ae:	6a 95       	dec	r22
     2b0:	e2 f7       	brpl	.-8      	; 0x2aa <DIO_pinWrite+0x14>
     2b2:	ba 01       	movw	r22, r20
     2b4:	62 2b       	or	r22, r18
     2b6:	62 83       	std	Z+2, r22	; 0x02
		 break;
     2b8:	08 95       	ret
		 case LOW:
		 /* The Pin Get Output Low State */
		 RESET_Bit(pinC -> PORT, pin_num);
     2ba:	22 81       	ldd	r18, Z+2	; 0x02
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	ac 01       	movw	r20, r24
     2c2:	02 c0       	rjmp	.+4      	; 0x2c8 <DIO_pinWrite+0x32>
     2c4:	44 0f       	add	r20, r20
     2c6:	55 1f       	adc	r21, r21
     2c8:	6a 95       	dec	r22
     2ca:	e2 f7       	brpl	.-8      	; 0x2c4 <DIO_pinWrite+0x2e>
     2cc:	ba 01       	movw	r22, r20
     2ce:	60 95       	com	r22
     2d0:	62 23       	and	r22, r18
     2d2:	62 83       	std	Z+2, r22	; 0x02
     2d4:	08 95       	ret

000002d6 <DIO_pinRead>:
 }
 
 
 
 DigitalValue DIO_pinRead(GPIO * pinC, pinNumber pin_num)
 {
     2d6:	fc 01       	movw	r30, r24
	 /* This Function Return The Current State Of The Pin by Use The READ_Bit Definition In The Macro Header */
	 return (READ_Bit(pinC -> PIN, pin_num));
     2d8:	20 81       	ld	r18, Z
     2da:	41 e0       	ldi	r20, 0x01	; 1
     2dc:	50 e0       	ldi	r21, 0x00	; 0
     2de:	ca 01       	movw	r24, r20
     2e0:	06 2e       	mov	r0, r22
     2e2:	02 c0       	rjmp	.+4      	; 0x2e8 <DIO_pinRead+0x12>
     2e4:	88 0f       	add	r24, r24
     2e6:	99 1f       	adc	r25, r25
     2e8:	0a 94       	dec	r0
     2ea:	e2 f7       	brpl	.-8      	; 0x2e4 <DIO_pinRead+0xe>
     2ec:	30 e0       	ldi	r19, 0x00	; 0
     2ee:	82 23       	and	r24, r18
     2f0:	93 23       	and	r25, r19
     2f2:	02 c0       	rjmp	.+4      	; 0x2f8 <DIO_pinRead+0x22>
     2f4:	95 95       	asr	r25
     2f6:	87 95       	ror	r24
     2f8:	6a 95       	dec	r22
     2fa:	e2 f7       	brpl	.-8      	; 0x2f4 <DIO_pinRead+0x1e>
 }
     2fc:	08 95       	ret

000002fe <DIO_portConfiguration>:
	  
	  if (portValue <= MAX_uint8_VALUE && portValue >= MIN_uint8_VALUE)
	  {
		  /* The Value On The 8 bit DDR To Define Each Pin From The 8 Pins Of The Port As input Or Output */
		  /* equal the port to the 0xFF to get the output */
		  portC->DDR = portValue;
     2fe:	fc 01       	movw	r30, r24
     300:	61 83       	std	Z+1, r22	; 0x01
	  }
	  else
	  {
		  //DIO_ErrorIndication()
	  }
  } 
     302:	08 95       	ret

00000304 <DIO_portWrite>:
 {
	  /* We Must Check That THe Value Of The configuration Of The Port Does Not exceed The 8 bit (0 <-> 255) */
	 if (portValue <= MAX_uint8_VALUE && portValue >= MIN_uint8_VALUE)
	 {
		 /* Get Out The 8bit Value On The * Pins Of The Port */
		 portC->PORT = portValue;
     304:	fc 01       	movw	r30, r24
     306:	62 83       	std	Z+2, r22	; 0x02
	 }
	 else if (portValue < MIN_uint8_VALUE)
	 {
		 portC->PORT = 0x00;
	 }
 }
     308:	08 95       	ret

0000030a <DIO_portRead>:
 
 
 uint8 DIO_portRead(GPIO * portC)
 {
	 /* we And THe Value Of The Port With 1111 1111 And return the result To Get Port State */
	 return (READ_Bit(portC->PORT,ANDINGV_to_readPORT));
     30a:	fc 01       	movw	r30, r24
     30c:	82 81       	ldd	r24, Z+2	; 0x02
	 
 }
     30e:	80 e0       	ldi	r24, 0x00	; 0
     310:	08 95       	ret

00000312 <EEPROM_Write>:
 #include "Macro.h"

  void EEPROM_Write (unsigned short Address, unsigned char Data)
  {
	   /* Boole until make sure the  write operation is finish */
	  while (READ_Bit(EECR, EEWE)) {};
     312:	e1 99       	sbic	0x1c, 1	; 28
     314:	fe cf       	rjmp	.-4      	; 0x312 <EEPROM_Write>
	 /* flash Program Complete */
	 while(READ_Bit(SPMCR,SPMIE));
     316:	07 b6       	in	r0, 0x37	; 55
     318:	00 fc       	sbrc	r0, 0
     31a:	fd cf       	rjmp	.-6      	; 0x316 <EEPROM_Write+0x4>
	  /* Set the Address in the EEEPROM address Register */
	  EEAR = Address;
     31c:	9f bb       	out	0x1f, r25	; 31
     31e:	8e bb       	out	0x1e, r24	; 30
	  /* Set the Data in the EEPROM data Register */
	  EEDR = Data;
     320:	6d bb       	out	0x1d, r22	; 29
	  /* Set the EEPROM Master Write Enable (( Note it only will be set for 4 clock cycle and will reset automatically by HW ))*/
	  EECR |= (1 << EEMWE);
     322:	e2 9a       	sbi	0x1c, 2	; 28
	  /* start the Write Operation */
	  EECR |= (1 << EEWE);
     324:	e1 9a       	sbi	0x1c, 1	; 28
	 
  }
     326:	08 95       	ret

00000328 <EEPEOM_Read>:
  
  
  unsigned char EEPEOM_Read (unsigned short Address)
  {
	  /* Boole until make sure the last write operation is finish */
       while (READ_Bit(EECR, EEWE)) {};
     328:	e1 99       	sbic	0x1c, 1	; 28
     32a:	fe cf       	rjmp	.-4      	; 0x328 <EEPEOM_Read>
	  /* Set the Address in the EEEPROM address Register */
	  EEAR = Address;
     32c:	9f bb       	out	0x1f, r25	; 31
     32e:	8e bb       	out	0x1e, r24	; 30
	  
	  /* start the Read Operation */
	  EECR |= (1 << EERE);
     330:	e0 9a       	sbi	0x1c, 0	; 28
	  /* return the data store in the EEPROM data Register */
	  return EEDR;
     332:	8d b3       	in	r24, 0x1d	; 29
     334:	08 95       	ret

00000336 <__vector_1>:
  
  
  

  ISR (INT0_vect,ISR_NESTED_ENABLE)
     {
     336:	1f 92       	push	r1
     338:	0f 92       	push	r0
     33a:	0f b6       	in	r0, 0x3f	; 63
     33c:	0f 92       	push	r0
     33e:	11 24       	eor	r1, r1
     340:	2f 93       	push	r18
     342:	3f 93       	push	r19
     344:	4f 93       	push	r20
     346:	5f 93       	push	r21
     348:	6f 93       	push	r22
     34a:	7f 93       	push	r23
     34c:	8f 93       	push	r24
     34e:	9f 93       	push	r25
     350:	af 93       	push	r26
     352:	bf 93       	push	r27
     354:	ef 93       	push	r30
     356:	ff 93       	push	r31
		 if (EXTINT0_ISR != NULL)
     358:	e0 91 76 00 	lds	r30, 0x0076
     35c:	f0 91 77 00 	lds	r31, 0x0077
     360:	30 97       	sbiw	r30, 0x00	; 0
     362:	09 f0       	breq	.+2      	; 0x366 <__vector_1+0x30>
		 {
			 EXTINT0_ISR();
     364:	09 95       	icall
		 }
	 }
     366:	ff 91       	pop	r31
     368:	ef 91       	pop	r30
     36a:	bf 91       	pop	r27
     36c:	af 91       	pop	r26
     36e:	9f 91       	pop	r25
     370:	8f 91       	pop	r24
     372:	7f 91       	pop	r23
     374:	6f 91       	pop	r22
     376:	5f 91       	pop	r21
     378:	4f 91       	pop	r20
     37a:	3f 91       	pop	r19
     37c:	2f 91       	pop	r18
     37e:	0f 90       	pop	r0
     380:	0f be       	out	0x3f, r0	; 63
     382:	0f 90       	pop	r0
     384:	1f 90       	pop	r1
     386:	18 95       	reti

00000388 <__vector_2>:
	 
	ISR (INT1_vect,ISR_NESTED_ENABLE)
	{
     388:	1f 92       	push	r1
     38a:	0f 92       	push	r0
     38c:	0f b6       	in	r0, 0x3f	; 63
     38e:	0f 92       	push	r0
     390:	11 24       	eor	r1, r1
     392:	2f 93       	push	r18
     394:	3f 93       	push	r19
     396:	4f 93       	push	r20
     398:	5f 93       	push	r21
     39a:	6f 93       	push	r22
     39c:	7f 93       	push	r23
     39e:	8f 93       	push	r24
     3a0:	9f 93       	push	r25
     3a2:	af 93       	push	r26
     3a4:	bf 93       	push	r27
     3a6:	ef 93       	push	r30
     3a8:	ff 93       	push	r31
		if (EXTINT1_ISR != NULL)
     3aa:	e0 91 74 00 	lds	r30, 0x0074
     3ae:	f0 91 75 00 	lds	r31, 0x0075
     3b2:	30 97       	sbiw	r30, 0x00	; 0
     3b4:	09 f0       	breq	.+2      	; 0x3b8 <__vector_2+0x30>
		{
			EXTINT1_ISR();
     3b6:	09 95       	icall
		}
	}
     3b8:	ff 91       	pop	r31
     3ba:	ef 91       	pop	r30
     3bc:	bf 91       	pop	r27
     3be:	af 91       	pop	r26
     3c0:	9f 91       	pop	r25
     3c2:	8f 91       	pop	r24
     3c4:	7f 91       	pop	r23
     3c6:	6f 91       	pop	r22
     3c8:	5f 91       	pop	r21
     3ca:	4f 91       	pop	r20
     3cc:	3f 91       	pop	r19
     3ce:	2f 91       	pop	r18
     3d0:	0f 90       	pop	r0
     3d2:	0f be       	out	0x3f, r0	; 63
     3d4:	0f 90       	pop	r0
     3d6:	1f 90       	pop	r1
     3d8:	18 95       	reti

000003da <EXTINT_InterruptInit>:



	void EXTINT_InterruptInit(EXInterrupt_Source source,ExInterrupt_Modes Mode)
	{
		switch (source)
     3da:	81 30       	cpi	r24, 0x01	; 1
     3dc:	71 f1       	breq	.+92     	; 0x43a <EXTINT_InterruptInit+0x60>
     3de:	81 30       	cpi	r24, 0x01	; 1
     3e0:	20 f0       	brcs	.+8      	; 0x3ea <EXTINT_InterruptInit+0x10>
     3e2:	82 30       	cpi	r24, 0x02	; 2
     3e4:	09 f0       	breq	.+2      	; 0x3e8 <EXTINT_InterruptInit+0xe>
     3e6:	60 c0       	rjmp	.+192    	; 0x4a8 <EXTINT_InterruptInit+0xce>
     3e8:	50 c0       	rjmp	.+160    	; 0x48a <EXTINT_InterruptInit+0xb0>
		{
			case EXINT_INT0 :
				 switch (Mode)
     3ea:	61 30       	cpi	r22, 0x01	; 1
     3ec:	71 f0       	breq	.+28     	; 0x40a <EXTINT_InterruptInit+0x30>
     3ee:	61 30       	cpi	r22, 0x01	; 1
     3f0:	28 f0       	brcs	.+10     	; 0x3fc <EXTINT_InterruptInit+0x22>
     3f2:	62 30       	cpi	r22, 0x02	; 2
     3f4:	89 f0       	breq	.+34     	; 0x418 <EXTINT_InterruptInit+0x3e>
     3f6:	63 30       	cpi	r22, 0x03	; 3
     3f8:	e1 f4       	brne	.+56     	; 0x432 <EXTINT_InterruptInit+0x58>
     3fa:	15 c0       	rjmp	.+42     	; 0x426 <EXTINT_InterruptInit+0x4c>
				 {
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC00);
     3fc:	85 b7       	in	r24, 0x35	; 53
     3fe:	8e 7f       	andi	r24, 0xFE	; 254
     400:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC01);
     402:	85 b7       	in	r24, 0x35	; 53
     404:	8d 7f       	andi	r24, 0xFD	; 253
     406:	85 bf       	out	0x35, r24	; 53
						  break;
     408:	14 c0       	rjmp	.+40     	; 0x432 <EXTINT_InterruptInit+0x58>
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC00);
     40a:	85 b7       	in	r24, 0x35	; 53
     40c:	81 60       	ori	r24, 0x01	; 1
     40e:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC01);
     410:	85 b7       	in	r24, 0x35	; 53
     412:	8d 7f       	andi	r24, 0xFD	; 253
     414:	85 bf       	out	0x35, r24	; 53
						  break;
     416:	0d c0       	rjmp	.+26     	; 0x432 <EXTINT_InterruptInit+0x58>
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC00);
     418:	85 b7       	in	r24, 0x35	; 53
     41a:	8e 7f       	andi	r24, 0xFE	; 254
     41c:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC01);
     41e:	85 b7       	in	r24, 0x35	; 53
     420:	82 60       	ori	r24, 0x02	; 2
     422:	85 bf       	out	0x35, r24	; 53
						  break;
     424:	06 c0       	rjmp	.+12     	; 0x432 <EXTINT_InterruptInit+0x58>
					 case EXINT_RisingEdge :
						  SET_Bit(MCUCR,ISC00);
     426:	85 b7       	in	r24, 0x35	; 53
     428:	81 60       	ori	r24, 0x01	; 1
     42a:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC01);
     42c:	85 b7       	in	r24, 0x35	; 53
     42e:	82 60       	ori	r24, 0x02	; 2
     430:	85 bf       	out	0x35, r24	; 53
						  break;
				  }
				/* Enable THe InT 0 */
				SET_Bit(GICR,INT0);	
     432:	8b b7       	in	r24, 0x3b	; 59
     434:	80 64       	ori	r24, 0x40	; 64
     436:	8b bf       	out	0x3b, r24	; 59
				break;
     438:	08 95       	ret
		  case EXINT_INT1 :
				 switch (Mode)
     43a:	61 30       	cpi	r22, 0x01	; 1
     43c:	71 f0       	breq	.+28     	; 0x45a <EXTINT_InterruptInit+0x80>
     43e:	61 30       	cpi	r22, 0x01	; 1
     440:	28 f0       	brcs	.+10     	; 0x44c <EXTINT_InterruptInit+0x72>
     442:	62 30       	cpi	r22, 0x02	; 2
     444:	89 f0       	breq	.+34     	; 0x468 <EXTINT_InterruptInit+0x8e>
     446:	63 30       	cpi	r22, 0x03	; 3
     448:	e1 f4       	brne	.+56     	; 0x482 <EXTINT_InterruptInit+0xa8>
     44a:	15 c0       	rjmp	.+42     	; 0x476 <EXTINT_InterruptInit+0x9c>
				 {
					 case EXINT_LowLevel :
						  RESET_Bit(MCUCR,ISC10);
     44c:	85 b7       	in	r24, 0x35	; 53
     44e:	8b 7f       	andi	r24, 0xFB	; 251
     450:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC11);
     452:	85 b7       	in	r24, 0x35	; 53
     454:	87 7f       	andi	r24, 0xF7	; 247
     456:	85 bf       	out	0x35, r24	; 53
						  break;
     458:	14 c0       	rjmp	.+40     	; 0x482 <EXTINT_InterruptInit+0xa8>
					 case EXINT_Toggle :
						  SET_Bit(MCUCR,ISC11);
     45a:	85 b7       	in	r24, 0x35	; 53
     45c:	88 60       	ori	r24, 0x08	; 8
     45e:	85 bf       	out	0x35, r24	; 53
						  RESET_Bit(MCUCR,ISC10);
     460:	85 b7       	in	r24, 0x35	; 53
     462:	8b 7f       	andi	r24, 0xFB	; 251
     464:	85 bf       	out	0x35, r24	; 53
						  break;
     466:	0d c0       	rjmp	.+26     	; 0x482 <EXTINT_InterruptInit+0xa8>
					 case EXINT_FallingEdge :
						  RESET_Bit(MCUCR,ISC11);
     468:	85 b7       	in	r24, 0x35	; 53
     46a:	87 7f       	andi	r24, 0xF7	; 247
     46c:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC10);
     46e:	85 b7       	in	r24, 0x35	; 53
     470:	84 60       	ori	r24, 0x04	; 4
     472:	85 bf       	out	0x35, r24	; 53
						  break;
     474:	06 c0       	rjmp	.+12     	; 0x482 <EXTINT_InterruptInit+0xa8>
					 case EXINT_RisingEdge :
						  SET_Bit(MCUCR,ISC11);
     476:	85 b7       	in	r24, 0x35	; 53
     478:	88 60       	ori	r24, 0x08	; 8
     47a:	85 bf       	out	0x35, r24	; 53
						  SET_Bit(MCUCR,ISC10);
     47c:	85 b7       	in	r24, 0x35	; 53
     47e:	84 60       	ori	r24, 0x04	; 4
     480:	85 bf       	out	0x35, r24	; 53
					break;
				 }
				 /* Enable THe InT 0 */
				 SET_Bit(GICR,INT1);
     482:	8b b7       	in	r24, 0x3b	; 59
     484:	80 68       	ori	r24, 0x80	; 128
     486:	8b bf       	out	0x3b, r24	; 59
				 break;
     488:	08 95       	ret
		  case EXINT_INT2 :
			   switch (Mode)
     48a:	62 30       	cpi	r22, 0x02	; 2
     48c:	19 f0       	breq	.+6      	; 0x494 <EXTINT_InterruptInit+0xba>
     48e:	63 30       	cpi	r22, 0x03	; 3
     490:	41 f4       	brne	.+16     	; 0x4a2 <EXTINT_InterruptInit+0xc8>
     492:	04 c0       	rjmp	.+8      	; 0x49c <EXTINT_InterruptInit+0xc2>
			   {
				   case EXINT_FallingEdge :
						RESET_Bit(MCUCSR,ISC2);
     494:	84 b7       	in	r24, 0x34	; 52
     496:	8f 7b       	andi	r24, 0xBF	; 191
     498:	84 bf       	out	0x34, r24	; 52
						break;
     49a:	03 c0       	rjmp	.+6      	; 0x4a2 <EXTINT_InterruptInit+0xc8>
				   case EXINT_RisingEdge :
						SET_Bit(MCUCSR,ISC2);
     49c:	84 b7       	in	r24, 0x34	; 52
     49e:	80 64       	ori	r24, 0x40	; 64
     4a0:	84 bf       	out	0x34, r24	; 52
				  case EXINT_LowLevel :
				  case EXINT_Toggle :
				  break;
			   }
			   /* Enable THe InT 0 */
			   SET_Bit(GICR,INT2);
     4a2:	8b b7       	in	r24, 0x3b	; 59
     4a4:	80 62       	ori	r24, 0x20	; 32
     4a6:	8b bf       	out	0x3b, r24	; 59
     4a8:	08 95       	ret

000004aa <__vector_12>:

SPI_Configuration SPI0 = {.SPI_TransferInterrupCall = NULL};


ISR (SPI_STC_vect)
{
     4aa:	1f 92       	push	r1
     4ac:	0f 92       	push	r0
     4ae:	0f b6       	in	r0, 0x3f	; 63
     4b0:	0f 92       	push	r0
     4b2:	11 24       	eor	r1, r1
     4b4:	2f 93       	push	r18
     4b6:	3f 93       	push	r19
     4b8:	4f 93       	push	r20
     4ba:	5f 93       	push	r21
     4bc:	6f 93       	push	r22
     4be:	7f 93       	push	r23
     4c0:	8f 93       	push	r24
     4c2:	9f 93       	push	r25
     4c4:	af 93       	push	r26
     4c6:	bf 93       	push	r27
     4c8:	ef 93       	push	r30
     4ca:	ff 93       	push	r31
	if (SPI0.SPI_TransferInterrupCall != NULL)
     4cc:	e0 91 7d 00 	lds	r30, 0x007D
     4d0:	f0 91 7e 00 	lds	r31, 0x007E
     4d4:	30 97       	sbiw	r30, 0x00	; 0
     4d6:	09 f0       	breq	.+2      	; 0x4da <__vector_12+0x30>
	{
		SPI0.SPI_TransferInterrupCall();
     4d8:	09 95       	icall
	}
}
     4da:	ff 91       	pop	r31
     4dc:	ef 91       	pop	r30
     4de:	bf 91       	pop	r27
     4e0:	af 91       	pop	r26
     4e2:	9f 91       	pop	r25
     4e4:	8f 91       	pop	r24
     4e6:	7f 91       	pop	r23
     4e8:	6f 91       	pop	r22
     4ea:	5f 91       	pop	r21
     4ec:	4f 91       	pop	r20
     4ee:	3f 91       	pop	r19
     4f0:	2f 91       	pop	r18
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0
     4f8:	1f 90       	pop	r1
     4fa:	18 95       	reti

000004fc <SPI_Intiat>:


void SPI_Intiat(void)
{
	/* at the First We Make The 2 Reg Of The SPI All 0 */
	SPCR = 0;
     4fc:	1d b8       	out	0x0d, r1	; 13
	SPSR = 0;
     4fe:	1e b8       	out	0x0e, r1	; 14
	switch (SPI0.EnableControl)
     500:	80 91 78 00 	lds	r24, 0x0078
     504:	81 30       	cpi	r24, 0x01	; 1
     506:	09 f0       	breq	.+2      	; 0x50a <SPI_Intiat+0xe>
     508:	7e c0       	rjmp	.+252    	; 0x606 <SPI_Intiat+0x10a>
		case SPI_Disable :
		/* In this Case We Should Put Bit Of the SPE In SPCR 0 And We Already Make All the Reg By 0 */
		break;
		case SPI_Enable :
		/* Configure The SPI Communication Setting */
		switch (SPI0.ModeSelect)
     50a:	80 91 79 00 	lds	r24, 0x0079
     50e:	88 23       	and	r24, r24
     510:	19 f0       	breq	.+6      	; 0x518 <SPI_Intiat+0x1c>
     512:	81 30       	cpi	r24, 0x01	; 1
     514:	99 f5       	brne	.+102    	; 0x57c <SPI_Intiat+0x80>
     516:	13 c0       	rjmp	.+38     	; 0x53e <SPI_Intiat+0x42>
		{
			case SPI_SLAVE :
			/* Make The Pin MISO As Output */
			//DDRB |= (1<<MISO);
			DIO_pinConfiguration(GPIOB, MISO, Output);
     518:	86 e3       	ldi	r24, 0x36	; 54
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	66 e0       	ldi	r22, 0x06	; 6
     51e:	42 e0       	ldi	r20, 0x02	; 2
     520:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
			DIO_pinConfiguration(GPIOB, MOSI, InputFloat);
     524:	86 e3       	ldi	r24, 0x36	; 54
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	65 e0       	ldi	r22, 0x05	; 5
     52a:	40 e0       	ldi	r20, 0x00	; 0
     52c:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
			DIO_pinConfiguration(GPIOB, SS, InputFloat);
     530:	86 e3       	ldi	r24, 0x36	; 54
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	64 e0       	ldi	r22, 0x04	; 4
     536:	40 e0       	ldi	r20, 0x00	; 0
     538:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
			break;
     53c:	1f c0       	rjmp	.+62     	; 0x57c <SPI_Intiat+0x80>
			case SPI_MASTER :
			/* Set the Bit MSTR In The Reg SPCR */
			//SPCR |= (1<<MSTR);
			SET_Bit(SPCR,MSTR);
     53e:	6c 9a       	sbi	0x0d, 4	; 13
			/* Make The Default Pin SCK , SS , MOSI an Output */
			//DDRB |= (1<<MOSI) | (1<<SS) | (1<<SCK);
			DIO_pinConfiguration(GPIOB, MOSI, Output);
     540:	86 e3       	ldi	r24, 0x36	; 54
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	65 e0       	ldi	r22, 0x05	; 5
     546:	42 e0       	ldi	r20, 0x02	; 2
     548:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
			DIO_pinConfiguration(GPIOB, SS, Output);
     54c:	86 e3       	ldi	r24, 0x36	; 54
     54e:	90 e0       	ldi	r25, 0x00	; 0
     550:	64 e0       	ldi	r22, 0x04	; 4
     552:	42 e0       	ldi	r20, 0x02	; 2
     554:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
			DIO_pinConfiguration(GPIOB, SCK, Output);
     558:	86 e3       	ldi	r24, 0x36	; 54
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	67 e0       	ldi	r22, 0x07	; 7
     55e:	42 e0       	ldi	r20, 0x02	; 2
     560:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
			/* Make The Pins MOSI, SS  As Default State HIGH */
			//PORTB |= (1<<SS) | (1<<MOSI); 
			DIO_pinWrite(GPIOB, MOSI, HIGH);
     564:	86 e3       	ldi	r24, 0x36	; 54
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	65 e0       	ldi	r22, 0x05	; 5
     56a:	41 e0       	ldi	r20, 0x01	; 1
     56c:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
			DIO_pinWrite(GPIOB, SS, HIGH);
     570:	86 e3       	ldi	r24, 0x36	; 54
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	64 e0       	ldi	r22, 0x04	; 4
     576:	41 e0       	ldi	r20, 0x01	; 1
     578:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
			break;
		}
		switch (SPI0.DataOreder)
     57c:	80 91 7b 00 	lds	r24, 0x007B
     580:	81 30       	cpi	r24, 0x01	; 1
     582:	09 f4       	brne	.+2      	; 0x586 <SPI_Intiat+0x8a>
			case SPI_MSB :
			/* In this Case We Should Put Bit Of the DORD In SPCR 0 And We Already Make All the Reg By 0 */
			break;
			case SPI_LSB :
			//SPCR |= (1<<DORD);
			SET_Bit(SPCR, DORD);
     584:	6d 9a       	sbi	0x0d, 5	; 13
			break;
		}
		switch (SPI0.InterruptState)
     586:	80 91 7a 00 	lds	r24, 0x007A
     58a:	81 30       	cpi	r24, 0x01	; 1
     58c:	09 f4       	brne	.+2      	; 0x590 <SPI_Intiat+0x94>
			case SPI_InterruptDisable:
			/* In this Case We Should Put Bit Of the SPIE In SPCR 0 And We Already Make All the Reg By 0 */
			break;
			case SPI_InterruptEnable:
			//SPCR |= (1<<SPIE);
			SET_Bit(SPCR, SPIE);
     58e:	6f 9a       	sbi	0x0d, 7	; 13
			break;
		}
		switch (SPI0.ClkMode)
     590:	80 91 7c 00 	lds	r24, 0x007C
     594:	82 30       	cpi	r24, 0x02	; 2
     596:	31 f0       	breq	.+12     	; 0x5a4 <SPI_Intiat+0xa8>
     598:	83 30       	cpi	r24, 0x03	; 3
     59a:	61 f0       	breq	.+24     	; 0x5b4 <SPI_Intiat+0xb8>
     59c:	81 30       	cpi	r24, 0x01	; 1
     59e:	91 f4       	brne	.+36     	; 0x5c4 <SPI_Intiat+0xc8>
			/* In this Case We Should Put Bit Of the CPOL,CPHA In SPCR 0 And We Already Make All the Reg By 0 */
			break;
			/* Setup(L) On Rising Sample On The Falling(T) */
			case SPI_ClkMode1:
			//SPCR |= (1<<CPHA);
			SET_Bit(SPCR, CPHA);
     5a0:	6a 9a       	sbi	0x0d, 2	; 13
			break;
     5a2:	10 c0       	rjmp	.+32     	; 0x5c4 <SPI_Intiat+0xc8>
			/* Sample(T) On Rising Setup(L) On the Falling */
			case SPI_ClkMode2:
			//SPCR |= (1<<CPOL);
			SET_Bit(SPCR, CPOL);
     5a4:	6b 9a       	sbi	0x0d, 3	; 13
			 * Note : if Used SPI Mode 3 or Mode 2 (CLK IDLE STATE = HIGH)
			 * in Some MicroControllers we must Explicitly State that The Default clk pin state is High 
			 * By Setting the pin to Output with a High Value 
			 */
			//PORTB |= (1<<SCK);
			DIO_pinWrite(GPIOB, SCK, HIGH);
     5a6:	86 e3       	ldi	r24, 0x36	; 54
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	67 e0       	ldi	r22, 0x07	; 7
     5ac:	41 e0       	ldi	r20, 0x01	; 1
     5ae:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
			break;
     5b2:	08 c0       	rjmp	.+16     	; 0x5c4 <SPI_Intiat+0xc8>
			/* Setup(T) On Rising Sample On The Falling(L) */
			case SPI_ClkMode3:
			//SPCR |= (1<<CPHA) | (1<<CPOL);
			SET_Bit(SPCR, CPHA);
     5b4:	6a 9a       	sbi	0x0d, 2	; 13
			SET_Bit(SPCR, CPOL);
     5b6:	6b 9a       	sbi	0x0d, 3	; 13
			//PORTB |= (1<<SCK);
			DIO_pinWrite(GPIOB, SCK, HIGH);
     5b8:	86 e3       	ldi	r24, 0x36	; 54
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	67 e0       	ldi	r22, 0x07	; 7
     5be:	41 e0       	ldi	r20, 0x01	; 1
     5c0:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
			break;
		}
		switch (SPI0.SCKFreq)
     5c4:	80 91 7f 00 	lds	r24, 0x007F
     5c8:	83 30       	cpi	r24, 0x03	; 3
     5ca:	99 f0       	breq	.+38     	; 0x5f2 <SPI_Intiat+0xf6>
     5cc:	84 30       	cpi	r24, 0x04	; 4
     5ce:	28 f4       	brcc	.+10     	; 0x5da <SPI_Intiat+0xde>
     5d0:	88 23       	and	r24, r24
     5d2:	51 f0       	breq	.+20     	; 0x5e8 <SPI_Intiat+0xec>
     5d4:	82 30       	cpi	r24, 0x02	; 2
     5d6:	b1 f4       	brne	.+44     	; 0x604 <SPI_Intiat+0x108>
     5d8:	09 c0       	rjmp	.+18     	; 0x5ec <SPI_Intiat+0xf0>
     5da:	85 30       	cpi	r24, 0x05	; 5
     5dc:	79 f0       	breq	.+30     	; 0x5fc <SPI_Intiat+0x100>
     5de:	85 30       	cpi	r24, 0x05	; 5
     5e0:	50 f0       	brcs	.+20     	; 0x5f6 <SPI_Intiat+0xfa>
     5e2:	86 30       	cpi	r24, 0x06	; 6
     5e4:	79 f4       	brne	.+30     	; 0x604 <SPI_Intiat+0x108>
     5e6:	0c c0       	rjmp	.+24     	; 0x600 <SPI_Intiat+0x104>
		{
			/* Get From The Table 58 In Page 137 In Data sheet */
			case SPI_FCPU_By_2:
			//SPSR |= (1<<SPI2X);
			SET_Bit(SPSR, SPI2X);
     5e8:	70 9a       	sbi	0x0e, 0	; 14
			break;
     5ea:	0c c0       	rjmp	.+24     	; 0x604 <SPI_Intiat+0x108>
			/* In this Case We Should Put Bit Of the SPR0,SPR1,SPI2X In SPCR 0 And We Already Make All the Reg By 0 */
			break;
			case SPI_FCPU_By_8:
			//SPSR |= (1<<SPI2X);
			//SPCR |= (1<<SPR0);
			SET_Bit(SPSR, SPI2X);
     5ec:	70 9a       	sbi	0x0e, 0	; 14
			SET_Bit(SPCR, SPR0);
     5ee:	68 9a       	sbi	0x0d, 0	; 13
			break;
     5f0:	09 c0       	rjmp	.+18     	; 0x604 <SPI_Intiat+0x108>
			case SPI_FCPU_By_16:
			//SPCR |= (1<<SPR0);
			SET_Bit(SPCR, SPR0);
     5f2:	68 9a       	sbi	0x0d, 0	; 13
			break;
     5f4:	07 c0       	rjmp	.+14     	; 0x604 <SPI_Intiat+0x108>
			case SPI_FCPU_By_32:
			//SPSR |= (1<<SPI2X);
			//SPCR |= (1<<SPR1);
			SET_Bit(SPSR, SPI2X);
     5f6:	70 9a       	sbi	0x0e, 0	; 14
			SET_Bit(SPCR, SPR1);
     5f8:	69 9a       	sbi	0x0d, 1	; 13
			break;
     5fa:	04 c0       	rjmp	.+8      	; 0x604 <SPI_Intiat+0x108>
			case SPI_FCPU_By_64:
			//SPCR |= (1<<SPR1);
			SET_Bit(SPCR, SPR1);
     5fc:	69 9a       	sbi	0x0d, 1	; 13
			break;
     5fe:	02 c0       	rjmp	.+4      	; 0x604 <SPI_Intiat+0x108>
			case SPI_FCPU_By_128:
			//SPCR |= (1<<SPR0) | (1<<SPR1);
			SET_Bit(SPCR, SPR0);
     600:	68 9a       	sbi	0x0d, 0	; 13
			SET_Bit(SPCR, SPR1);
     602:	69 9a       	sbi	0x0d, 1	; 13
			break;
		}
		/* Enable SPI Communication */
		SPCR |= (1<<SPE);		
     604:	6e 9a       	sbi	0x0d, 6	; 13
     606:	08 95       	ret

00000608 <Exchange_Byte_Blocking>:


unsigned char Exchange_Byte_Blocking(unsigned char Data)
{
	/* Transmit Data Using SPI */
	SPDR = Data;
     608:	8f b9       	out	0x0f, r24	; 15
	
	/* Chick If The Write Collision Error Occurred */
	if ((READ_Bit(SPSR, WCOL)) != 0)
     60a:	76 9b       	sbis	0x0e, 6	; 14
     60c:	03 c0       	rjmp	.+6      	; 0x614 <Exchange_Byte_Blocking+0xc>
	{
		SPI0.ErrorType = SPI_WriteColisionError;
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	80 93 80 00 	sts	0x0080, r24
	}
	
	/* Stuck Until The Transmission Is End */
	while ((READ_Bit(SPSR,SPIF)) == 0) {};
     614:	77 9b       	sbis	0x0e, 7	; 14
     616:	fe cf       	rjmp	.-4      	; 0x614 <Exchange_Byte_Blocking+0xc>
	
	/* Return Rx Data */
	return SPDR ;
     618:	8f b1       	in	r24, 0x0f	; 15
}	
     61a:	08 95       	ret

0000061c <Exchange_Byte_NoneBlocking>:
unsigned char Exchange_Byte_NoneBlocking(unsigned char Data)
{
	/* Transmit Data Using SPI */
	SPDR = Data;
     61c:	8f b9       	out	0x0f, r24	; 15
	
	/* Chick If The Write Collision Error Occurred */
	if ((READ_Bit(SPSR, WCOL)) != 0)
     61e:	76 9b       	sbis	0x0e, 6	; 14
     620:	03 c0       	rjmp	.+6      	; 0x628 <Exchange_Byte_NoneBlocking+0xc>
	{
		SPI0.ErrorType = SPI_WriteColisionError;
     622:	81 e0       	ldi	r24, 0x01	; 1
     624:	80 93 80 00 	sts	0x0080, r24
	}
	
	/* Return Rx Data */
	return SPDR ;
     628:	8f b1       	in	r24, 0x0f	; 15
}
     62a:	08 95       	ret

0000062c <TIMER_INTIATE>:
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
		unsigned char TIMASK_Temp = 0x00;
		
		/* Set up the Timer The User Select */
		switch(T.timer_Number)
     62c:	66 23       	and	r22, r22
     62e:	21 f0       	breq	.+8      	; 0x638 <TIMER_INTIATE+0xc>
     630:	61 30       	cpi	r22, 0x01	; 1
     632:	09 f0       	breq	.+2      	; 0x636 <TIMER_INTIATE+0xa>
     634:	87 c0       	rjmp	.+270    	; 0x744 <TIMER_INTIATE+0x118>
     636:	40 c0       	rjmp	.+128    	; 0x6b8 <TIMER_INTIATE+0x8c>
		{
			case Timer0:
				/* Set Up The Timer Mode By bit WGM01 WGM00 In The TCCR */
				switch (T.timer_mode)
     638:	73 30       	cpi	r23, 0x03	; 3
     63a:	31 f0       	breq	.+12     	; 0x648 <TIMER_INTIATE+0x1c>
     63c:	74 30       	cpi	r23, 0x04	; 4
     63e:	31 f0       	breq	.+12     	; 0x64c <TIMER_INTIATE+0x20>
     640:	71 30       	cpi	r23, 0x01	; 1
     642:	31 f0       	breq	.+12     	; 0x650 <TIMER_INTIATE+0x24>
 
 
    void TIMER_INTIATE(TIMER_DATATYPE T)
	{
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
     644:	20 e0       	ldi	r18, 0x00	; 0
     646:	05 c0       	rjmp	.+10     	; 0x652 <TIMER_INTIATE+0x26>
						 SET_Bit(TCCR_Temp,WGM01);
						 RESET_Bit(TCCR_Temp, WGM00);
					break;
					case Timer_Fast_PWM_Mode:
						 SET_Bit(TCCR_Temp,WGM00);
						 SET_Bit(TCCR_Temp,WGM01);
     648:	28 e4       	ldi	r18, 0x48	; 72
					break;
     64a:	03 c0       	rjmp	.+6      	; 0x652 <TIMER_INTIATE+0x26>
					case Timer_PhaceCorrect_PWM_Mode:
						 SET_Bit(TCCR_Temp,WGM00);
						 RESET_Bit(TCCR_Temp, WGM01);
     64c:	20 e4       	ldi	r18, 0x40	; 64
					break;
     64e:	01 c0       	rjmp	.+2      	; 0x652 <TIMER_INTIATE+0x26>
						 /* It Is The Normal Mode So No Change Will happened On The Bit */
				 
					break;
					case Timer_CTC_Mode:
						 SET_Bit(TCCR_Temp,WGM01);
						 RESET_Bit(TCCR_Temp, WGM00);
     650:	28 e0       	ldi	r18, 0x08	; 8
					default:
					break;
				}
		
				/* Set Up The Timer Clock Frequency By The Bit CS00, CS01 , CS02 In The TCCR */
				switch(T.timer_CLK)
     652:	87 30       	cpi	r24, 0x07	; 7
     654:	c9 f0       	breq	.+50     	; 0x688 <TIMER_INTIATE+0x5c>
     656:	88 30       	cpi	r24, 0x08	; 8
     658:	38 f4       	brcc	.+14     	; 0x668 <TIMER_INTIATE+0x3c>
     65a:	83 30       	cpi	r24, 0x03	; 3
     65c:	79 f0       	breq	.+30     	; 0x67c <TIMER_INTIATE+0x50>
     65e:	84 30       	cpi	r24, 0x04	; 4
     660:	81 f0       	breq	.+32     	; 0x682 <TIMER_INTIATE+0x56>
     662:	81 30       	cpi	r24, 0x01	; 1
     664:	d9 f4       	brne	.+54     	; 0x69c <TIMER_INTIATE+0x70>
     666:	07 c0       	rjmp	.+14     	; 0x676 <TIMER_INTIATE+0x4a>
     668:	89 30       	cpi	r24, 0x09	; 9
     66a:	a1 f0       	breq	.+40     	; 0x694 <TIMER_INTIATE+0x68>
     66c:	89 30       	cpi	r24, 0x09	; 9
     66e:	78 f0       	brcs	.+30     	; 0x68e <TIMER_INTIATE+0x62>
     670:	8a 30       	cpi	r24, 0x0A	; 10
     672:	a1 f4       	brne	.+40     	; 0x69c <TIMER_INTIATE+0x70>
     674:	12 c0       	rjmp	.+36     	; 0x69a <TIMER_INTIATE+0x6e>
					case Timer_NoCLK_Source:
						/* It SI The Default State At All Bit Equal 0 */
						/* In This Case The Timer Gets Its Clock From External Device */
					break;
					case Timer_Fcpu:
						 SET_Bit(TCCR_Temp,CS00);
     676:	21 60       	ori	r18, 0x01	; 1
						 RESET_Bit(TCCR_Temp,CS01);
						 RESET_Bit(TCCR_Temp,CS02);
     678:	29 7f       	andi	r18, 0xF9	; 249
					break;
     67a:	10 c0       	rjmp	.+32     	; 0x69c <TIMER_INTIATE+0x70>
					case Timer_Fcpu_Div8:
						 RESET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
     67c:	28 7f       	andi	r18, 0xF8	; 248
						 RESET_Bit(TCCR_Temp,CS02);
     67e:	22 60       	ori	r18, 0x02	; 2
					break;
     680:	0d c0       	rjmp	.+26     	; 0x69c <TIMER_INTIATE+0x70>
					case Timer_Fcpu_Div64:
						 SET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
     682:	23 60       	ori	r18, 0x03	; 3
						 RESET_Bit(TCCR_Temp,CS02);
     684:	2b 7f       	andi	r18, 0xFB	; 251
					break;
     686:	0a c0       	rjmp	.+20     	; 0x69c <TIMER_INTIATE+0x70>
					case Timer_Fcpu_Div256:
						 RESET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
     688:	2c 7f       	andi	r18, 0xFC	; 252
						 SET_Bit(TCCR_Temp,CS02);
     68a:	24 60       	ori	r18, 0x04	; 4
					break;
     68c:	07 c0       	rjmp	.+14     	; 0x69c <TIMER_INTIATE+0x70>
					case Timer_Fcpu_Div1024:
						 SET_Bit(TCCR_Temp,CS00);
						 RESET_Bit(TCCR_Temp,CS01);
     68e:	28 7f       	andi	r18, 0xF8	; 248
						 SET_Bit(TCCR_Temp,CS02);
     690:	25 60       	ori	r18, 0x05	; 5
					break;
     692:	04 c0       	rjmp	.+8      	; 0x69c <TIMER_INTIATE+0x70>
					case Timer_FallingEdge:
						 RESET_Bit(TCCR_Temp,CS00);
     694:	2e 7f       	andi	r18, 0xFE	; 254
						 SET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
     696:	26 60       	ori	r18, 0x06	; 6
					break;
     698:	01 c0       	rjmp	.+2      	; 0x69c <TIMER_INTIATE+0x70>
					case Timer_RisingEdge:
						 SET_Bit(TCCR_Temp,CS00);
						 SET_Bit(TCCR_Temp,CS01);
						 SET_Bit(TCCR_Temp,CS02);
     69a:	27 60       	ori	r18, 0x07	; 7
				   default:
				   break;
				}
		
				/* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
				switch(T.TimerINT_Source)
     69c:	91 30       	cpi	r25, 0x01	; 1
     69e:	19 f0       	breq	.+6      	; 0x6a6 <TIMER_INTIATE+0x7a>
     6a0:	92 30       	cpi	r25, 0x02	; 2
     6a2:	41 f4       	brne	.+16     	; 0x6b4 <TIMER_INTIATE+0x88>
     6a4:	04 c0       	rjmp	.+8      	; 0x6ae <TIMER_INTIATE+0x82>
				{
					case Timer_Overflow_Interrupt:
						 /* This Interrupt happened when the TCNT reach its Max then return to zero again */ 
						 SET_Bit(TIMSK,TOIE0);
     6a6:	89 b7       	in	r24, 0x39	; 57
     6a8:	81 60       	ori	r24, 0x01	; 1
     6aa:	89 bf       	out	0x39, r24	; 57
					break;
     6ac:	03 c0       	rjmp	.+6      	; 0x6b4 <TIMER_INTIATE+0x88>
					case Timer_TopCTC_Interrupt:
						 /* This Interrupt happened When The TCNT Reach The Value Equal The Value OnThe OCR and Return To Zero */
						 SET_Bit(TIMSK,OCIE0);
     6ae:	89 b7       	in	r24, 0x39	; 57
     6b0:	82 60       	ori	r24, 0x02	; 2
     6b2:	89 bf       	out	0x39, r24	; 57
					break;
					default:
					break;
			
				}
				TCCR0 = TCCR_Temp;
     6b4:	23 bf       	out	0x33, r18	; 51
		break;
     6b6:	46 c0       	rjmp	.+140    	; 0x744 <TIMER_INTIATE+0x118>
		case Timer2:
		     /* Set Up The Timer Mode By bit WGM21 WGM20 In The TCCR */
		     switch (T.timer_mode)
     6b8:	73 30       	cpi	r23, 0x03	; 3
     6ba:	31 f0       	breq	.+12     	; 0x6c8 <TIMER_INTIATE+0x9c>
     6bc:	74 30       	cpi	r23, 0x04	; 4
     6be:	31 f0       	breq	.+12     	; 0x6cc <TIMER_INTIATE+0xa0>
     6c0:	71 30       	cpi	r23, 0x01	; 1
     6c2:	31 f0       	breq	.+12     	; 0x6d0 <TIMER_INTIATE+0xa4>
 
 
    void TIMER_INTIATE(TIMER_DATATYPE T)
	{
		/* make temporary Register To Hold The Initiate Value */
		unsigned char TCCR_Temp = 0x00;
     6c4:	20 e0       	ldi	r18, 0x00	; 0
     6c6:	05 c0       	rjmp	.+10     	; 0x6d2 <TIMER_INTIATE+0xa6>
			     SET_Bit(TCCR_Temp,WGM21);
			     RESET_Bit(TCCR_Temp, WGM20);
			     break;
			     case Timer_Fast_PWM_Mode:
			     SET_Bit(TCCR_Temp,WGM20);
			     SET_Bit(TCCR_Temp,WGM21);
     6c8:	28 e4       	ldi	r18, 0x48	; 72
			     break;
     6ca:	03 c0       	rjmp	.+6      	; 0x6d2 <TIMER_INTIATE+0xa6>
			     case Timer_PhaceCorrect_PWM_Mode:
			     SET_Bit(TCCR_Temp,WGM20);
			     RESET_Bit(TCCR_Temp, WGM21);
     6cc:	20 e4       	ldi	r18, 0x40	; 64
			     break;
     6ce:	01 c0       	rjmp	.+2      	; 0x6d2 <TIMER_INTIATE+0xa6>
			     /* It Is The Normal Mode So No Change Will happened On The Bit */
			     
			     break;
			     case Timer_CTC_Mode:
			     SET_Bit(TCCR_Temp,WGM21);
			     RESET_Bit(TCCR_Temp, WGM20);
     6d0:	28 e0       	ldi	r18, 0x08	; 8
			     default:
			     break;
		     }
		     
		     /* Set Up The Timer Clock Frequency By The Bit CS20, CS21 , CS22 In The TCCR2 */
		     switch(T.timer_CLK)
     6d2:	84 30       	cpi	r24, 0x04	; 4
     6d4:	01 f1       	breq	.+64     	; 0x716 <TIMER_INTIATE+0xea>
     6d6:	85 30       	cpi	r24, 0x05	; 5
     6d8:	38 f4       	brcc	.+14     	; 0x6e8 <TIMER_INTIATE+0xbc>
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	89 f0       	breq	.+34     	; 0x700 <TIMER_INTIATE+0xd4>
     6de:	83 30       	cpi	r24, 0x03	; 3
     6e0:	a0 f4       	brcc	.+40     	; 0x70a <TIMER_INTIATE+0xde>
     6e2:	81 30       	cpi	r24, 0x01	; 1
     6e4:	11 f5       	brne	.+68     	; 0x72a <TIMER_INTIATE+0xfe>
     6e6:	09 c0       	rjmp	.+18     	; 0x6fa <TIMER_INTIATE+0xce>
     6e8:	86 30       	cpi	r24, 0x06	; 6
     6ea:	c1 f0       	breq	.+48     	; 0x71c <TIMER_INTIATE+0xf0>
     6ec:	86 30       	cpi	r24, 0x06	; 6
     6ee:	80 f0       	brcs	.+32     	; 0x710 <TIMER_INTIATE+0xe4>
     6f0:	87 30       	cpi	r24, 0x07	; 7
     6f2:	b9 f0       	breq	.+46     	; 0x722 <TIMER_INTIATE+0xf6>
     6f4:	88 30       	cpi	r24, 0x08	; 8
     6f6:	c9 f4       	brne	.+50     	; 0x72a <TIMER_INTIATE+0xfe>
     6f8:	17 c0       	rjmp	.+46     	; 0x728 <TIMER_INTIATE+0xfc>
		     {
			     case Timer_NoCLK_Source:
			     /* It SI The Default State At All Bit Equal 0 */
			     break;
			     case Timer_Fcpu:
			     SET_Bit(TCCR_Temp,CS20);
     6fa:	21 60       	ori	r18, 0x01	; 1
			     RESET_Bit(TCCR_Temp,CS21);
			     RESET_Bit(TCCR_Temp,CS22);
     6fc:	29 7f       	andi	r18, 0xF9	; 249
			     break;
     6fe:	15 c0       	rjmp	.+42     	; 0x72a <TIMER_INTIATE+0xfe>
				 case Timer2_OneSec_CLK:
				      /* In This Case To Get The Clock Exactly At One Sec We Used An External Clock With Value 32768Hz At Timer 2 Only Connect To the Pin 6 & 7 at Port C 
					   * Set the Pin AS2 At The Register ASSR To Make The Clock Source From The External Crystal 
					   *  Prescaler Value Will Used is 128 So 
					   */
					  ASSR = 0x08;
     700:	88 e0       	ldi	r24, 0x08	; 8
     702:	82 bd       	out	0x22, r24	; 34
					  SET_Bit(TCCR_Temp,CS20);
					  RESET_Bit(TCCR_Temp,CS21);
     704:	28 7f       	andi	r18, 0xF8	; 248
					  SET_Bit(TCCR_Temp,CS22);
     706:	25 60       	ori	r18, 0x05	; 5
				 break;
     708:	10 c0       	rjmp	.+32     	; 0x72a <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div8:
			     RESET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
     70a:	28 7f       	andi	r18, 0xF8	; 248
			     RESET_Bit(TCCR_Temp,CS22);
     70c:	22 60       	ori	r18, 0x02	; 2
			     break;
     70e:	0d c0       	rjmp	.+26     	; 0x72a <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div32:
			     SET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
     710:	23 60       	ori	r18, 0x03	; 3
			     RESET_Bit(TCCR_Temp,CS22);
     712:	2b 7f       	andi	r18, 0xFB	; 251
			     break;
     714:	0a c0       	rjmp	.+20     	; 0x72a <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div64:
			     RESET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
     716:	2c 7f       	andi	r18, 0xFC	; 252
			     SET_Bit(TCCR_Temp,CS22);
     718:	24 60       	ori	r18, 0x04	; 4
			     break;
     71a:	07 c0       	rjmp	.+14     	; 0x72a <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div128:
			     SET_Bit(TCCR_Temp,CS20);
			     RESET_Bit(TCCR_Temp,CS21);
     71c:	28 7f       	andi	r18, 0xF8	; 248
			     SET_Bit(TCCR_Temp,CS22);
     71e:	25 60       	ori	r18, 0x05	; 5
			     break;
     720:	04 c0       	rjmp	.+8      	; 0x72a <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div256:
			     RESET_Bit(TCCR_Temp,CS20);
     722:	2e 7f       	andi	r18, 0xFE	; 254
			     SET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
     724:	26 60       	ori	r18, 0x06	; 6
			     break;
     726:	01 c0       	rjmp	.+2      	; 0x72a <TIMER_INTIATE+0xfe>
			     case Timer_Fcpu_Div1024:
			     SET_Bit(TCCR_Temp,CS20);
			     SET_Bit(TCCR_Temp,CS21);
			     SET_Bit(TCCR_Temp,CS22);
     728:	27 60       	ori	r18, 0x07	; 7
				 /* If The User Select Else This Cases Handle An Error Massage */
			     break;
		     }
		     
		     /* Set Up The Interrupt Source By Set The Bit referee To The That Source InThe TIMASK */
		     switch(T.TimerINT_Source)
     72a:	91 30       	cpi	r25, 0x01	; 1
     72c:	19 f0       	breq	.+6      	; 0x734 <TIMER_INTIATE+0x108>
     72e:	92 30       	cpi	r25, 0x02	; 2
     730:	41 f4       	brne	.+16     	; 0x742 <TIMER_INTIATE+0x116>
     732:	04 c0       	rjmp	.+8      	; 0x73c <TIMER_INTIATE+0x110>
		     {
			     case Timer_Overflow_Interrupt:
			     /* This Interrupt happened when the TCNT reach its Max then return to zero again */
			     SET_Bit(TIMSK,TOIE2);
     734:	89 b7       	in	r24, 0x39	; 57
     736:	80 64       	ori	r24, 0x40	; 64
     738:	89 bf       	out	0x39, r24	; 57
			     break;
     73a:	03 c0       	rjmp	.+6      	; 0x742 <TIMER_INTIATE+0x116>
			     case Timer_TopCTC_Interrupt:
			     /* This Interrupt happened When The TCNT Reach The Value Equal The Value OnThe OCR and Return To Zero */
			     SET_Bit(TIMSK,OCIE2);
     73c:	89 b7       	in	r24, 0x39	; 57
     73e:	80 68       	ori	r24, 0x80	; 128
     740:	89 bf       	out	0x39, r24	; 57
			     break;
			     default:
			     break;
			     
		     }
			 TCCR2 = TCCR_Temp;
     742:	25 bd       	out	0x25, r18	; 37
			 break;
		}
			
		
		/* Set The I Bit In The Statues Register To Enable The General Interrupt */
		SET_Bit(SREG, 7);
     744:	8f b7       	in	r24, 0x3f	; 63
     746:	80 68       	ori	r24, 0x80	; 128
     748:	8f bf       	out	0x3f, r24	; 63
	}					 
     74a:	08 95       	ret

0000074c <TIMER_DELAY>:

	
		
    void TIMER_DELAY(TIMER_DATATYPE t, unsigned char Top_Value)
	{
		switch(t.timer_Number)
     74c:	66 23       	and	r22, r22
     74e:	19 f0       	breq	.+6      	; 0x756 <TIMER_DELAY+0xa>
     750:	61 30       	cpi	r22, 0x01	; 1
     752:	21 f4       	brne	.+8      	; 0x75c <TIMER_DELAY+0x10>
     754:	02 c0       	rjmp	.+4      	; 0x75a <TIMER_DELAY+0xe>
		{
			case Timer0: 
			     OCR0 = Top_Value;
     756:	4c bf       	out	0x3c, r20	; 60
			break;
     758:	08 95       	ret
			case Timer2:
			     OCR2 = Top_Value;
     75a:	43 bd       	out	0x23, r20	; 35
     75c:	08 95       	ret

0000075e <TIMER_WAVEGEN_NPWM>:
		}
	}
	
	
	void TIMER_WAVEGEN_NPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     75e:	cf 93       	push	r28
     760:	c4 2f       	mov	r28, r20
		switch (t.timer_Number)
     762:	66 23       	and	r22, r22
     764:	21 f0       	breq	.+8      	; 0x76e <TIMER_WAVEGEN_NPWM+0x10>
     766:	61 30       	cpi	r22, 0x01	; 1
     768:	09 f0       	breq	.+2      	; 0x76c <TIMER_WAVEGEN_NPWM+0xe>
     76a:	44 c0       	rjmp	.+136    	; 0x7f4 <TIMER_WAVEGEN_NPWM+0x96>
     76c:	22 c0       	rjmp	.+68     	; 0x7b2 <TIMER_WAVEGEN_NPWM+0x54>
		{
			case Timer0 :
				/* Set The Value Of OCR0 That will Wave Change after it */
				OCR0 = Top_Value;
     76e:	2c bf       	out	0x3c, r18	; 60
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     770:	86 e3       	ldi	r24, 0x36	; 54
     772:	90 e0       	ldi	r25, 0x00	; 0
     774:	63 e0       	ldi	r22, 0x03	; 3
     776:	42 e0       	ldi	r20, 0x02	; 2
     778:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
				/* Switch on the form we want the signal get out after each compare match */
				switch(wave)
     77c:	c2 30       	cpi	r28, 0x02	; 2
     77e:	59 f0       	breq	.+22     	; 0x796 <TIMER_WAVEGEN_NPWM+0x38>
     780:	c3 30       	cpi	r28, 0x03	; 3
     782:	81 f0       	breq	.+32     	; 0x7a4 <TIMER_WAVEGEN_NPWM+0x46>
     784:	c1 30       	cpi	r28, 0x01	; 1
     786:	b1 f5       	brne	.+108    	; 0x7f4 <TIMER_WAVEGEN_NPWM+0x96>
				{
					case NON:
					/* This is The Normal State when the COM00 and COM01 is cleared */
					break;
					case Toggle_PB_InCM:
						 RESET_Bit(TCCR0, COM01);
     788:	83 b7       	in	r24, 0x33	; 51
     78a:	8f 7d       	andi	r24, 0xDF	; 223
     78c:	83 bf       	out	0x33, r24	; 51
						 SET_Bit(TCCR0, COM00);
     78e:	83 b7       	in	r24, 0x33	; 51
     790:	80 61       	ori	r24, 0x10	; 16
     792:	83 bf       	out	0x33, r24	; 51
					break;
     794:	2f c0       	rjmp	.+94     	; 0x7f4 <TIMER_WAVEGEN_NPWM+0x96>
					case Clear_PB_InCM:
						 SET_Bit(TCCR0, COM01);
     796:	83 b7       	in	r24, 0x33	; 51
     798:	80 62       	ori	r24, 0x20	; 32
     79a:	83 bf       	out	0x33, r24	; 51
						 RESET_Bit(TCCR0, COM00);
     79c:	83 b7       	in	r24, 0x33	; 51
     79e:	8f 7e       	andi	r24, 0xEF	; 239
     7a0:	83 bf       	out	0x33, r24	; 51
					break;
     7a2:	28 c0       	rjmp	.+80     	; 0x7f4 <TIMER_WAVEGEN_NPWM+0x96>
					case Set_PB_InCM:
						SET_Bit(TCCR0, COM01);
     7a4:	83 b7       	in	r24, 0x33	; 51
     7a6:	80 62       	ori	r24, 0x20	; 32
     7a8:	83 bf       	out	0x33, r24	; 51
						SET_Bit(TCCR0, COM00);
     7aa:	83 b7       	in	r24, 0x33	; 51
     7ac:	80 61       	ori	r24, 0x10	; 16
     7ae:	83 bf       	out	0x33, r24	; 51
						break;
     7b0:	21 c0       	rjmp	.+66     	; 0x7f4 <TIMER_WAVEGEN_NPWM+0x96>
					break;
				}
			break;
			case Timer2: 
				    /* Set The Value Of OCR2 That will Wave Change after it */
					OCR2 = Top_Value;
     7b2:	23 bd       	out	0x23, r18	; 35
					/* at the first we set up the pin of the wave output in the Mc as output state OC2 pin */
					DIO_pinConfiguration(GPIOD,PIN7, Output);
     7b4:	80 e3       	ldi	r24, 0x30	; 48
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	67 e0       	ldi	r22, 0x07	; 7
     7ba:	42 e0       	ldi	r20, 0x02	; 2
     7bc:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
					/* Switch on the form we want the signal get out after each compare match */
					switch(wave)
     7c0:	c2 30       	cpi	r28, 0x02	; 2
     7c2:	59 f0       	breq	.+22     	; 0x7da <TIMER_WAVEGEN_NPWM+0x7c>
     7c4:	c3 30       	cpi	r28, 0x03	; 3
     7c6:	81 f0       	breq	.+32     	; 0x7e8 <TIMER_WAVEGEN_NPWM+0x8a>
     7c8:	c1 30       	cpi	r28, 0x01	; 1
     7ca:	a1 f4       	brne	.+40     	; 0x7f4 <TIMER_WAVEGEN_NPWM+0x96>
					{
						case NON:
						/* This is The Normal State when the COM00 and COM01 is cleared */
						break;
						case Toggle_PB_InCM:
							 RESET_Bit(TCCR2, COM21);
     7cc:	85 b5       	in	r24, 0x25	; 37
     7ce:	8f 7d       	andi	r24, 0xDF	; 223
     7d0:	85 bd       	out	0x25, r24	; 37
							 SET_Bit(TCCR2, COM20);
     7d2:	85 b5       	in	r24, 0x25	; 37
     7d4:	80 61       	ori	r24, 0x10	; 16
     7d6:	85 bd       	out	0x25, r24	; 37
						break;
     7d8:	0d c0       	rjmp	.+26     	; 0x7f4 <TIMER_WAVEGEN_NPWM+0x96>
						case Clear_PB_InCM:
							 SET_Bit(TCCR2, COM21);
     7da:	85 b5       	in	r24, 0x25	; 37
     7dc:	80 62       	ori	r24, 0x20	; 32
     7de:	85 bd       	out	0x25, r24	; 37
							 RESET_Bit(TCCR2, COM20);
     7e0:	85 b5       	in	r24, 0x25	; 37
     7e2:	8f 7e       	andi	r24, 0xEF	; 239
     7e4:	85 bd       	out	0x25, r24	; 37
						break;
     7e6:	06 c0       	rjmp	.+12     	; 0x7f4 <TIMER_WAVEGEN_NPWM+0x96>
						case Set_PB_InCM:
							SET_Bit(TCCR2, COM21);
     7e8:	85 b5       	in	r24, 0x25	; 37
     7ea:	80 62       	ori	r24, 0x20	; 32
     7ec:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM20);
     7ee:	85 b5       	in	r24, 0x25	; 37
     7f0:	80 61       	ori	r24, 0x10	; 16
     7f2:	85 bd       	out	0x25, r24	; 37
			break;
			default:
			break;
		}
	
	}	
     7f4:	cf 91       	pop	r28
     7f6:	08 95       	ret

000007f8 <TIMER_WAVEGEN_FASTPWM>:
	void TIMER_WAVEGEN_FASTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     7f8:	cf 93       	push	r28
     7fa:	c4 2f       	mov	r28, r20
		switch(t.timer_Number)
     7fc:	66 23       	and	r22, r22
     7fe:	19 f0       	breq	.+6      	; 0x806 <TIMER_WAVEGEN_FASTPWM+0xe>
     800:	61 30       	cpi	r22, 0x01	; 1
     802:	b1 f5       	brne	.+108    	; 0x870 <__stack+0x11>
     804:	1b c0       	rjmp	.+54     	; 0x83c <TIMER_WAVEGEN_FASTPWM+0x44>
				  *
				  * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				  * if the user choose the inverting mode this result become the OFF time ratio 
				  * and if decide non inverting mode this ratio become the ON time ratio 
				  */
				OCR0 = Top_Value;
     806:	2c bf       	out	0x3c, r18	; 60
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     808:	86 e3       	ldi	r24, 0x36	; 54
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	63 e0       	ldi	r22, 0x03	; 3
     80e:	42 e0       	ldi	r20, 0x02	; 2
     810:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
		
				/* Note 
					* the case of COM00 , COM01 is decimal 1 is reserved ( Not use ) 
					*/
				switch(wave)
     814:	c4 30       	cpi	r28, 0x04	; 4
     816:	59 f0       	breq	.+22     	; 0x82e <TIMER_WAVEGEN_FASTPWM+0x36>
     818:	c5 30       	cpi	r28, 0x05	; 5
     81a:	11 f0       	breq	.+4      	; 0x820 <TIMER_WAVEGEN_FASTPWM+0x28>
     81c:	cc 23       	and	r28, r28
     81e:	41 f5       	brne	.+80     	; 0x870 <__stack+0x11>
					case NON:
							/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
				 
					case NonInverting_FPWM:
							/* This mode when the signal on the OC0 is cleared when happen Compare match with the value on OCR0 and Set when TCCR0  reach bottom (Overflow) */
							RESET_Bit(TCCR0, COM00);
     820:	83 b7       	in	r24, 0x33	; 51
     822:	8f 7e       	andi	r24, 0xEF	; 239
     824:	83 bf       	out	0x33, r24	; 51
							SET_Bit(TCCR0, COM01);
     826:	83 b7       	in	r24, 0x33	; 51
     828:	80 62       	ori	r24, 0x20	; 32
     82a:	83 bf       	out	0x33, r24	; 51
					break;
     82c:	21 c0       	rjmp	.+66     	; 0x870 <__stack+0x11>
					case Inverting_FPWM:
							/* This mode when the signal on the OC0 is set when happen Compare match with the value on OCR0 and Cleared when TCCR0  reach bottom (Overflow) */
							SET_Bit(TCCR0, COM00);
     82e:	83 b7       	in	r24, 0x33	; 51
     830:	80 61       	ori	r24, 0x10	; 16
     832:	83 bf       	out	0x33, r24	; 51
							SET_Bit(TCCR0, COM01);
     834:	83 b7       	in	r24, 0x33	; 51
     836:	80 62       	ori	r24, 0x20	; 32
     838:	83 bf       	out	0x33, r24	; 51
					break;
     83a:	1a c0       	rjmp	.+52     	; 0x870 <__stack+0x11>
				  *
				  * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				  * if the user choose the inverting mode this result become the OFF time ratio 
				  * and if decide non inverting mode this ratio become the ON time ratio 
				  */
				OCR2 = Top_Value;
     83c:	23 bd       	out	0x23, r18	; 35
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOD,PIN7, Output);
     83e:	80 e3       	ldi	r24, 0x30	; 48
     840:	90 e0       	ldi	r25, 0x00	; 0
     842:	67 e0       	ldi	r22, 0x07	; 7
     844:	42 e0       	ldi	r20, 0x02	; 2
     846:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
		
				/* Note 
					* the case of COM20 , COM21 is decimal 1 is reserved ( Not use ) 
					*/
				switch(wave)
     84a:	c4 30       	cpi	r28, 0x04	; 4
     84c:	59 f0       	breq	.+22     	; 0x864 <__stack+0x5>
     84e:	c5 30       	cpi	r28, 0x05	; 5
     850:	11 f0       	breq	.+4      	; 0x856 <TIMER_WAVEGEN_FASTPWM+0x5e>
     852:	cc 23       	and	r28, r28
     854:	69 f4       	brne	.+26     	; 0x870 <__stack+0x11>
					case NON:
							/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
				 
					case NonInverting_FPWM:
							/* This mode when the signal on the OC0 is cleared when happen Compare match with the value on OCR0 and Set when TCCR0  reach bottom (Overflow) */
							RESET_Bit(TCCR2, COM20);
     856:	85 b5       	in	r24, 0x25	; 37
     858:	8f 7e       	andi	r24, 0xEF	; 239
     85a:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM21);
     85c:	85 b5       	in	r24, 0x25	; 37
     85e:	80 62       	ori	r24, 0x20	; 32
     860:	85 bd       	out	0x25, r24	; 37
					break;
     862:	06 c0       	rjmp	.+12     	; 0x870 <__stack+0x11>
					case Inverting_FPWM:
							/* This mode when the signal on the OC0 is set when happen Compare match with the value on OCR0 and Cleared when TCCR0  reach bottom (Overflow) */
							SET_Bit(TCCR2, COM20);
     864:	85 b5       	in	r24, 0x25	; 37
     866:	80 61       	ori	r24, 0x10	; 16
     868:	85 bd       	out	0x25, r24	; 37
							SET_Bit(TCCR2, COM21);
     86a:	85 b5       	in	r24, 0x25	; 37
     86c:	80 62       	ori	r24, 0x20	; 32
     86e:	85 bd       	out	0x25, r24	; 37
			default :
			break;
		}
		
		
	}	
     870:	cf 91       	pop	r28
     872:	08 95       	ret

00000874 <TIMER_WAVEGEN_PHACECORRECTPWM>:
	
	
	void TIMER_WAVEGEN_PHACECORRECTPWM(TIMER_DATATYPE t, Wave_Gen_OP wave, unsigned char Top_Value)
	{
     874:	cf 93       	push	r28
     876:	c4 2f       	mov	r28, r20
		switch(t.timer_Number)
     878:	66 23       	and	r22, r22
     87a:	19 f0       	breq	.+6      	; 0x882 <TIMER_WAVEGEN_PHACECORRECTPWM+0xe>
     87c:	61 30       	cpi	r22, 0x01	; 1
     87e:	b1 f5       	brne	.+108    	; 0x8ec <TIMER_WAVEGEN_PHACECORRECTPWM+0x78>
     880:	1b c0       	rjmp	.+54     	; 0x8b8 <TIMER_WAVEGEN_PHACECORRECTPWM+0x44>
				 *
				 * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				 * if the user choose Set OC0 at up counting and Clear at down counting  mode this result become the OFF time ratio 
				 * and if decide Clear OC0 at up counting and Set at down counting  mode this ratio become the ON time ratio 
				 */
				OCR0 = Top_Value;
     882:	2c bf       	out	0x3c, r18	; 60
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOB,PIN3, Output);
     884:	86 e3       	ldi	r24, 0x36	; 54
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	63 e0       	ldi	r22, 0x03	; 3
     88a:	42 e0       	ldi	r20, 0x02	; 2
     88c:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
		
				/* Note 
				 * the case of COM00 , COM01 is decimal 1 is reserved ( Not use ) 
				 */
				switch(wave)
     890:	c6 30       	cpi	r28, 0x06	; 6
     892:	21 f0       	breq	.+8      	; 0x89c <TIMER_WAVEGEN_PHACECORRECTPWM+0x28>
     894:	c7 30       	cpi	r28, 0x07	; 7
     896:	49 f0       	breq	.+18     	; 0x8aa <TIMER_WAVEGEN_PHACECORRECTPWM+0x36>
     898:	cc 23       	and	r28, r28
     89a:	41 f5       	brne	.+80     	; 0x8ec <TIMER_WAVEGEN_PHACECORRECTPWM+0x78>
					case NON:
					/* This IS the normal mode OC0 IS disconnected when the COM00 and COM01 is cleared  */
			
					case ClearUp_SetDowen_PCPWM:
					/* This mode operation is the signal on the OC0 is clear when happen Compare match with the value on OCR0 at the up counting of the TCNT0 and Set when happen compare match at the down counting of the TCNT0 */
					RESET_Bit(TCCR0, COM00);
     89c:	83 b7       	in	r24, 0x33	; 51
     89e:	8f 7e       	andi	r24, 0xEF	; 239
     8a0:	83 bf       	out	0x33, r24	; 51
					SET_Bit(TCCR0, COM01);
     8a2:	83 b7       	in	r24, 0x33	; 51
     8a4:	80 62       	ori	r24, 0x20	; 32
     8a6:	83 bf       	out	0x33, r24	; 51
					break;
     8a8:	21 c0       	rjmp	.+66     	; 0x8ec <TIMER_WAVEGEN_PHACECORRECTPWM+0x78>
					case SetUp_ClearDowen_PCPWM:
					/* This mode operation is the signal on the OC0 is set when happen Compare match with the value on OCR0 at the up counting of the TCNT0 and clear when happen compare match at the down counting of the TCNT0 */
					SET_Bit(TCCR0, COM00);
     8aa:	83 b7       	in	r24, 0x33	; 51
     8ac:	80 61       	ori	r24, 0x10	; 16
     8ae:	83 bf       	out	0x33, r24	; 51
					SET_Bit(TCCR0, COM01);
     8b0:	83 b7       	in	r24, 0x33	; 51
     8b2:	80 62       	ori	r24, 0x20	; 32
     8b4:	83 bf       	out	0x33, r24	; 51
					break;
     8b6:	1a c0       	rjmp	.+52     	; 0x8ec <TIMER_WAVEGEN_PHACECORRECTPWM+0x78>
				 *
				 * Note: That this value decide the value of the duty cycle (the ratio of ON time ) by Top_Value/ 256 
				 * if the user choose Set OC2 at up counting and Clear at down counting  mode this result become the OFF time ratio 
				 * and if decide Clear OC2 at up counting and Set at down counting  mode this ratio become the ON time ratio 
				 */
				OCR2 = Top_Value;
     8b8:	23 bd       	out	0x23, r18	; 35
		
				/* at the first we set up the pin of the wave output in the Mc as output state */
				DIO_pinConfiguration(GPIOD,PIN7, Output);
     8ba:	80 e3       	ldi	r24, 0x30	; 48
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	67 e0       	ldi	r22, 0x07	; 7
     8c0:	42 e0       	ldi	r20, 0x02	; 2
     8c2:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
		
				/* Note 
				 * the case of COM20 , COM21 is decimal 1 is reserved ( Not use ) 
				 */
				switch(wave)
     8c6:	c6 30       	cpi	r28, 0x06	; 6
     8c8:	21 f0       	breq	.+8      	; 0x8d2 <TIMER_WAVEGEN_PHACECORRECTPWM+0x5e>
     8ca:	c7 30       	cpi	r28, 0x07	; 7
     8cc:	49 f0       	breq	.+18     	; 0x8e0 <TIMER_WAVEGEN_PHACECORRECTPWM+0x6c>
     8ce:	cc 23       	and	r28, r28
     8d0:	69 f4       	brne	.+26     	; 0x8ec <TIMER_WAVEGEN_PHACECORRECTPWM+0x78>
					case NON:
					/* This IS the normal mode OC2 IS disconnected when the COM20 and COM21 is cleared  */
			
					case ClearUp_SetDowen_PCPWM:
					/* This mode operation is the signal on the OC2 is clear when happen Compare match with the value on OCR2 at the up counting of the TCNT0 and Set when happen compare match at the down counting of the TCNT0 */
					RESET_Bit(TCCR2, COM20);
     8d2:	85 b5       	in	r24, 0x25	; 37
     8d4:	8f 7e       	andi	r24, 0xEF	; 239
     8d6:	85 bd       	out	0x25, r24	; 37
					SET_Bit(TCCR2, COM21);
     8d8:	85 b5       	in	r24, 0x25	; 37
     8da:	80 62       	ori	r24, 0x20	; 32
     8dc:	85 bd       	out	0x25, r24	; 37
					break;
     8de:	06 c0       	rjmp	.+12     	; 0x8ec <TIMER_WAVEGEN_PHACECORRECTPWM+0x78>
					case SetUp_ClearDowen_PCPWM:
					/* This mode operation is the signal on the OC2 is set when happen Compare match with the value on OCR2 at the up counting of the TCNT0 and clear when happen compare match at the down counting of the TCNT0 */
					SET_Bit(TCCR2, COM20);
     8e0:	85 b5       	in	r24, 0x25	; 37
     8e2:	80 61       	ori	r24, 0x10	; 16
     8e4:	85 bd       	out	0x25, r24	; 37
					SET_Bit(TCCR2, COM21);
     8e6:	85 b5       	in	r24, 0x25	; 37
     8e8:	80 62       	ori	r24, 0x20	; 32
     8ea:	85 bd       	out	0x25, r24	; 37
			break;
			default: 
			
			break;
		}		
	}	
     8ec:	cf 91       	pop	r28
     8ee:	08 95       	ret

000008f0 <USART_RXC_vect>:
		 * so it should write as ISR(_vector(13)) but this is define in the AVR/Interrupt 
		*/ 					 
							 
	/* interrupt function by the RXC */						 
	 ISR (USART_RXC_vect)
	 {
     8f0:	1f 92       	push	r1
     8f2:	0f 92       	push	r0
     8f4:	0f b6       	in	r0, 0x3f	; 63
     8f6:	0f 92       	push	r0
     8f8:	11 24       	eor	r1, r1
     8fa:	2f 93       	push	r18
     8fc:	3f 93       	push	r19
     8fe:	4f 93       	push	r20
     900:	5f 93       	push	r21
     902:	6f 93       	push	r22
     904:	7f 93       	push	r23
     906:	8f 93       	push	r24
     908:	9f 93       	push	r25
     90a:	af 93       	push	r26
     90c:	bf 93       	push	r27
     90e:	ef 93       	push	r30
     910:	ff 93       	push	r31
		 if (USART0.RXC_InterruptCall != NULL)
     912:	e0 91 8d 00 	lds	r30, 0x008D
     916:	f0 91 8e 00 	lds	r31, 0x008E
     91a:	30 97       	sbiw	r30, 0x00	; 0
     91c:	09 f0       	breq	.+2      	; 0x920 <USART_RXC_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.RXC_InterruptCall();
     91e:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     920:	ff 91       	pop	r31
     922:	ef 91       	pop	r30
     924:	bf 91       	pop	r27
     926:	af 91       	pop	r26
     928:	9f 91       	pop	r25
     92a:	8f 91       	pop	r24
     92c:	7f 91       	pop	r23
     92e:	6f 91       	pop	r22
     930:	5f 91       	pop	r21
     932:	4f 91       	pop	r20
     934:	3f 91       	pop	r19
     936:	2f 91       	pop	r18
     938:	0f 90       	pop	r0
     93a:	0f be       	out	0x3f, r0	; 63
     93c:	0f 90       	pop	r0
     93e:	1f 90       	pop	r1
     940:	18 95       	reti

00000942 <USART_TXC_vect>:
	 
	 
	 /* interrupt function by the RXC */						 
	 ISR (USART_TXC_vect)
	 {
     942:	1f 92       	push	r1
     944:	0f 92       	push	r0
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	0f 92       	push	r0
     94a:	11 24       	eor	r1, r1
     94c:	2f 93       	push	r18
     94e:	3f 93       	push	r19
     950:	4f 93       	push	r20
     952:	5f 93       	push	r21
     954:	6f 93       	push	r22
     956:	7f 93       	push	r23
     958:	8f 93       	push	r24
     95a:	9f 93       	push	r25
     95c:	af 93       	push	r26
     95e:	bf 93       	push	r27
     960:	ef 93       	push	r30
     962:	ff 93       	push	r31
		 if (USART0.TXC_InterruptCall != NULL)
     964:	e0 91 8f 00 	lds	r30, 0x008F
     968:	f0 91 90 00 	lds	r31, 0x0090
     96c:	30 97       	sbiw	r30, 0x00	; 0
     96e:	09 f0       	breq	.+2      	; 0x972 <USART_TXC_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.TXC_InterruptCall();
     970:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     972:	ff 91       	pop	r31
     974:	ef 91       	pop	r30
     976:	bf 91       	pop	r27
     978:	af 91       	pop	r26
     97a:	9f 91       	pop	r25
     97c:	8f 91       	pop	r24
     97e:	7f 91       	pop	r23
     980:	6f 91       	pop	r22
     982:	5f 91       	pop	r21
     984:	4f 91       	pop	r20
     986:	3f 91       	pop	r19
     988:	2f 91       	pop	r18
     98a:	0f 90       	pop	r0
     98c:	0f be       	out	0x3f, r0	; 63
     98e:	0f 90       	pop	r0
     990:	1f 90       	pop	r1
     992:	18 95       	reti

00000994 <USART_UDRE_vect>:
	 
	 
	 /* interrupt function by the UDRE */						 
	 ISR (USART_UDRE_vect)
	 {
     994:	1f 92       	push	r1
     996:	0f 92       	push	r0
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	0f 92       	push	r0
     99c:	11 24       	eor	r1, r1
     99e:	2f 93       	push	r18
     9a0:	3f 93       	push	r19
     9a2:	4f 93       	push	r20
     9a4:	5f 93       	push	r21
     9a6:	6f 93       	push	r22
     9a8:	7f 93       	push	r23
     9aa:	8f 93       	push	r24
     9ac:	9f 93       	push	r25
     9ae:	af 93       	push	r26
     9b0:	bf 93       	push	r27
     9b2:	ef 93       	push	r30
     9b4:	ff 93       	push	r31
		 if (USART0.UDRE_InterruptCall != NULL)
     9b6:	e0 91 91 00 	lds	r30, 0x0091
     9ba:	f0 91 92 00 	lds	r31, 0x0092
     9be:	30 97       	sbiw	r30, 0x00	; 0
     9c0:	09 f0       	breq	.+2      	; 0x9c4 <USART_UDRE_vect+0x30>
		 {
			 /* if it not point to the zero that mean it point to the interrupt function so we call it using call Back */
			 USART0.UDRE_InterruptCall();
     9c2:	09 95       	icall
			 /* that mean that the interrupt is activate and no function implement 
			  * if the user take the project it is his fault so we keep that else empty 
			  * if you in stage of implementation you should handle the error massage 
			 */
		 }			 
	 }
     9c4:	ff 91       	pop	r31
     9c6:	ef 91       	pop	r30
     9c8:	bf 91       	pop	r27
     9ca:	af 91       	pop	r26
     9cc:	9f 91       	pop	r25
     9ce:	8f 91       	pop	r24
     9d0:	7f 91       	pop	r23
     9d2:	6f 91       	pop	r22
     9d4:	5f 91       	pop	r21
     9d6:	4f 91       	pop	r20
     9d8:	3f 91       	pop	r19
     9da:	2f 91       	pop	r18
     9dc:	0f 90       	pop	r0
     9de:	0f be       	out	0x3f, r0	; 63
     9e0:	0f 90       	pop	r0
     9e2:	1f 90       	pop	r1
     9e4:	18 95       	reti

000009e6 <USART_Intia>:
	
	  void USART_Intia(void)
	  {
     9e6:	ff 92       	push	r15
     9e8:	0f 93       	push	r16
     9ea:	1f 93       	push	r17
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
		  unsigned char UCSRA_Temp = 0;
		  unsigned char UCSRB_Temp = 0;
		  unsigned char UCSRC_Temp = 0;
		  float   UBRR_Temp = 0.0;
		  
		  switch (USART0.enableMode)
     9f0:	80 91 81 00 	lds	r24, 0x0081
     9f4:	82 30       	cpi	r24, 0x02	; 2
     9f6:	51 f0       	breq	.+20     	; 0xa0c <USART_Intia+0x26>
     9f8:	83 30       	cpi	r24, 0x03	; 3
     9fa:	31 f0       	breq	.+12     	; 0xa08 <USART_Intia+0x22>
     9fc:	81 30       	cpi	r24, 0x01	; 1
     9fe:	11 f0       	breq	.+4      	; 0xa04 <USART_Intia+0x1e>
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
		  unsigned char UCSRB_Temp = 0;
     a00:	c0 e0       	ldi	r28, 0x00	; 0
     a02:	05 c0       	rjmp	.+10     	; 0xa0e <USART_Intia+0x28>
			  break;
			  case USART_Rx_Only:
			       UCSRB_Temp |= (1<<RXEN);
			  break;
			  case USART_Tx_Only:
			       UCSRB_Temp |= (1<<TXEN);
     a04:	c8 e0       	ldi	r28, 0x08	; 8
			  break;
     a06:	03 c0       	rjmp	.+6      	; 0xa0e <USART_Intia+0x28>
			  case USART_TxRx_Enable:
			       UCSRB_Temp |= (1<<RXEN) | (1<<TXEN);
     a08:	c8 e1       	ldi	r28, 0x18	; 24
			  break;
     a0a:	01 c0       	rjmp	.+2      	; 0xa0e <USART_Intia+0x28>
		  {
			  case USART_Disable:
			    
			  break;
			  case USART_Rx_Only:
			       UCSRB_Temp |= (1<<RXEN);
     a0c:	c0 e1       	ldi	r28, 0x10	; 16
			  break;
			  default:
			  break;
		  }	
		  
		  switch(USART0.communicationMode)
     a0e:	80 91 82 00 	lds	r24, 0x0082
     a12:	81 30       	cpi	r24, 0x01	; 1
     a14:	51 f1       	breq	.+84     	; 0xa6a <USART_Intia+0x84>
     a16:	81 30       	cpi	r24, 0x01	; 1
     a18:	20 f0       	brcs	.+8      	; 0xa22 <USART_Intia+0x3c>
     a1a:	82 30       	cpi	r24, 0x02	; 2
     a1c:	09 f0       	breq	.+2      	; 0xa20 <USART_Intia+0x3a>
     a1e:	6b c0       	rjmp	.+214    	; 0xaf6 <USART_Intia+0x110>
     a20:	48 c0       	rjmp	.+144    	; 0xab2 <USART_Intia+0xcc>
		  {
			  case USART_Asyn_DoupleSpeed:
			       UCSRA_Temp |= (1<<U2X);
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
     a22:	60 91 89 00 	lds	r22, 0x0089
     a26:	70 91 8a 00 	lds	r23, 0x008A
     a2a:	80 91 8b 00 	lds	r24, 0x008B
     a2e:	90 91 8c 00 	lds	r25, 0x008C
     a32:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <__floatunsisf>
     a36:	20 e0       	ldi	r18, 0x00	; 0
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	40 e0       	ldi	r20, 0x00	; 0
     a3c:	51 e4       	ldi	r21, 0x41	; 65
     a3e:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
     a42:	9b 01       	movw	r18, r22
     a44:	ac 01       	movw	r20, r24
     a46:	60 e0       	ldi	r22, 0x00	; 0
     a48:	74 e2       	ldi	r23, 0x24	; 36
     a4a:	84 e7       	ldi	r24, 0x74	; 116
     a4c:	9b e4       	ldi	r25, 0x4B	; 75
     a4e:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <__divsf3>
     a52:	20 e0       	ldi	r18, 0x00	; 0
     a54:	30 e0       	ldi	r19, 0x00	; 0
     a56:	40 e0       	ldi	r20, 0x00	; 0
     a58:	5f e3       	ldi	r21, 0x3F	; 63
     a5a:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <__subsf3>
     a5e:	f6 2e       	mov	r15, r22
     a60:	07 2f       	mov	r16, r23
     a62:	18 2f       	mov	r17, r24
     a64:	d9 2f       	mov	r29, r25
		  }	
		  
		  switch(USART0.communicationMode)
		  {
			  case USART_Asyn_DoupleSpeed:
			       UCSRA_Temp |= (1<<U2X);
     a66:	92 e0       	ldi	r25, 0x02	; 2
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
			  break;
     a68:	4b c0       	rjmp	.+150    	; 0xb00 <USART_Intia+0x11a>
			  
			  case USART_Asyn_SingleSpeed:
			       UBRR_Temp = (((float)F_CPU) / (16.0 * USART0.baudRate)) - 0.5;
     a6a:	60 91 89 00 	lds	r22, 0x0089
     a6e:	70 91 8a 00 	lds	r23, 0x008A
     a72:	80 91 8b 00 	lds	r24, 0x008B
     a76:	90 91 8c 00 	lds	r25, 0x008C
     a7a:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <__floatunsisf>
     a7e:	20 e0       	ldi	r18, 0x00	; 0
     a80:	30 e0       	ldi	r19, 0x00	; 0
     a82:	40 e8       	ldi	r20, 0x80	; 128
     a84:	51 e4       	ldi	r21, 0x41	; 65
     a86:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
     a8a:	9b 01       	movw	r18, r22
     a8c:	ac 01       	movw	r20, r24
     a8e:	60 e0       	ldi	r22, 0x00	; 0
     a90:	74 e2       	ldi	r23, 0x24	; 36
     a92:	84 e7       	ldi	r24, 0x74	; 116
     a94:	9b e4       	ldi	r25, 0x4B	; 75
     a96:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <__divsf3>
     a9a:	20 e0       	ldi	r18, 0x00	; 0
     a9c:	30 e0       	ldi	r19, 0x00	; 0
     a9e:	40 e0       	ldi	r20, 0x00	; 0
     aa0:	5f e3       	ldi	r21, 0x3F	; 63
     aa2:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <__subsf3>
     aa6:	f6 2e       	mov	r15, r22
     aa8:	07 2f       	mov	r16, r23
     aaa:	18 2f       	mov	r17, r24
     aac:	d9 2f       	mov	r29, r25
		 }			 
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
     aae:	90 e0       	ldi	r25, 0x00	; 0
				   UBRR_Temp = (((float)F_CPU) / (8.0 * USART0.baudRate)) - 0.5; //to make sure that the output above o.5 will be 1 so we add 0.5 to -1-> in the equation
			  break;
			  
			  case USART_Asyn_SingleSpeed:
			       UBRR_Temp = (((float)F_CPU) / (16.0 * USART0.baudRate)) - 0.5;
			  break;
     ab0:	27 c0       	rjmp	.+78     	; 0xb00 <USART_Intia+0x11a>
			  
			  case USART_Sync:
			       UCSRC_Temp |= (1<<UMSEL);
				   UBRR_Temp = (((float)F_CPU) / (2.0 * USART0.baudRate)) - 0.5;
     ab2:	60 91 89 00 	lds	r22, 0x0089
     ab6:	70 91 8a 00 	lds	r23, 0x008A
     aba:	80 91 8b 00 	lds	r24, 0x008B
     abe:	90 91 8c 00 	lds	r25, 0x008C
     ac2:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <__floatunsisf>
     ac6:	9b 01       	movw	r18, r22
     ac8:	ac 01       	movw	r20, r24
     aca:	0e 94 e5 0e 	call	0x1dca	; 0x1dca <__addsf3>
     ace:	9b 01       	movw	r18, r22
     ad0:	ac 01       	movw	r20, r24
     ad2:	60 e0       	ldi	r22, 0x00	; 0
     ad4:	74 e2       	ldi	r23, 0x24	; 36
     ad6:	84 e7       	ldi	r24, 0x74	; 116
     ad8:	9b e4       	ldi	r25, 0x4B	; 75
     ada:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <__divsf3>
     ade:	20 e0       	ldi	r18, 0x00	; 0
     ae0:	30 e0       	ldi	r19, 0x00	; 0
     ae2:	40 e0       	ldi	r20, 0x00	; 0
     ae4:	5f e3       	ldi	r21, 0x3F	; 63
     ae6:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <__subsf3>
     aea:	f6 2e       	mov	r15, r22
     aec:	07 2f       	mov	r16, r23
     aee:	18 2f       	mov	r17, r24
     af0:	d9 2f       	mov	r29, r25
		 }			 
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
     af2:	90 e0       	ldi	r25, 0x00	; 0
     af4:	05 c0       	rjmp	.+10     	; 0xb00 <USART_Intia+0x11a>
		  unsigned char UCSRB_Temp = 0;
		  unsigned char UCSRC_Temp = 0;
		  float   UBRR_Temp = 0.0;
     af6:	ff 24       	eor	r15, r15
     af8:	00 e0       	ldi	r16, 0x00	; 0
     afa:	10 e0       	ldi	r17, 0x00	; 0
     afc:	d0 e0       	ldi	r29, 0x00	; 0
		 }			 
	 }
	
	  void USART_Intia(void)
	  {
		  unsigned char UCSRA_Temp = 0;
     afe:	90 e0       	ldi	r25, 0x00	; 0
			 break;
			  default:
			  break;
		  }
		  
		  switch(USART0.communicationTerminal)
     b00:	80 91 83 00 	lds	r24, 0x0083
     b04:	81 30       	cpi	r24, 0x01	; 1
     b06:	09 f4       	brne	.+2      	; 0xb0a <USART_Intia+0x124>
		  {
			  case USART_SingleProcessor:
			  break;
			  case USART_MultiProcessor:
			       UCSRA_Temp |= (1<<MPCM);
     b08:	91 60       	ori	r25, 0x01	; 1
			  break;
			  default:
			  break;
		  }
		  
		  switch (USART0.interruptSource)
     b0a:	80 91 84 00 	lds	r24, 0x0084
     b0e:	84 30       	cpi	r24, 0x04	; 4
     b10:	b1 f0       	breq	.+44     	; 0xb3e <USART_Intia+0x158>
     b12:	85 30       	cpi	r24, 0x05	; 5
     b14:	38 f4       	brcc	.+14     	; 0xb24 <USART_Intia+0x13e>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	71 f0       	breq	.+28     	; 0xb36 <USART_Intia+0x150>
     b1a:	83 30       	cpi	r24, 0x03	; 3
     b1c:	70 f4       	brcc	.+28     	; 0xb3a <USART_Intia+0x154>
     b1e:	81 30       	cpi	r24, 0x01	; 1
     b20:	a9 f4       	brne	.+42     	; 0xb4c <USART_Intia+0x166>
     b22:	07 c0       	rjmp	.+14     	; 0xb32 <USART_Intia+0x14c>
     b24:	86 30       	cpi	r24, 0x06	; 6
     b26:	79 f0       	breq	.+30     	; 0xb46 <USART_Intia+0x160>
     b28:	86 30       	cpi	r24, 0x06	; 6
     b2a:	58 f0       	brcs	.+22     	; 0xb42 <USART_Intia+0x15c>
     b2c:	87 30       	cpi	r24, 0x07	; 7
     b2e:	71 f4       	brne	.+28     	; 0xb4c <USART_Intia+0x166>
     b30:	0c c0       	rjmp	.+24     	; 0xb4a <USART_Intia+0x164>
		  {
		    case USART_InterruptsDisable:
		  	break;
			case USART_RxComInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE);
     b32:	c0 68       	ori	r28, 0x80	; 128
			break;
     b34:	0b c0       	rjmp	.+22     	; 0xb4c <USART_Intia+0x166>
			case USART_TxComInt_Enable:
			     UCSRB_Temp |= (1<<TXCIE);
     b36:	c0 64       	ori	r28, 0x40	; 64
			break;
     b38:	09 c0       	rjmp	.+18     	; 0xb4c <USART_Intia+0x166>
			case USART_UDRInt_Enable:
			     UCSRB_Temp |= (1<<UDRIE);
     b3a:	c0 62       	ori	r28, 0x20	; 32
			break;
     b3c:	07 c0       	rjmp	.+14     	; 0xb4c <USART_Intia+0x166>
			case USART_RxTxComInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE) | (1<<TXCIE);
     b3e:	c0 6c       	ori	r28, 0xC0	; 192
			break;
     b40:	05 c0       	rjmp	.+10     	; 0xb4c <USART_Intia+0x166>
			case USART_RxComUDRInt_Enable:
			     UCSRB_Temp |= (1<<RXCIE) | (1<<UDRIE);
     b42:	c0 6a       	ori	r28, 0xA0	; 160
			break;
     b44:	03 c0       	rjmp	.+6      	; 0xb4c <USART_Intia+0x166>
			case USART_TxComUDRInt_Enable:
			     UCSRB_Temp |= (1<<TXCIE) | (1<<UDRIE);
     b46:	c0 66       	ori	r28, 0x60	; 96
			break;
     b48:	01 c0       	rjmp	.+2      	; 0xb4c <USART_Intia+0x166>
			case USART_InterruptsEnable:
			     UCSRB_Temp |= (1<<TXCIE) | (1<<UDRIE) | (1<<RXCIE);
     b4a:	c0 6e       	ori	r28, 0xE0	; 224
			default:
			break;
		  }
		  
		  
		  switch(USART0.dataFrame)
     b4c:	80 91 85 00 	lds	r24, 0x0085
     b50:	84 30       	cpi	r24, 0x04	; 4
     b52:	09 f4       	brne	.+2      	; 0xb56 <USART_Intia+0x170>
			  case USART_8bitData:
			       UCSRC_Temp |= (1<<UCSZ0) | (1<<UCSZ1);
			  break;
			  case USART_9bitData:
			       UCSRC_Temp |= (1<<UCSZ0) | (1<<UCSZ1);
				   UCSRB_Temp |= (1<<UCSZ2);
     b54:	c4 60       	ori	r28, 0x04	; 4
			  default:
			  break;
		  }
		  
		  
		  UCSRA = UCSRA_Temp;
     b56:	9b b9       	out	0x0b, r25	; 11
		  UCSRC = UCSRB_Temp;
     b58:	c0 bd       	out	0x20, r28	; 32
		  UBRRH = ((unsigned short)UBRR_Temp)>>8;
     b5a:	8f 2d       	mov	r24, r15
     b5c:	90 2f       	mov	r25, r16
     b5e:	a1 2f       	mov	r26, r17
     b60:	bd 2f       	mov	r27, r29
     b62:	bc 01       	movw	r22, r24
     b64:	cd 01       	movw	r24, r26
     b66:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <__fixunssfsi>
     b6a:	70 bd       	out	0x20, r23	; 32
		  UBRRL = ((unsigned char)UBRR_Temp);
     b6c:	8f 2d       	mov	r24, r15
     b6e:	90 2f       	mov	r25, r16
     b70:	a1 2f       	mov	r26, r17
     b72:	bd 2f       	mov	r27, r29
     b74:	bc 01       	movw	r22, r24
     b76:	cd 01       	movw	r24, r26
     b78:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <__fixunssfsi>
     b7c:	69 b9       	out	0x09, r22	; 9
		  UCSRB = UCSRB_Temp; //put in the last because on it the enable bit of the UART
     b7e:	ca b9       	out	0x0a, r28	; 10
		  		  
	  }
     b80:	df 91       	pop	r29
     b82:	cf 91       	pop	r28
     b84:	1f 91       	pop	r17
     b86:	0f 91       	pop	r16
     b88:	ff 90       	pop	r15
     b8a:	08 95       	ret

00000b8c <USART_SendByte_Blocking>:
	  
	  void USART_SendByte_Blocking(unsigned short Data)
	  {
		  while ((UCSRA & (1<<UDRE)) == 0)
     b8c:	5d 9b       	sbis	0x0b, 5	; 11
     b8e:	fe cf       	rjmp	.-4      	; 0xb8c <USART_SendByte_Blocking>
		  {
			  /* this to blocking on the bit UDRE until it change to 1 to start transmit*/
		  }
		  if (USART0.dataFrame == USART_9bitData)
     b90:	20 91 85 00 	lds	r18, 0x0085
     b94:	24 30       	cpi	r18, 0x04	; 4
     b96:	41 f4       	brne	.+16     	; 0xba8 <USART_SendByte_Blocking+0x1c>
			  /*
			   * UCSRB & 1111 1110 to make sure the bit 0 is reset to hold the new value because it does not mention in data sheet
			   * we need to take the bit 9  in the data and hold it in the bit 0  in the UCSRB so we & the data with 8 to get 
			   *  and shift it again to put in the position of the bit 0
			   */ 
			  UCSRB = (UCSRB & 0xFE) | ((Data & (1<<8))>>8);
     b98:	4a b1       	in	r20, 0x0a	; 10
     b9a:	9c 01       	movw	r18, r24
     b9c:	20 70       	andi	r18, 0x00	; 0
     b9e:	31 70       	andi	r19, 0x01	; 1
     ba0:	24 2f       	mov	r18, r20
     ba2:	2e 7f       	andi	r18, 0xFE	; 254
     ba4:	23 2b       	or	r18, r19
     ba6:	2a b9       	out	0x0a, r18	; 10
		  }
		  /* casting the data to char to get only the 8 bit */
		  UDR = (unsigned char) Data;
     ba8:	8c b9       	out	0x0c, r24	; 12
	  }
     baa:	08 95       	ret

00000bac <USART_SendByte_NoneBlocking>:
	  
	  /* this function is use in case called by interrupt */
	  void USART_SendByte_NoneBlocking(unsigned short Data)
	  {
		  if ((UCSRA & (1<<UDRE)) != 0)
     bac:	5d 9b       	sbis	0x0b, 5	; 11
     bae:	0d c0       	rjmp	.+26     	; 0xbca <USART_SendByte_NoneBlocking+0x1e>
		  {
			
			  if (USART0.dataFrame == USART_9bitData)
     bb0:	20 91 85 00 	lds	r18, 0x0085
     bb4:	24 30       	cpi	r18, 0x04	; 4
     bb6:	41 f4       	brne	.+16     	; 0xbc8 <USART_SendByte_NoneBlocking+0x1c>
				  /*
				   * UCSRB & 1111 1110 to make sure the bit 0 is reset to hold the new value because it does not mention in data sheet
				   * we need to take the bit 9  in the data and hold it in the bit 0  in the UCSRB so we & the data with 8 to get 
					   and shift it again to put in the position of the bit 0
				  */ 
				  UCSRB = (UCSRB & 0xFE) | ((Data & (1<<8))>>8);
     bb8:	4a b1       	in	r20, 0x0a	; 10
     bba:	9c 01       	movw	r18, r24
     bbc:	20 70       	andi	r18, 0x00	; 0
     bbe:	31 70       	andi	r19, 0x01	; 1
     bc0:	24 2f       	mov	r18, r20
     bc2:	2e 7f       	andi	r18, 0xFE	; 254
     bc4:	23 2b       	or	r18, r19
     bc6:	2a b9       	out	0x0a, r18	; 10
			  }
			  /* casting the data to char to get only the 8 bit */
			  UDR = (unsigned char) Data;
     bc8:	8c b9       	out	0x0c, r24	; 12
     bca:	08 95       	ret

00000bcc <USART_ReadByte_Blocking>:
	  unsigned short USART_ReadByte_Blocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
		  
		  while ((UCSRA & (1<<RXC)) == 0)
     bcc:	5f 9b       	sbis	0x0b, 7	; 11
     bce:	fe cf       	rjmp	.-4      	; 0xbcc <USART_ReadByte_Blocking>
		  {
			  /* this flag set when there was unread data in the receive buffer so we blocking until it set */ 
		  }
		  
		  if (UCSRA & ((1<<FE) | (1<<DOR) | (1<<PE)))
     bd0:	8b b1       	in	r24, 0x0b	; 11
     bd2:	8c 71       	andi	r24, 0x1C	; 28
     bd4:	89 f0       	breq	.+34     	; 0xbf8 <USART_ReadByte_Blocking+0x2c>
		  {
			  /* error handle as you wish */
			  if(UCSRA & (1<<FE))
     bd6:	5c 9b       	sbis	0x0b, 4	; 11
     bd8:	04 c0       	rjmp	.+8      	; 0xbe2 <USART_ReadByte_Blocking+0x16>
			  {
				  USART0.errorType = USART_FrameError;
     bda:	83 e0       	ldi	r24, 0x03	; 3
     bdc:	80 93 88 00 	sts	0x0088, r24
     be0:	0b c0       	rjmp	.+22     	; 0xbf8 <USART_ReadByte_Blocking+0x2c>
			  }	
			  else if(UCSRA & (1<<DOR))
     be2:	5b 9b       	sbis	0x0b, 3	; 11
     be4:	04 c0       	rjmp	.+8      	; 0xbee <USART_ReadByte_Blocking+0x22>
			  {
				  USART0.errorType = USART_OverRunError;
     be6:	82 e0       	ldi	r24, 0x02	; 2
     be8:	80 93 88 00 	sts	0x0088, r24
     bec:	05 c0       	rjmp	.+10     	; 0xbf8 <USART_ReadByte_Blocking+0x2c>
			  }
			  else if(UCSRA & (1<<PE))
     bee:	5a 9b       	sbis	0x0b, 2	; 11
     bf0:	03 c0       	rjmp	.+6      	; 0xbf8 <USART_ReadByte_Blocking+0x2c>
			  {
				  USART0.errorType = USART_ParityError;
     bf2:	81 e0       	ldi	r24, 0x01	; 1
     bf4:	80 93 88 00 	sts	0x0088, r24
			  }
			  			  
		  }
		  
		  if(USART0.dataFrame == USART_9bitData)
     bf8:	80 91 85 00 	lds	r24, 0x0085
     bfc:	84 30       	cpi	r24, 0x04	; 4
     bfe:	51 f4       	brne	.+20     	; 0xc14 <USART_ReadByte_Blocking+0x48>
		  {
			  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
			  RxData = ((UCSRB & (1<<RXB8)) << 7);
     c00:	8a b1       	in	r24, 0x0a	; 10
     c02:	90 e0       	ldi	r25, 0x00	; 0
     c04:	82 70       	andi	r24, 0x02	; 2
     c06:	90 70       	andi	r25, 0x00	; 0
     c08:	96 95       	lsr	r25
     c0a:	98 2f       	mov	r25, r24
     c0c:	88 27       	eor	r24, r24
     c0e:	97 95       	ror	r25
     c10:	87 95       	ror	r24
     c12:	02 c0       	rjmp	.+4      	; 0xc18 <USART_ReadByte_Blocking+0x4c>
	  }
	  
	  unsigned short USART_ReadByte_Blocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
     c14:	80 e0       	ldi	r24, 0x00	; 0
     c16:	90 e0       	ldi	r25, 0x00	; 0
		  {
			  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
			  RxData = ((UCSRB & (1<<RXB8)) << 7);
		  }
		  
		  RxData |= UDR;
     c18:	2c b1       	in	r18, 0x0c	; 12
     c1a:	30 e0       	ldi	r19, 0x00	; 0
     c1c:	82 2b       	or	r24, r18
     c1e:	93 2b       	or	r25, r19
		  return RxData;
		  
	  }
     c20:	08 95       	ret

00000c22 <USART_ReadByte_NoneBlocking>:
	  unsigned short USART_ReadByte_NoneBlocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
		  
		  if ((UCSRA & (1<<RXC)) != 0)
     c22:	5f 9b       	sbis	0x0b, 7	; 11
     c24:	22 c0       	rjmp	.+68     	; 0xc6a <USART_ReadByte_NoneBlocking+0x48>
		  {
		  
			  if (UCSRA & ((1<<FE) | (1<<DOR) | (1<<PE)))
     c26:	8b b1       	in	r24, 0x0b	; 11
     c28:	8c 71       	andi	r24, 0x1C	; 28
     c2a:	89 f0       	breq	.+34     	; 0xc4e <USART_ReadByte_NoneBlocking+0x2c>
			  {
				  /* error handle as you wish */
				  if(UCSRA & (1<<FE))
     c2c:	5c 9b       	sbis	0x0b, 4	; 11
     c2e:	04 c0       	rjmp	.+8      	; 0xc38 <USART_ReadByte_NoneBlocking+0x16>
				  {
					  USART0.errorType = USART_FrameError;
     c30:	83 e0       	ldi	r24, 0x03	; 3
     c32:	80 93 88 00 	sts	0x0088, r24
     c36:	0b c0       	rjmp	.+22     	; 0xc4e <USART_ReadByte_NoneBlocking+0x2c>
				  }
				  else if(UCSRA & (1<<DOR))
     c38:	5b 9b       	sbis	0x0b, 3	; 11
     c3a:	04 c0       	rjmp	.+8      	; 0xc44 <USART_ReadByte_NoneBlocking+0x22>
				  {
					  USART0.errorType = USART_OverRunError;
     c3c:	82 e0       	ldi	r24, 0x02	; 2
     c3e:	80 93 88 00 	sts	0x0088, r24
     c42:	05 c0       	rjmp	.+10     	; 0xc4e <USART_ReadByte_NoneBlocking+0x2c>
				  }
				  else if(UCSRA & (1<<PE))
     c44:	5a 9b       	sbis	0x0b, 2	; 11
     c46:	03 c0       	rjmp	.+6      	; 0xc4e <USART_ReadByte_NoneBlocking+0x2c>
				  {
					  USART0.errorType = USART_ParityError;
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	80 93 88 00 	sts	0x0088, r24
				  }
			  
			  }
		  
			  if(USART0.dataFrame == USART_9bitData)
     c4e:	80 91 85 00 	lds	r24, 0x0085
     c52:	84 30       	cpi	r24, 0x04	; 4
     c54:	69 f4       	brne	.+26     	; 0xc70 <USART_ReadByte_NoneBlocking+0x4e>
			  {
				  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
				  RxData = ((UCSRB & (1<<RXB8)) << 7);
     c56:	8a b1       	in	r24, 0x0a	; 10
     c58:	90 e0       	ldi	r25, 0x00	; 0
     c5a:	82 70       	andi	r24, 0x02	; 2
     c5c:	90 70       	andi	r25, 0x00	; 0
     c5e:	96 95       	lsr	r25
     c60:	98 2f       	mov	r25, r24
     c62:	88 27       	eor	r24, r24
     c64:	97 95       	ror	r25
     c66:	87 95       	ror	r24
     c68:	05 c0       	rjmp	.+10     	; 0xc74 <USART_ReadByte_NoneBlocking+0x52>
	  
	  
	  unsigned short USART_ReadByte_NoneBlocking(void)
	  {
		  /* this variable to hold the 9bit data */
		  unsigned short RxData = 0x00;
     c6a:	80 e0       	ldi	r24, 0x00	; 0
     c6c:	90 e0       	ldi	r25, 0x00	; 0
     c6e:	02 c0       	rjmp	.+4      	; 0xc74 <USART_ReadByte_NoneBlocking+0x52>
     c70:	80 e0       	ldi	r24, 0x00	; 0
     c72:	90 e0       	ldi	r25, 0x00	; 0
				  /* get the 9bit from the bit 1 in the UCSRB then shift it to left by 7 to hold in 9bit */
				  RxData = ((UCSRB & (1<<RXB8)) << 7);
			  }
		  }			
		  
			RxData |= UDR;
     c74:	2c b1       	in	r18, 0x0c	; 12
     c76:	30 e0       	ldi	r19, 0x00	; 0
     c78:	82 2b       	or	r24, r18
     c7a:	93 2b       	or	r25, r19
			return RxData;
		 	  
		  
     c7c:	08 95       	ret

00000c7e <sevenSegment_setup>:
  #define bit_2_num (2)
  #define bit_3_num (3)
  
  
  void sevenSegment_setup(SevenSegment pins)
  {
     c7e:	0f 93       	push	r16
     c80:	1f 93       	push	r17
     c82:	cf 93       	push	r28
     c84:	df 93       	push	r29
     c86:	00 d0       	rcall	.+0      	; 0xc88 <sevenSegment_setup+0xa>
     c88:	00 d0       	rcall	.+0      	; 0xc8a <sevenSegment_setup+0xc>
     c8a:	00 d0       	rcall	.+0      	; 0xc8c <sevenSegment_setup+0xe>
     c8c:	cd b7       	in	r28, 0x3d	; 61
     c8e:	de b7       	in	r29, 0x3e	; 62
     c90:	49 83       	std	Y+1, r20	; 0x01
     c92:	5a 83       	std	Y+2, r21	; 0x02
     c94:	6b 83       	std	Y+3, r22	; 0x03
     c96:	7c 83       	std	Y+4, r23	; 0x04
     c98:	8d 83       	std	Y+5, r24	; 0x05
     c9a:	9e 83       	std	Y+6, r25	; 0x06
     c9c:	09 81       	ldd	r16, Y+1	; 0x01
     c9e:	1a 81       	ldd	r17, Y+2	; 0x02
	  /* define The Pins Of The BCD IC As Output Pins */
	  DIO_pinConfiguration(pins.drivPORT,pins.Apin,Output);
     ca0:	c8 01       	movw	r24, r16
     ca2:	42 e0       	ldi	r20, 0x02	; 2
     ca4:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Bpin,Output);
     ca8:	c8 01       	movw	r24, r16
     caa:	6c 81       	ldd	r22, Y+4	; 0x04
     cac:	42 e0       	ldi	r20, 0x02	; 2
     cae:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Cpin,Output);
     cb2:	c8 01       	movw	r24, r16
     cb4:	6d 81       	ldd	r22, Y+5	; 0x05
     cb6:	42 e0       	ldi	r20, 0x02	; 2
     cb8:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  DIO_pinConfiguration(pins.drivPORT,pins.Dpin,Output);
     cbc:	c8 01       	movw	r24, r16
     cbe:	6e 81       	ldd	r22, Y+6	; 0x06
     cc0:	42 e0       	ldi	r20, 0x02	; 2
     cc2:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
  }
     cc6:	26 96       	adiw	r28, 0x06	; 6
     cc8:	0f b6       	in	r0, 0x3f	; 63
     cca:	f8 94       	cli
     ccc:	de bf       	out	0x3e, r29	; 62
     cce:	0f be       	out	0x3f, r0	; 63
     cd0:	cd bf       	out	0x3d, r28	; 61
     cd2:	df 91       	pop	r29
     cd4:	cf 91       	pop	r28
     cd6:	1f 91       	pop	r17
     cd8:	0f 91       	pop	r16
     cda:	08 95       	ret

00000cdc <sevenSegment_write>:
  
  
  void sevenSegment_write(SevenSegment pins, unsigned char number)
  {
     cdc:	ef 92       	push	r14
     cde:	ff 92       	push	r15
     ce0:	0f 93       	push	r16
     ce2:	1f 93       	push	r17
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	00 d0       	rcall	.+0      	; 0xcea <sevenSegment_write+0xe>
     cea:	00 d0       	rcall	.+0      	; 0xcec <sevenSegment_write+0x10>
     cec:	00 d0       	rcall	.+0      	; 0xcee <sevenSegment_write+0x12>
     cee:	cd b7       	in	r28, 0x3d	; 61
     cf0:	de b7       	in	r29, 0x3e	; 62
     cf2:	49 83       	std	Y+1, r20	; 0x01
     cf4:	5a 83       	std	Y+2, r21	; 0x02
     cf6:	6b 83       	std	Y+3, r22	; 0x03
     cf8:	7c 83       	std	Y+4, r23	; 0x04
     cfa:	8d 83       	std	Y+5, r24	; 0x05
     cfc:	9e 83       	std	Y+6, r25	; 0x06
     cfe:	12 2f       	mov	r17, r18
     d00:	e9 80       	ldd	r14, Y+1	; 0x01
     d02:	fa 80       	ldd	r15, Y+2	; 0x02
	  /* read The Bit Zero from The Number And represent By The Pin A */
	  DIO_pinWrite(pins.drivPORT,pins.Apin, (READ_Bit(number,bit_0_num)));
     d04:	42 2f       	mov	r20, r18
     d06:	41 70       	andi	r20, 0x01	; 1
     d08:	c7 01       	movw	r24, r14
     d0a:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
	  /* read The Bit 1 from The Number And represent By The Pin B */
	  DIO_pinWrite(pins.drivPORT,pins.Bpin, (READ_Bit(number,bit_1_num)));
     d0e:	01 2f       	mov	r16, r17
     d10:	10 e0       	ldi	r17, 0x00	; 0
     d12:	a8 01       	movw	r20, r16
     d14:	42 70       	andi	r20, 0x02	; 2
     d16:	50 70       	andi	r21, 0x00	; 0
     d18:	55 95       	asr	r21
     d1a:	47 95       	ror	r20
     d1c:	c7 01       	movw	r24, r14
     d1e:	6c 81       	ldd	r22, Y+4	; 0x04
     d20:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
	  /* read The Bit 2 from The Number And represent By The Pin C */
	  DIO_pinWrite(pins.drivPORT,pins.Cpin, (READ_Bit(number,bit_2_num)));
     d24:	a8 01       	movw	r20, r16
     d26:	44 70       	andi	r20, 0x04	; 4
     d28:	50 70       	andi	r21, 0x00	; 0
     d2a:	55 95       	asr	r21
     d2c:	47 95       	ror	r20
     d2e:	55 95       	asr	r21
     d30:	47 95       	ror	r20
     d32:	c7 01       	movw	r24, r14
     d34:	6d 81       	ldd	r22, Y+5	; 0x05
     d36:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
	  /* read The Bit 3 from The Number And represent By The Pin D */
	  DIO_pinWrite(pins.drivPORT,pins.Dpin, (READ_Bit(number,bit_3_num)));
     d3a:	08 70       	andi	r16, 0x08	; 8
     d3c:	10 70       	andi	r17, 0x00	; 0
     d3e:	a8 01       	movw	r20, r16
     d40:	55 95       	asr	r21
     d42:	47 95       	ror	r20
     d44:	55 95       	asr	r21
     d46:	47 95       	ror	r20
     d48:	55 95       	asr	r21
     d4a:	47 95       	ror	r20
     d4c:	c7 01       	movw	r24, r14
     d4e:	6e 81       	ldd	r22, Y+6	; 0x06
     d50:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
     d54:	26 96       	adiw	r28, 0x06	; 6
     d56:	0f b6       	in	r0, 0x3f	; 63
     d58:	f8 94       	cli
     d5a:	de bf       	out	0x3e, r29	; 62
     d5c:	0f be       	out	0x3f, r0	; 63
     d5e:	cd bf       	out	0x3d, r28	; 61
     d60:	df 91       	pop	r29
     d62:	cf 91       	pop	r28
     d64:	1f 91       	pop	r17
     d66:	0f 91       	pop	r16
     d68:	ff 90       	pop	r15
     d6a:	ef 90       	pop	r14
     d6c:	08 95       	ret

00000d6e <BUZZER_Setup>:
  #define PEP_DELAY (100)
  
  
  
  void BUZZER_Setup (BUZZER_dataType buz)
  {
     d6e:	cf 93       	push	r28
     d70:	df 93       	push	r29
     d72:	00 d0       	rcall	.+0      	; 0xd74 <BUZZER_Setup+0x6>
     d74:	0f 92       	push	r0
     d76:	cd b7       	in	r28, 0x3d	; 61
     d78:	de b7       	in	r29, 0x3e	; 62
     d7a:	69 83       	std	Y+1, r22	; 0x01
     d7c:	7a 83       	std	Y+2, r23	; 0x02
     d7e:	68 2f       	mov	r22, r24
     d80:	8b 83       	std	Y+3, r24	; 0x03
	  /* Configuration The Pin Of The Buzzer As Output Pin */
	  DIO_pinConfiguration(buz.buzzerPORT,buz.buzzerPIN,Output);
     d82:	89 81       	ldd	r24, Y+1	; 0x01
     d84:	9a 81       	ldd	r25, Y+2	; 0x02
     d86:	42 e0       	ldi	r20, 0x02	; 2
     d88:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
  }
     d8c:	0f 90       	pop	r0
     d8e:	0f 90       	pop	r0
     d90:	0f 90       	pop	r0
     d92:	df 91       	pop	r29
     d94:	cf 91       	pop	r28
     d96:	08 95       	ret

00000d98 <BUZZER_ALARM>:
  
  
  void BUZZER_ALARM(BUZZER_dataType buz)
  {
     d98:	ef 92       	push	r14
     d9a:	ff 92       	push	r15
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	00 d0       	rcall	.+0      	; 0xda4 <BUZZER_ALARM+0xc>
     da4:	0f 92       	push	r0
     da6:	cd b7       	in	r28, 0x3d	; 61
     da8:	de b7       	in	r29, 0x3e	; 62
     daa:	69 83       	std	Y+1, r22	; 0x01
     dac:	7a 83       	std	Y+2, r23	; 0x02
     dae:	8b 83       	std	Y+3, r24	; 0x03
     db0:	e9 80       	ldd	r14, Y+1	; 0x01
     db2:	fa 80       	ldd	r15, Y+2	; 0x02
     db4:	18 2f       	mov	r17, r24
	  /* That Make A sequence Of PeP By On an Off THe Buzzer */
	  DIO_pinWrite(buz.buzzerPORT, buz.buzzerPIN, HIGH);
     db6:	c7 01       	movw	r24, r14
     db8:	61 2f       	mov	r22, r17
     dba:	41 e0       	ldi	r20, 0x01	; 1
     dbc:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     dc0:	8f ef       	ldi	r24, 0xFF	; 255
     dc2:	91 ee       	ldi	r25, 0xE1	; 225
     dc4:	a4 e0       	ldi	r26, 0x04	; 4
     dc6:	81 50       	subi	r24, 0x01	; 1
     dc8:	90 40       	sbci	r25, 0x00	; 0
     dca:	a0 40       	sbci	r26, 0x00	; 0
     dcc:	e1 f7       	brne	.-8      	; 0xdc6 <BUZZER_ALARM+0x2e>
     dce:	00 c0       	rjmp	.+0      	; 0xdd0 <BUZZER_ALARM+0x38>
     dd0:	00 00       	nop
	  _delay_ms(PEP_DELAY);
	  DIO_pinWrite(buz.buzzerPORT, buz.buzzerPIN, LOW);
     dd2:	c7 01       	movw	r24, r14
     dd4:	61 2f       	mov	r22, r17
     dd6:	40 e0       	ldi	r20, 0x00	; 0
     dd8:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
     ddc:	8f ef       	ldi	r24, 0xFF	; 255
     dde:	91 ee       	ldi	r25, 0xE1	; 225
     de0:	a4 e0       	ldi	r26, 0x04	; 4
     de2:	81 50       	subi	r24, 0x01	; 1
     de4:	90 40       	sbci	r25, 0x00	; 0
     de6:	a0 40       	sbci	r26, 0x00	; 0
     de8:	e1 f7       	brne	.-8      	; 0xde2 <BUZZER_ALARM+0x4a>
     dea:	00 c0       	rjmp	.+0      	; 0xdec <BUZZER_ALARM+0x54>
     dec:	00 00       	nop
	  _delay_ms(PEP_DELAY);
     dee:	0f 90       	pop	r0
     df0:	0f 90       	pop	r0
     df2:	0f 90       	pop	r0
     df4:	df 91       	pop	r29
     df6:	cf 91       	pop	r28
     df8:	1f 91       	pop	r17
     dfa:	ff 90       	pop	r15
     dfc:	ef 90       	pop	r14
     dfe:	08 95       	ret

00000e00 <sensor_setup>:
   #include <IndicatorSensor.h>
   
   
   
   void sensor_setup(indecationSensor_dataType sensor)
   {
     e00:	28 2f       	mov	r18, r24
	   /* Configuration The PinOf The Sensor As an Input Pull up Pin So It default Is LOW */
	   DIO_pinConfiguration(sensor.sensorPORT, sensor.sensorPIN, InputFloat);
     e02:	86 2f       	mov	r24, r22
     e04:	97 2f       	mov	r25, r23
     e06:	62 2f       	mov	r22, r18
     e08:	40 e0       	ldi	r20, 0x00	; 0
     e0a:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
   }
     e0e:	08 95       	ret

00000e10 <sensor_operate>:
   
   
   
   DigitalValue sensor_operate(indecationSensor_dataType sensor)
   {
     e10:	28 2f       	mov	r18, r24
	   /* read The Pin State Refer To The Condition OfThe sensor If It Indicate Will return High Else Will Return LOW */ 
	   return ( DIO_pinRead(sensor.sensorPORT, sensor.sensorPIN) );
     e12:	86 2f       	mov	r24, r22
     e14:	97 2f       	mov	r25, r23
     e16:	62 2f       	mov	r22, r18
     e18:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     e1c:	08 95       	ret

00000e1e <CheckData>:
	
	
	 
 /* This is an static function to check the value of the current data get from the keypad key */
 static unsigned char CheckData(KEYPAD_PIN keypad,MATRIX_COL col )
 {
     e1e:	bf 92       	push	r11
     e20:	cf 92       	push	r12
     e22:	df 92       	push	r13
     e24:	ef 92       	push	r14
     e26:	ff 92       	push	r15
     e28:	0f 93       	push	r16
     e2a:	1f 93       	push	r17
     e2c:	cf 93       	push	r28
     e2e:	df 93       	push	r29
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
     e34:	2a 97       	sbiw	r28, 0x0a	; 10
     e36:	0f b6       	in	r0, 0x3f	; 63
     e38:	f8 94       	cli
     e3a:	de bf       	out	0x3e, r29	; 62
     e3c:	0f be       	out	0x3f, r0	; 63
     e3e:	cd bf       	out	0x3d, r28	; 61
     e40:	09 83       	std	Y+1, r16	; 0x01
     e42:	1a 83       	std	Y+2, r17	; 0x02
     e44:	f2 2e       	mov	r15, r18
     e46:	2b 83       	std	Y+3, r18	; 0x03
     e48:	d3 2e       	mov	r13, r19
     e4a:	3c 83       	std	Y+4, r19	; 0x04
     e4c:	c4 2e       	mov	r12, r20
     e4e:	4d 83       	std	Y+5, r20	; 0x05
     e50:	b5 2e       	mov	r11, r21
     e52:	5e 83       	std	Y+6, r21	; 0x06
     e54:	6f 83       	std	Y+7, r22	; 0x07
     e56:	78 87       	std	Y+8, r23	; 0x08
     e58:	89 87       	std	Y+9, r24	; 0x09
     e5a:	9a 87       	std	Y+10, r25	; 0x0a
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
		 {
			 return(KeyData[ROW4][col]);
		 }
	 }
	 return 0;
     e5c:	09 81       	ldd	r16, Y+1	; 0x01
     e5e:	1a 81       	ldd	r17, Y+2	; 0x02
	 
 /* This is an static function to check the value of the current data get from the keypad key */
 static unsigned char CheckData(KEYPAD_PIN keypad,MATRIX_COL col )
 {
	 /* Each time We Check If The User Is Push The button by Check the value get on The Raw Pin if HIGH the button pushed else we check the other Raw */ 
	 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW1))
     e60:	c8 01       	movw	r24, r16
     e62:	62 2f       	mov	r22, r18
     e64:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     e68:	88 23       	and	r24, r24
     e6a:	b1 f0       	breq	.+44     	; 0xe98 <CheckData+0x7a>
     e6c:	8f e7       	ldi	r24, 0x7F	; 127
     e6e:	92 e3       	ldi	r25, 0x32	; 50
     e70:	a2 e0       	ldi	r26, 0x02	; 2
     e72:	81 50       	subi	r24, 0x01	; 1
     e74:	90 40       	sbci	r25, 0x00	; 0
     e76:	a0 40       	sbci	r26, 0x00	; 0
     e78:	e1 f7       	brne	.-8      	; 0xe72 <CheckData+0x54>
     e7a:	00 c0       	rjmp	.+0      	; 0xe7c <CheckData+0x5e>
     e7c:	00 00       	nop
	 {
		 /* wait Time Delay and recheck the condition of the Raw pin to Make Sure The Is Not An Noise */
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW1))
     e7e:	c8 01       	movw	r24, r16
     e80:	6f 2d       	mov	r22, r15
     e82:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     e86:	88 23       	and	r24, r24
     e88:	09 f4       	brne	.+2      	; 0xe8c <CheckData+0x6e>
     e8a:	57 c0       	rjmp	.+174    	; 0xf3a <CheckData+0x11c>
		 {
			 /* We Match the Value Get From The REad Function Of The Number Of The Column And The Number Of The Raw We Get Here To Get The Value From The Matrix */
			return(KeyData[ROW1][col]);
     e8c:	e3 e9       	ldi	r30, 0x93	; 147
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	ee 0d       	add	r30, r14
     e92:	f1 1d       	adc	r31, r1
     e94:	80 81       	ld	r24, Z
     e96:	5a c0       	rjmp	.+180    	; 0xf4c <CheckData+0x12e>
		 }			 
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW2))
     e98:	c8 01       	movw	r24, r16
     e9a:	6d 2d       	mov	r22, r13
     e9c:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     ea0:	88 23       	and	r24, r24
     ea2:	a9 f0       	breq	.+42     	; 0xece <CheckData+0xb0>
     ea4:	8f e7       	ldi	r24, 0x7F	; 127
     ea6:	92 e3       	ldi	r25, 0x32	; 50
     ea8:	a2 e0       	ldi	r26, 0x02	; 2
     eaa:	81 50       	subi	r24, 0x01	; 1
     eac:	90 40       	sbci	r25, 0x00	; 0
     eae:	a0 40       	sbci	r26, 0x00	; 0
     eb0:	e1 f7       	brne	.-8      	; 0xeaa <CheckData+0x8c>
     eb2:	00 c0       	rjmp	.+0      	; 0xeb4 <CheckData+0x96>
     eb4:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW2))
     eb6:	c8 01       	movw	r24, r16
     eb8:	6d 2d       	mov	r22, r13
     eba:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     ebe:	88 23       	and	r24, r24
     ec0:	f1 f1       	breq	.+124    	; 0xf3e <CheckData+0x120>
		 {
			  return(KeyData[ROW2][col]);
     ec2:	e3 e9       	ldi	r30, 0x93	; 147
     ec4:	f0 e0       	ldi	r31, 0x00	; 0
     ec6:	ee 0d       	add	r30, r14
     ec8:	f1 1d       	adc	r31, r1
     eca:	84 81       	ldd	r24, Z+4	; 0x04
     ecc:	3f c0       	rjmp	.+126    	; 0xf4c <CheckData+0x12e>
		 }
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW3))
     ece:	c8 01       	movw	r24, r16
     ed0:	6c 2d       	mov	r22, r12
     ed2:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     ed6:	88 23       	and	r24, r24
     ed8:	a9 f0       	breq	.+42     	; 0xf04 <CheckData+0xe6>
     eda:	8f e7       	ldi	r24, 0x7F	; 127
     edc:	92 e3       	ldi	r25, 0x32	; 50
     ede:	a2 e0       	ldi	r26, 0x02	; 2
     ee0:	81 50       	subi	r24, 0x01	; 1
     ee2:	90 40       	sbci	r25, 0x00	; 0
     ee4:	a0 40       	sbci	r26, 0x00	; 0
     ee6:	e1 f7       	brne	.-8      	; 0xee0 <CheckData+0xc2>
     ee8:	00 c0       	rjmp	.+0      	; 0xeea <CheckData+0xcc>
     eea:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW3))
     eec:	c8 01       	movw	r24, r16
     eee:	6c 2d       	mov	r22, r12
     ef0:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     ef4:	88 23       	and	r24, r24
     ef6:	29 f1       	breq	.+74     	; 0xf42 <CheckData+0x124>
		 {
			return(KeyData[ROW3][col]);
     ef8:	e3 e9       	ldi	r30, 0x93	; 147
     efa:	f0 e0       	ldi	r31, 0x00	; 0
     efc:	ee 0d       	add	r30, r14
     efe:	f1 1d       	adc	r31, r1
     f00:	80 85       	ldd	r24, Z+8	; 0x08
     f02:	24 c0       	rjmp	.+72     	; 0xf4c <CheckData+0x12e>
		 }
	 }
	 else if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
     f04:	c8 01       	movw	r24, r16
     f06:	6b 2d       	mov	r22, r11
     f08:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     f0c:	88 23       	and	r24, r24
     f0e:	d9 f0       	breq	.+54     	; 0xf46 <CheckData+0x128>
     f10:	8f e7       	ldi	r24, 0x7F	; 127
     f12:	92 e3       	ldi	r25, 0x32	; 50
     f14:	a2 e0       	ldi	r26, 0x02	; 2
     f16:	81 50       	subi	r24, 0x01	; 1
     f18:	90 40       	sbci	r25, 0x00	; 0
     f1a:	a0 40       	sbci	r26, 0x00	; 0
     f1c:	e1 f7       	brne	.-8      	; 0xf16 <CheckData+0xf8>
     f1e:	00 c0       	rjmp	.+0      	; 0xf20 <CheckData+0x102>
     f20:	00 00       	nop
	 {
		 _delay_ms(DELAY_FOR_BOUNCING);
		 if (DIO_pinRead(keypad.keypadREG_Port,keypad.PINRW4))
     f22:	c8 01       	movw	r24, r16
     f24:	6b 2d       	mov	r22, r11
     f26:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
     f2a:	88 23       	and	r24, r24
     f2c:	71 f0       	breq	.+28     	; 0xf4a <CheckData+0x12c>
		 {
			 return(KeyData[ROW4][col]);
     f2e:	e3 e9       	ldi	r30, 0x93	; 147
     f30:	f0 e0       	ldi	r31, 0x00	; 0
     f32:	ee 0d       	add	r30, r14
     f34:	f1 1d       	adc	r31, r1
     f36:	84 85       	ldd	r24, Z+12	; 0x0c
     f38:	09 c0       	rjmp	.+18     	; 0xf4c <CheckData+0x12e>
		 }
	 }
	 return 0;
     f3a:	80 e0       	ldi	r24, 0x00	; 0
     f3c:	07 c0       	rjmp	.+14     	; 0xf4c <CheckData+0x12e>
     f3e:	80 e0       	ldi	r24, 0x00	; 0
     f40:	05 c0       	rjmp	.+10     	; 0xf4c <CheckData+0x12e>
     f42:	80 e0       	ldi	r24, 0x00	; 0
     f44:	03 c0       	rjmp	.+6      	; 0xf4c <CheckData+0x12e>
     f46:	80 e0       	ldi	r24, 0x00	; 0
     f48:	01 c0       	rjmp	.+2      	; 0xf4c <CheckData+0x12e>
     f4a:	80 e0       	ldi	r24, 0x00	; 0
	 
 }
     f4c:	2a 96       	adiw	r28, 0x0a	; 10
     f4e:	0f b6       	in	r0, 0x3f	; 63
     f50:	f8 94       	cli
     f52:	de bf       	out	0x3e, r29	; 62
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	cd bf       	out	0x3d, r28	; 61
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	1f 91       	pop	r17
     f5e:	0f 91       	pop	r16
     f60:	ff 90       	pop	r15
     f62:	ef 90       	pop	r14
     f64:	df 90       	pop	r13
     f66:	cf 90       	pop	r12
     f68:	bf 90       	pop	r11
     f6a:	08 95       	ret

00000f6c <keypad_Intiat>:
 
 void keypad_Intiat (KEYPAD_PIN keypad)
 {
     f6c:	0f 93       	push	r16
     f6e:	1f 93       	push	r17
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
     f74:	cd b7       	in	r28, 0x3d	; 61
     f76:	de b7       	in	r29, 0x3e	; 62
     f78:	2a 97       	sbiw	r28, 0x0a	; 10
     f7a:	0f b6       	in	r0, 0x3f	; 63
     f7c:	f8 94       	cli
     f7e:	de bf       	out	0x3e, r29	; 62
     f80:	0f be       	out	0x3f, r0	; 63
     f82:	cd bf       	out	0x3d, r28	; 61
     f84:	09 83       	std	Y+1, r16	; 0x01
     f86:	1a 83       	std	Y+2, r17	; 0x02
     f88:	2b 83       	std	Y+3, r18	; 0x03
     f8a:	3c 83       	std	Y+4, r19	; 0x04
     f8c:	4d 83       	std	Y+5, r20	; 0x05
     f8e:	5e 83       	std	Y+6, r21	; 0x06
     f90:	6f 83       	std	Y+7, r22	; 0x07
     f92:	78 87       	std	Y+8, r23	; 0x08
     f94:	89 87       	std	Y+9, r24	; 0x09
     f96:	9a 87       	std	Y+10, r25	; 0x0a
     f98:	09 81       	ldd	r16, Y+1	; 0x01
     f9a:	1a 81       	ldd	r17, Y+2	; 0x02
	 /* Set the all pins of the Keypad input & And Make Its Initial Value Is Float by Set 0 To The Port And Connect a PullDowen Resistance */
	 DIO_portConfiguration(keypad.keypadREG_Port,0x00);
     f9c:	c8 01       	movw	r24, r16
     f9e:	60 e0       	ldi	r22, 0x00	; 0
     fa0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <DIO_portConfiguration>
	 DIO_portWrite(keypad.keypadREG_Port,0x00);
     fa4:	c8 01       	movw	r24, r16
     fa6:	60 e0       	ldi	r22, 0x00	; 0
     fa8:	0e 94 82 01 	call	0x304	; 0x304 <DIO_portWrite>
 }
     fac:	2a 96       	adiw	r28, 0x0a	; 10
     fae:	0f b6       	in	r0, 0x3f	; 63
     fb0:	f8 94       	cli
     fb2:	de bf       	out	0x3e, r29	; 62
     fb4:	0f be       	out	0x3f, r0	; 63
     fb6:	cd bf       	out	0x3d, r28	; 61
     fb8:	df 91       	pop	r29
     fba:	cf 91       	pop	r28
     fbc:	1f 91       	pop	r17
     fbe:	0f 91       	pop	r16
     fc0:	08 95       	ret

00000fc2 <keypad_Read>:
 
 
 unsigned char keypad_Read(KEYPAD_PIN keypad)
 {
     fc2:	8f 92       	push	r8
     fc4:	9f 92       	push	r9
     fc6:	af 92       	push	r10
     fc8:	bf 92       	push	r11
     fca:	cf 92       	push	r12
     fcc:	df 92       	push	r13
     fce:	ef 92       	push	r14
     fd0:	ff 92       	push	r15
     fd2:	0f 93       	push	r16
     fd4:	1f 93       	push	r17
     fd6:	cf 93       	push	r28
     fd8:	df 93       	push	r29
     fda:	cd b7       	in	r28, 0x3d	; 61
     fdc:	de b7       	in	r29, 0x3e	; 62
     fde:	2a 97       	sbiw	r28, 0x0a	; 10
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	f8 94       	cli
     fe4:	de bf       	out	0x3e, r29	; 62
     fe6:	0f be       	out	0x3f, r0	; 63
     fe8:	cd bf       	out	0x3d, r28	; 61
     fea:	09 83       	std	Y+1, r16	; 0x01
     fec:	1a 83       	std	Y+2, r17	; 0x02
     fee:	2b 83       	std	Y+3, r18	; 0x03
     ff0:	3c 83       	std	Y+4, r19	; 0x04
     ff2:	4d 83       	std	Y+5, r20	; 0x05
     ff4:	5e 83       	std	Y+6, r21	; 0x06
     ff6:	c6 2e       	mov	r12, r22
     ff8:	6f 83       	std	Y+7, r22	; 0x07
     ffa:	b7 2e       	mov	r11, r23
     ffc:	78 87       	std	Y+8, r23	; 0x08
     ffe:	89 87       	std	Y+9, r24	; 0x09
    1000:	9a 87       	std	Y+10, r25	; 0x0a
	 unsigned char DataRead = 0x00;
    1002:	f0 2e       	mov	r15, r16
    1004:	d1 2e       	mov	r13, r17
    1006:	a8 2e       	mov	r10, r24
    1008:	99 2e       	mov	r9, r25
	 
	 /* CHECK IN THE COLUM 1 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL1,Output);
    100a:	80 2f       	mov	r24, r16
    100c:	91 2f       	mov	r25, r17
    100e:	42 e0       	ldi	r20, 0x02	; 2
    1010:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL1,HIGH);
    1014:	80 2f       	mov	r24, r16
    1016:	91 2f       	mov	r25, r17
    1018:	6c 2d       	mov	r22, r12
    101a:	41 e0       	ldi	r20, 0x01	; 1
    101c:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
     
	 if (CheckData(keypad, COL1))
    1020:	f9 82       	std	Y+1, r15	; 0x01
    1022:	1a 83       	std	Y+2, r17	; 0x02
    1024:	cf 82       	std	Y+7, r12	; 0x07
    1026:	b8 86       	std	Y+8, r11	; 0x08
    1028:	a9 86       	std	Y+9, r10	; 0x09
    102a:	9a 86       	std	Y+10, r9	; 0x0a
    102c:	2b 81       	ldd	r18, Y+3	; 0x03
    102e:	3c 81       	ldd	r19, Y+4	; 0x04
    1030:	4d 81       	ldd	r20, Y+5	; 0x05
    1032:	5e 81       	ldd	r21, Y+6	; 0x06
    1034:	6c 2d       	mov	r22, r12
    1036:	7b 2d       	mov	r23, r11
    1038:	8a 2d       	mov	r24, r10
    103a:	99 2d       	mov	r25, r9
    103c:	ee 24       	eor	r14, r14
    103e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <CheckData>
    1042:	88 23       	and	r24, r24
    1044:	91 f0       	breq	.+36     	; 0x106a <keypad_Read+0xa8>
	 { 
		 DataRead = CheckData(keypad, COL1);
    1046:	f9 82       	std	Y+1, r15	; 0x01
    1048:	da 82       	std	Y+2, r13	; 0x02
    104a:	cf 82       	std	Y+7, r12	; 0x07
    104c:	b8 86       	std	Y+8, r11	; 0x08
    104e:	a9 86       	std	Y+9, r10	; 0x09
    1050:	9a 86       	std	Y+10, r9	; 0x0a
    1052:	2b 81       	ldd	r18, Y+3	; 0x03
    1054:	3c 81       	ldd	r19, Y+4	; 0x04
    1056:	4d 81       	ldd	r20, Y+5	; 0x05
    1058:	5e 81       	ldd	r21, Y+6	; 0x06
    105a:	6c 2d       	mov	r22, r12
    105c:	7b 2d       	mov	r23, r11
    105e:	8a 2d       	mov	r24, r10
    1060:	99 2d       	mov	r25, r9
    1062:	0e 94 0f 07 	call	0xe1e	; 0xe1e <CheckData>
    1066:	88 2e       	mov	r8, r24
    1068:	01 c0       	rjmp	.+2      	; 0x106c <keypad_Read+0xaa>
 }
 
 
 unsigned char keypad_Read(KEYPAD_PIN keypad)
 {
	 unsigned char DataRead = 0x00;
    106a:	88 24       	eor	r8, r8
	 if (CheckData(keypad, COL1))
	 { 
		 DataRead = CheckData(keypad, COL1);
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL1,InputFloat);
    106c:	8f 2d       	mov	r24, r15
    106e:	9d 2d       	mov	r25, r13
    1070:	6c 2d       	mov	r22, r12
    1072:	40 e0       	ldi	r20, 0x00	; 0
    1074:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
    1078:	8f e1       	ldi	r24, 0x1F	; 31
    107a:	9e e4       	ldi	r25, 0x4E	; 78
    107c:	01 97       	sbiw	r24, 0x01	; 1
    107e:	f1 f7       	brne	.-4      	; 0x107c <keypad_Read+0xba>
    1080:	00 c0       	rjmp	.+0      	; 0x1082 <keypad_Read+0xc0>
    1082:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	
	 /* CHECK IN THE COLUM 2 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL2,Output);
    1084:	8f 2d       	mov	r24, r15
    1086:	9d 2d       	mov	r25, r13
    1088:	6b 2d       	mov	r22, r11
    108a:	42 e0       	ldi	r20, 0x02	; 2
    108c:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL2,HIGH);
    1090:	8f 2d       	mov	r24, r15
    1092:	9d 2d       	mov	r25, r13
    1094:	6b 2d       	mov	r22, r11
    1096:	41 e0       	ldi	r20, 0x01	; 1
    1098:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
     
	 if (CheckData(keypad, COL2))
    109c:	0f 2d       	mov	r16, r15
    109e:	f9 82       	std	Y+1, r15	; 0x01
    10a0:	da 82       	std	Y+2, r13	; 0x02
    10a2:	cf 82       	std	Y+7, r12	; 0x07
    10a4:	b8 86       	std	Y+8, r11	; 0x08
    10a6:	a9 86       	std	Y+9, r10	; 0x09
    10a8:	9a 86       	std	Y+10, r9	; 0x0a
    10aa:	1d 2d       	mov	r17, r13
    10ac:	2b 81       	ldd	r18, Y+3	; 0x03
    10ae:	3c 81       	ldd	r19, Y+4	; 0x04
    10b0:	4d 81       	ldd	r20, Y+5	; 0x05
    10b2:	5e 81       	ldd	r21, Y+6	; 0x06
    10b4:	6c 2d       	mov	r22, r12
    10b6:	7b 2d       	mov	r23, r11
    10b8:	8a 2d       	mov	r24, r10
    10ba:	99 2d       	mov	r25, r9
    10bc:	ee 24       	eor	r14, r14
    10be:	e3 94       	inc	r14
    10c0:	0e 94 0f 07 	call	0xe1e	; 0xe1e <CheckData>
    10c4:	88 23       	and	r24, r24
    10c6:	89 f0       	breq	.+34     	; 0x10ea <keypad_Read+0x128>
	 {
		 DataRead = CheckData(keypad, COL2);
    10c8:	f9 82       	std	Y+1, r15	; 0x01
    10ca:	da 82       	std	Y+2, r13	; 0x02
    10cc:	cf 82       	std	Y+7, r12	; 0x07
    10ce:	b8 86       	std	Y+8, r11	; 0x08
    10d0:	a9 86       	std	Y+9, r10	; 0x09
    10d2:	9a 86       	std	Y+10, r9	; 0x0a
    10d4:	2b 81       	ldd	r18, Y+3	; 0x03
    10d6:	3c 81       	ldd	r19, Y+4	; 0x04
    10d8:	4d 81       	ldd	r20, Y+5	; 0x05
    10da:	5e 81       	ldd	r21, Y+6	; 0x06
    10dc:	6c 2d       	mov	r22, r12
    10de:	7b 2d       	mov	r23, r11
    10e0:	8a 2d       	mov	r24, r10
    10e2:	99 2d       	mov	r25, r9
    10e4:	0e 94 0f 07 	call	0xe1e	; 0xe1e <CheckData>
    10e8:	88 2e       	mov	r8, r24
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL2,InputFloat);
    10ea:	8f 2d       	mov	r24, r15
    10ec:	9d 2d       	mov	r25, r13
    10ee:	6b 2d       	mov	r22, r11
    10f0:	40 e0       	ldi	r20, 0x00	; 0
    10f2:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
    10f6:	8f e1       	ldi	r24, 0x1F	; 31
    10f8:	9e e4       	ldi	r25, 0x4E	; 78
    10fa:	01 97       	sbiw	r24, 0x01	; 1
    10fc:	f1 f7       	brne	.-4      	; 0x10fa <keypad_Read+0x138>
    10fe:	00 c0       	rjmp	.+0      	; 0x1100 <keypad_Read+0x13e>
    1100:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 
	 /* CHECK IN THE COLUM 3 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL3,Output);
    1102:	8f 2d       	mov	r24, r15
    1104:	9d 2d       	mov	r25, r13
    1106:	6a 2d       	mov	r22, r10
    1108:	42 e0       	ldi	r20, 0x02	; 2
    110a:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL3,HIGH);
    110e:	8f 2d       	mov	r24, r15
    1110:	9d 2d       	mov	r25, r13
    1112:	6a 2d       	mov	r22, r10
    1114:	41 e0       	ldi	r20, 0x01	; 1
    1116:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
     
	 if (CheckData(keypad, COL3))
    111a:	0f 2d       	mov	r16, r15
    111c:	f9 82       	std	Y+1, r15	; 0x01
    111e:	da 82       	std	Y+2, r13	; 0x02
    1120:	cf 82       	std	Y+7, r12	; 0x07
    1122:	b8 86       	std	Y+8, r11	; 0x08
    1124:	a9 86       	std	Y+9, r10	; 0x09
    1126:	9a 86       	std	Y+10, r9	; 0x0a
    1128:	1d 2d       	mov	r17, r13
    112a:	2b 81       	ldd	r18, Y+3	; 0x03
    112c:	3c 81       	ldd	r19, Y+4	; 0x04
    112e:	4d 81       	ldd	r20, Y+5	; 0x05
    1130:	5e 81       	ldd	r21, Y+6	; 0x06
    1132:	6c 2d       	mov	r22, r12
    1134:	7b 2d       	mov	r23, r11
    1136:	8a 2d       	mov	r24, r10
    1138:	99 2d       	mov	r25, r9
    113a:	ee 24       	eor	r14, r14
    113c:	68 94       	set
    113e:	e1 f8       	bld	r14, 1
    1140:	0e 94 0f 07 	call	0xe1e	; 0xe1e <CheckData>
    1144:	88 23       	and	r24, r24
    1146:	89 f0       	breq	.+34     	; 0x116a <keypad_Read+0x1a8>
	 { 
		 DataRead = CheckData(keypad, COL3);
    1148:	f9 82       	std	Y+1, r15	; 0x01
    114a:	da 82       	std	Y+2, r13	; 0x02
    114c:	cf 82       	std	Y+7, r12	; 0x07
    114e:	b8 86       	std	Y+8, r11	; 0x08
    1150:	a9 86       	std	Y+9, r10	; 0x09
    1152:	9a 86       	std	Y+10, r9	; 0x0a
    1154:	2b 81       	ldd	r18, Y+3	; 0x03
    1156:	3c 81       	ldd	r19, Y+4	; 0x04
    1158:	4d 81       	ldd	r20, Y+5	; 0x05
    115a:	5e 81       	ldd	r21, Y+6	; 0x06
    115c:	6c 2d       	mov	r22, r12
    115e:	7b 2d       	mov	r23, r11
    1160:	8a 2d       	mov	r24, r10
    1162:	99 2d       	mov	r25, r9
    1164:	0e 94 0f 07 	call	0xe1e	; 0xe1e <CheckData>
    1168:	88 2e       	mov	r8, r24
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL3,InputFloat);
    116a:	8f 2d       	mov	r24, r15
    116c:	9d 2d       	mov	r25, r13
    116e:	6a 2d       	mov	r22, r10
    1170:	40 e0       	ldi	r20, 0x00	; 0
    1172:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
    1176:	8f e1       	ldi	r24, 0x1F	; 31
    1178:	9e e4       	ldi	r25, 0x4E	; 78
    117a:	01 97       	sbiw	r24, 0x01	; 1
    117c:	f1 f7       	brne	.-4      	; 0x117a <keypad_Read+0x1b8>
    117e:	00 c0       	rjmp	.+0      	; 0x1180 <keypad_Read+0x1be>
    1180:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 
	 /* CHECK IN THE COLUM 4 */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL4,Output);
    1182:	8f 2d       	mov	r24, r15
    1184:	9d 2d       	mov	r25, r13
    1186:	69 2d       	mov	r22, r9
    1188:	42 e0       	ldi	r20, 0x02	; 2
    118a:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	 DIO_pinWrite(keypad.keypadREG_Port,keypad.PINCL4,HIGH);
    118e:	8f 2d       	mov	r24, r15
    1190:	9d 2d       	mov	r25, r13
    1192:	69 2d       	mov	r22, r9
    1194:	41 e0       	ldi	r20, 0x01	; 1
    1196:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
     
	 if (CheckData(keypad, COL4))
    119a:	0f 2d       	mov	r16, r15
    119c:	f9 82       	std	Y+1, r15	; 0x01
    119e:	da 82       	std	Y+2, r13	; 0x02
    11a0:	cf 82       	std	Y+7, r12	; 0x07
    11a2:	b8 86       	std	Y+8, r11	; 0x08
    11a4:	a9 86       	std	Y+9, r10	; 0x09
    11a6:	9a 86       	std	Y+10, r9	; 0x0a
    11a8:	1d 2d       	mov	r17, r13
    11aa:	2b 81       	ldd	r18, Y+3	; 0x03
    11ac:	3c 81       	ldd	r19, Y+4	; 0x04
    11ae:	4d 81       	ldd	r20, Y+5	; 0x05
    11b0:	5e 81       	ldd	r21, Y+6	; 0x06
    11b2:	6c 2d       	mov	r22, r12
    11b4:	7b 2d       	mov	r23, r11
    11b6:	8a 2d       	mov	r24, r10
    11b8:	99 2d       	mov	r25, r9
    11ba:	0f 2e       	mov	r0, r31
    11bc:	f3 e0       	ldi	r31, 0x03	; 3
    11be:	ef 2e       	mov	r14, r31
    11c0:	f0 2d       	mov	r31, r0
    11c2:	0e 94 0f 07 	call	0xe1e	; 0xe1e <CheckData>
    11c6:	88 23       	and	r24, r24
    11c8:	89 f0       	breq	.+34     	; 0x11ec <keypad_Read+0x22a>
	 {
		 DataRead = CheckData(keypad, COL4);
    11ca:	f9 82       	std	Y+1, r15	; 0x01
    11cc:	da 82       	std	Y+2, r13	; 0x02
    11ce:	cf 82       	std	Y+7, r12	; 0x07
    11d0:	b8 86       	std	Y+8, r11	; 0x08
    11d2:	a9 86       	std	Y+9, r10	; 0x09
    11d4:	9a 86       	std	Y+10, r9	; 0x0a
    11d6:	2b 81       	ldd	r18, Y+3	; 0x03
    11d8:	3c 81       	ldd	r19, Y+4	; 0x04
    11da:	4d 81       	ldd	r20, Y+5	; 0x05
    11dc:	5e 81       	ldd	r21, Y+6	; 0x06
    11de:	6c 2d       	mov	r22, r12
    11e0:	7b 2d       	mov	r23, r11
    11e2:	8a 2d       	mov	r24, r10
    11e4:	99 2d       	mov	r25, r9
    11e6:	0e 94 0f 07 	call	0xe1e	; 0xe1e <CheckData>
    11ea:	88 2e       	mov	r8, r24
	 }
	 /* Return The Pin as Input Pin To Avoid The Short Circuit Condition if The User Pushed TWO Key At The Same Time */
	 DIO_pinConfiguration(keypad.keypadREG_Port,keypad.PINCL4,InputFloat);
    11ec:	8f 2d       	mov	r24, r15
    11ee:	9d 2d       	mov	r25, r13
    11f0:	69 2d       	mov	r22, r9
    11f2:	40 e0       	ldi	r20, 0x00	; 0
    11f4:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
    11f8:	8f e1       	ldi	r24, 0x1F	; 31
    11fa:	9e e4       	ldi	r25, 0x4E	; 78
    11fc:	01 97       	sbiw	r24, 0x01	; 1
    11fe:	f1 f7       	brne	.-4      	; 0x11fc <keypad_Read+0x23a>
    1200:	00 c0       	rjmp	.+0      	; 0x1202 <keypad_Read+0x240>
    1202:	00 00       	nop
	 _delay_ms(DELAY_FOR_PINCONFIG);
	 return DataRead;
	 
    1204:	88 2d       	mov	r24, r8
    1206:	2a 96       	adiw	r28, 0x0a	; 10
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	f8 94       	cli
    120c:	de bf       	out	0x3e, r29	; 62
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	cd bf       	out	0x3d, r28	; 61
    1212:	df 91       	pop	r29
    1214:	cf 91       	pop	r28
    1216:	1f 91       	pop	r17
    1218:	0f 91       	pop	r16
    121a:	ff 90       	pop	r15
    121c:	ef 90       	pop	r14
    121e:	df 90       	pop	r13
    1220:	cf 90       	pop	r12
    1222:	bf 90       	pop	r11
    1224:	af 90       	pop	r10
    1226:	9f 90       	pop	r9
    1228:	8f 90       	pop	r8
    122a:	08 95       	ret

0000122c <MotorDriver_Setup>:
  #include "L298N_MotorDriver.h"
  
  
  
  void MotorDriver_Setup(MotorDriver PINS)
  {
    122c:	0f 93       	push	r16
    122e:	1f 93       	push	r17
    1230:	cf 93       	push	r28
    1232:	df 93       	push	r29
    1234:	cd b7       	in	r28, 0x3d	; 61
    1236:	de b7       	in	r29, 0x3e	; 62
    1238:	28 97       	sbiw	r28, 0x08	; 8
    123a:	0f b6       	in	r0, 0x3f	; 63
    123c:	f8 94       	cli
    123e:	de bf       	out	0x3e, r29	; 62
    1240:	0f be       	out	0x3f, r0	; 63
    1242:	cd bf       	out	0x3d, r28	; 61
    1244:	29 83       	std	Y+1, r18	; 0x01
    1246:	3a 83       	std	Y+2, r19	; 0x02
    1248:	4b 83       	std	Y+3, r20	; 0x03
    124a:	5c 83       	std	Y+4, r21	; 0x04
    124c:	6d 83       	std	Y+5, r22	; 0x05
    124e:	7e 83       	std	Y+6, r23	; 0x06
    1250:	8f 83       	std	Y+7, r24	; 0x07
    1252:	98 87       	std	Y+8, r25	; 0x08
    1254:	09 81       	ldd	r16, Y+1	; 0x01
    1256:	1a 81       	ldd	r17, Y+2	; 0x02
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA1,Output);
    1258:	c8 01       	movw	r24, r16
    125a:	64 2f       	mov	r22, r20
    125c:	42 e0       	ldi	r20, 0x02	; 2
    125e:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA2,Output);
    1262:	c8 01       	movw	r24, r16
    1264:	6c 81       	ldd	r22, Y+4	; 0x04
    1266:	42 e0       	ldi	r20, 0x02	; 2
    1268:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA3,Output);
    126c:	c8 01       	movw	r24, r16
    126e:	6d 81       	ldd	r22, Y+5	; 0x05
    1270:	42 e0       	ldi	r20, 0x02	; 2
    1272:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  DIO_pinConfiguration(PINS.DriverPORT,PINS.MOTOR_INA4,Output);
    1276:	c8 01       	movw	r24, r16
    1278:	6e 81       	ldd	r22, Y+6	; 0x06
    127a:	42 e0       	ldi	r20, 0x02	; 2
    127c:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
  }
    1280:	28 96       	adiw	r28, 0x08	; 8
    1282:	0f b6       	in	r0, 0x3f	; 63
    1284:	f8 94       	cli
    1286:	de bf       	out	0x3e, r29	; 62
    1288:	0f be       	out	0x3f, r0	; 63
    128a:	cd bf       	out	0x3d, r28	; 61
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	1f 91       	pop	r17
    1292:	0f 91       	pop	r16
    1294:	08 95       	ret

00001296 <Motor_Direction>:
  
  
  
  void Motor_Direction(MotorDriver motordirection)
  {
    1296:	cf 92       	push	r12
    1298:	df 92       	push	r13
    129a:	ef 92       	push	r14
    129c:	ff 92       	push	r15
    129e:	0f 93       	push	r16
    12a0:	1f 93       	push	r17
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	cd b7       	in	r28, 0x3d	; 61
    12a8:	de b7       	in	r29, 0x3e	; 62
    12aa:	28 97       	sbiw	r28, 0x08	; 8
    12ac:	0f b6       	in	r0, 0x3f	; 63
    12ae:	f8 94       	cli
    12b0:	de bf       	out	0x3e, r29	; 62
    12b2:	0f be       	out	0x3f, r0	; 63
    12b4:	cd bf       	out	0x3d, r28	; 61
    12b6:	29 83       	std	Y+1, r18	; 0x01
    12b8:	3a 83       	std	Y+2, r19	; 0x02
    12ba:	f4 2e       	mov	r15, r20
    12bc:	4b 83       	std	Y+3, r20	; 0x03
    12be:	e5 2e       	mov	r14, r21
    12c0:	5c 83       	std	Y+4, r21	; 0x04
    12c2:	d6 2e       	mov	r13, r22
    12c4:	6d 83       	std	Y+5, r22	; 0x05
    12c6:	c7 2e       	mov	r12, r23
    12c8:	7e 83       	std	Y+6, r23	; 0x06
    12ca:	8f 83       	std	Y+7, r24	; 0x07
    12cc:	98 87       	std	Y+8, r25	; 0x08
    12ce:	09 81       	ldd	r16, Y+1	; 0x01
    12d0:	1a 81       	ldd	r17, Y+2	; 0x02
	  switch (motordirection.MOTORNUM)
    12d2:	88 23       	and	r24, r24
    12d4:	21 f0       	breq	.+8      	; 0x12de <Motor_Direction+0x48>
    12d6:	81 30       	cpi	r24, 0x01	; 1
    12d8:	09 f0       	breq	.+2      	; 0x12dc <Motor_Direction+0x46>
    12da:	a8 c0       	rjmp	.+336    	; 0x142c <Motor_Direction+0x196>
    12dc:	4a c0       	rjmp	.+148    	; 0x1372 <Motor_Direction+0xdc>
	  {
		  case Two_Motor :
		  /* in This Case Motor A is the Back Motor that give The Main Motion To The Robot And Th Motor B is Direction Motor */
		        switch(motordirection.MOVMENT)
    12de:	91 30       	cpi	r25, 0x01	; 1
    12e0:	99 f0       	breq	.+38     	; 0x1308 <Motor_Direction+0x72>
    12e2:	91 30       	cpi	r25, 0x01	; 1
    12e4:	30 f0       	brcs	.+12     	; 0x12f2 <Motor_Direction+0x5c>
    12e6:	92 30       	cpi	r25, 0x02	; 2
    12e8:	d1 f0       	breq	.+52     	; 0x131e <Motor_Direction+0x88>
    12ea:	93 30       	cpi	r25, 0x03	; 3
    12ec:	09 f0       	breq	.+2      	; 0x12f0 <Motor_Direction+0x5a>
    12ee:	41 c0       	rjmp	.+130    	; 0x1372 <Motor_Direction+0xdc>
    12f0:	2b c0       	rjmp	.+86     	; 0x1348 <Motor_Direction+0xb2>
				{
					case Forward:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    12f2:	c8 01       	movw	r24, r16
    12f4:	64 2f       	mov	r22, r20
    12f6:	41 e0       	ldi	r20, 0x01	; 1
    12f8:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    12fc:	c8 01       	movw	r24, r16
    12fe:	6e 2d       	mov	r22, r14
    1300:	40 e0       	ldi	r20, 0x00	; 0
    1302:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
    1306:	3f c0       	rjmp	.+126    	; 0x1386 <Motor_Direction+0xf0>
						 break;
					case Reverce:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
    1308:	c8 01       	movw	r24, r16
    130a:	64 2f       	mov	r22, r20
    130c:	40 e0       	ldi	r20, 0x00	; 0
    130e:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,HIGH);
    1312:	c8 01       	movw	r24, r16
    1314:	6e 2d       	mov	r22, r14
    1316:	41 e0       	ldi	r20, 0x01	; 1
    1318:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
    131c:	49 c0       	rjmp	.+146    	; 0x13b0 <Motor_Direction+0x11a>
						 break;
				    case Left:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    131e:	c8 01       	movw	r24, r16
    1320:	64 2f       	mov	r22, r20
    1322:	41 e0       	ldi	r20, 0x01	; 1
    1324:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    1328:	c8 01       	movw	r24, r16
    132a:	6e 2d       	mov	r22, r14
    132c:	40 e0       	ldi	r20, 0x00	; 0
    132e:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,HIGH);
    1332:	c8 01       	movw	r24, r16
    1334:	6d 2d       	mov	r22, r13
    1336:	41 e0       	ldi	r20, 0x01	; 1
    1338:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
						 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
    133c:	c8 01       	movw	r24, r16
    133e:	6c 2d       	mov	r22, r12
    1340:	40 e0       	ldi	r20, 0x00	; 0
    1342:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
    1346:	49 c0       	rjmp	.+146    	; 0x13da <Motor_Direction+0x144>
						 break;
					case Right:
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    1348:	c8 01       	movw	r24, r16
    134a:	64 2f       	mov	r22, r20
    134c:	41 e0       	ldi	r20, 0x01	; 1
    134e:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    1352:	c8 01       	movw	r24, r16
    1354:	6e 2d       	mov	r22, r14
    1356:	40 e0       	ldi	r20, 0x00	; 0
    1358:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,LOW);
    135c:	c8 01       	movw	r24, r16
    135e:	6d 2d       	mov	r22, r13
    1360:	40 e0       	ldi	r20, 0x00	; 0
    1362:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
					     DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,HIGH);
    1366:	c8 01       	movw	r24, r16
    1368:	6c 2d       	mov	r22, r12
    136a:	41 e0       	ldi	r20, 0x01	; 1
    136c:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
    1370:	49 c0       	rjmp	.+146    	; 0x1404 <Motor_Direction+0x16e>
					default:
					       /* Handle The Error Function */
						   break;
				}	
		case More:
		     switch (motordirection.MOVMENT)
    1372:	91 30       	cpi	r25, 0x01	; 1
    1374:	e9 f0       	breq	.+58     	; 0x13b0 <Motor_Direction+0x11a>
    1376:	91 30       	cpi	r25, 0x01	; 1
    1378:	30 f0       	brcs	.+12     	; 0x1386 <Motor_Direction+0xf0>
    137a:	92 30       	cpi	r25, 0x02	; 2
    137c:	71 f1       	breq	.+92     	; 0x13da <Motor_Direction+0x144>
    137e:	93 30       	cpi	r25, 0x03	; 3
    1380:	09 f0       	breq	.+2      	; 0x1384 <Motor_Direction+0xee>
    1382:	54 c0       	rjmp	.+168    	; 0x142c <Motor_Direction+0x196>
    1384:	3f c0       	rjmp	.+126    	; 0x1404 <Motor_Direction+0x16e>
			 {
				 case Forward:
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    1386:	c8 01       	movw	r24, r16
    1388:	6f 2d       	mov	r22, r15
    138a:	41 e0       	ldi	r20, 0x01	; 1
    138c:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    1390:	c8 01       	movw	r24, r16
    1392:	6e 2d       	mov	r22, r14
    1394:	40 e0       	ldi	r20, 0x00	; 0
    1396:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,HIGH);
    139a:	c8 01       	movw	r24, r16
    139c:	6d 2d       	mov	r22, r13
    139e:	41 e0       	ldi	r20, 0x01	; 1
    13a0:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
    13a4:	c8 01       	movw	r24, r16
    13a6:	6c 2d       	mov	r22, r12
    13a8:	40 e0       	ldi	r20, 0x00	; 0
    13aa:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 break;
    13ae:	3e c0       	rjmp	.+124    	; 0x142c <Motor_Direction+0x196>
				 case Reverce:
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
    13b0:	c8 01       	movw	r24, r16
    13b2:	6f 2d       	mov	r22, r15
    13b4:	40 e0       	ldi	r20, 0x00	; 0
    13b6:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,HIGH);
    13ba:	c8 01       	movw	r24, r16
    13bc:	6e 2d       	mov	r22, r14
    13be:	41 e0       	ldi	r20, 0x01	; 1
    13c0:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,LOW);
    13c4:	c8 01       	movw	r24, r16
    13c6:	6f 2d       	mov	r22, r15
    13c8:	40 e0       	ldi	r20, 0x00	; 0
    13ca:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,HIGH);
    13ce:	c8 01       	movw	r24, r16
    13d0:	6e 2d       	mov	r22, r14
    13d2:	41 e0       	ldi	r20, 0x01	; 1
    13d4:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 break;
    13d8:	29 c0       	rjmp	.+82     	; 0x142c <Motor_Direction+0x196>
				 case Left:
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    13da:	c8 01       	movw	r24, r16
    13dc:	6f 2d       	mov	r22, r15
    13de:	41 e0       	ldi	r20, 0x01	; 1
    13e0:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    13e4:	c8 01       	movw	r24, r16
    13e6:	6e 2d       	mov	r22, r14
    13e8:	40 e0       	ldi	r20, 0x00	; 0
    13ea:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,HIGH);
    13ee:	c8 01       	movw	r24, r16
    13f0:	6d 2d       	mov	r22, r13
    13f2:	41 e0       	ldi	r20, 0x01	; 1
    13f4:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,LOW);
    13f8:	c8 01       	movw	r24, r16
    13fa:	6c 2d       	mov	r22, r12
    13fc:	40 e0       	ldi	r20, 0x00	; 0
    13fe:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 break;
    1402:	14 c0       	rjmp	.+40     	; 0x142c <Motor_Direction+0x196>
				 case Right:
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA1,HIGH);
    1404:	c8 01       	movw	r24, r16
    1406:	6f 2d       	mov	r22, r15
    1408:	41 e0       	ldi	r20, 0x01	; 1
    140a:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA2,LOW);
    140e:	c8 01       	movw	r24, r16
    1410:	6e 2d       	mov	r22, r14
    1412:	40 e0       	ldi	r20, 0x00	; 0
    1414:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA3,LOW);
    1418:	c8 01       	movw	r24, r16
    141a:	6d 2d       	mov	r22, r13
    141c:	40 e0       	ldi	r20, 0x00	; 0
    141e:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 DIO_pinWrite(motordirection.DriverPORT,motordirection.MOTOR_INA4,HIGH);
    1422:	c8 01       	movw	r24, r16
    1424:	6c 2d       	mov	r22, r12
    1426:	41 e0       	ldi	r20, 0x01	; 1
    1428:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
				 default:
				 /* Handle The Error Function */
				 break;
			 }				 				
	  }		  
    142c:	28 96       	adiw	r28, 0x08	; 8
    142e:	0f b6       	in	r0, 0x3f	; 63
    1430:	f8 94       	cli
    1432:	de bf       	out	0x3e, r29	; 62
    1434:	0f be       	out	0x3f, r0	; 63
    1436:	cd bf       	out	0x3d, r28	; 61
    1438:	df 91       	pop	r29
    143a:	cf 91       	pop	r28
    143c:	1f 91       	pop	r17
    143e:	0f 91       	pop	r16
    1440:	ff 90       	pop	r15
    1442:	ef 90       	pop	r14
    1444:	df 90       	pop	r13
    1446:	cf 90       	pop	r12
    1448:	08 95       	ret

0000144a <Send_instruction>:
  #define MAX_NWCHAR   (8)
  
    void Send_instruction(unsigned char instruction)
	{
		/* The RS And The RW Must Be RESET When Send Instruction To The LCD */
		RESET_Bit(LCD_CONTROL_REG_OP, RS);
    144a:	c0 98       	cbi	0x18, 0	; 24
		RESET_Bit(LCD_CONTROL_REG_OP, RW);
    144c:	c1 98       	cbi	0x18, 1	; 24
    144e:	ef e9       	ldi	r30, 0x9F	; 159
    1450:	ff e0       	ldi	r31, 0x0F	; 15
    1452:	31 97       	sbiw	r30, 0x01	; 1
    1454:	f1 f7       	brne	.-4      	; 0x1452 <Send_instruction+0x8>
    1456:	00 c0       	rjmp	.+0      	; 0x1458 <Send_instruction+0xe>
    1458:	00 00       	nop
		/* Delay of Address Set 60ns minimum This In The Ideal State */
		_delay_ms(1);
		
		/* We WriteTo the LCD InThe Falling Of The Enable Pin */
		/* Set The Enable Pin */
		SET_Bit(LCD_CONTROL_REG_OP, E);
    145a:	c2 9a       	sbi	0x18, 2	; 24
    145c:	ef e9       	ldi	r30, 0x9F	; 159
    145e:	ff e0       	ldi	r31, 0x0F	; 15
    1460:	31 97       	sbiw	r30, 0x01	; 1
    1462:	f1 f7       	brne	.-4      	; 0x1460 <Send_instruction+0x16>
    1464:	00 c0       	rjmp	.+0      	; 0x1466 <Send_instruction+0x1c>
    1466:	00 00       	nop
		
	   #else 
	        /* At The First We Send The MSB 4-bit Of The Instruction So We handle If The User Connect LCD in The Upper Or Lower Pin Of The Port */
	        #ifdef LCD_UPPER_DATA_PORT
			       /* Setup The Data Port To hold The Data By Reset the Upper Pin */
				   LCD_DATA_REG_OP &= 0x0F ; 
    1468:	9b b3       	in	r25, 0x1b	; 27
    146a:	9f 70       	andi	r25, 0x0F	; 15
    146c:	9b bb       	out	0x1b, r25	; 27
				   LCD_DATA_REG_OP |= (instruction & 0xF0);
    146e:	9b b3       	in	r25, 0x1b	; 27
    1470:	28 2f       	mov	r18, r24
    1472:	20 7f       	andi	r18, 0xF0	; 240
    1474:	92 2b       	or	r25, r18
    1476:	9b bb       	out	0x1b, r25	; 27
    1478:	ef e9       	ldi	r30, 0x9F	; 159
    147a:	ff e0       	ldi	r31, 0x0F	; 15
    147c:	31 97       	sbiw	r30, 0x01	; 1
    147e:	f1 f7       	brne	.-4      	; 0x147c <Send_instruction+0x32>
    1480:	00 c0       	rjmp	.+0      	; 0x1482 <Send_instruction+0x38>
    1482:	00 00       	nop
			
			/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
			_delay_ms(1);
			
			/* disable LCD E=0 */
			RESET_Bit(LCD_CONTROL_REG_OP,E);
    1484:	c2 98       	cbi	0x18, 2	; 24
    1486:	ef e9       	ldi	r30, 0x9F	; 159
    1488:	ff e0       	ldi	r31, 0x0F	; 15
    148a:	31 97       	sbiw	r30, 0x01	; 1
    148c:	f1 f7       	brne	.-4      	; 0x148a <Send_instruction+0x40>
    148e:	00 c0       	rjmp	.+0      	; 0x1490 <Send_instruction+0x46>
    1490:	00 00       	nop
			/* Data Hold delay Th = 10ns */
			_delay_ms(1);
		    
			/* Reconfigure The E Pin To Prepare To Send The Next 4-bit LSB */
		    SET_Bit(LCD_CONTROL_REG_OP, E);
    1492:	c2 9a       	sbi	0x18, 2	; 24
    1494:	ef e9       	ldi	r30, 0x9F	; 159
    1496:	ff e0       	ldi	r31, 0x0F	; 15
    1498:	31 97       	sbiw	r30, 0x01	; 1
    149a:	f1 f7       	brne	.-4      	; 0x1498 <Send_instruction+0x4e>
    149c:	00 c0       	rjmp	.+0      	; 0x149e <Send_instruction+0x54>
    149e:	00 00       	nop
		    /* delay for processing PW min 450ns This In The Ideal State */
		    _delay_ms(1);
			
			#ifdef LCD_UPPER_DATA_PORT
			       /* Setup The Data Port To hold The Data By Reset the Upper Pin */
			       LCD_DATA_REG_OP &= 0x0F ;
    14a0:	9b b3       	in	r25, 0x1b	; 27
    14a2:	9f 70       	andi	r25, 0x0F	; 15
    14a4:	9b bb       	out	0x1b, r25	; 27
			       LCD_DATA_REG_OP |= ((instruction << 4) & 0xF0);
    14a6:	9b b3       	in	r25, 0x1b	; 27
    14a8:	82 95       	swap	r24
    14aa:	80 7f       	andi	r24, 0xF0	; 240
    14ac:	89 2b       	or	r24, r25
    14ae:	8b bb       	out	0x1b, r24	; 27
    14b0:	8f e9       	ldi	r24, 0x9F	; 159
    14b2:	9f e0       	ldi	r25, 0x0F	; 15
    14b4:	01 97       	sbiw	r24, 0x01	; 1
    14b6:	f1 f7       	brne	.-4      	; 0x14b4 <Send_instruction+0x6a>
    14b8:	00 c0       	rjmp	.+0      	; 0x14ba <Send_instruction+0x70>
    14ba:	00 00       	nop
		     	   LCD_DATA_REG_OP |= (instruction & 0x0F);  
            #endif
			/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
			_delay_ms(1);
			/* disable LCD E=0 */
			RESET_Bit(LCD_CONTROL_REG_OP,E);
    14bc:	c2 98       	cbi	0x18, 2	; 24
    14be:	ef e9       	ldi	r30, 0x9F	; 159
    14c0:	ff e0       	ldi	r31, 0x0F	; 15
    14c2:	31 97       	sbiw	r30, 0x01	; 1
    14c4:	f1 f7       	brne	.-4      	; 0x14c2 <Send_instruction+0x78>
    14c6:	00 c0       	rjmp	.+0      	; 0x14c8 <Send_instruction+0x7e>
    14c8:	00 00       	nop
			/* Data Hold delay Th = 10ns This In The Ideal State*/
			_delay_ms(1);
			#endif
	}	
    14ca:	08 95       	ret

000014cc <LCD_init>:
		/* Set The Direction Of The 8 Data Bit As Output */
		LCD_DATA_REG_DIR = 0xFF;
		#else
		#ifdef LCD_UPPER_DATA_PORT
		/* Set The Direction Of The Higher 4 Data Bit As Output */
		LCD_DATA_REG_DIR |= 0xF0;
    14cc:	8a b3       	in	r24, 0x1a	; 26
    14ce:	80 6f       	ori	r24, 0xF0	; 240
    14d0:	8a bb       	out	0x1a, r24	; 26
		#else
		/* Set The Direction Of The Lower 4 Data Bit As Output */
		LCD_DATA_REG_DIR |= 0x0F;
		#endif
		/* Setup The Control Pin As A Output Pin */
		LCD_CONTROL_REG_DIR |= (1 << E) | (1 << RS) | (1 << RW);
    14d2:	87 b3       	in	r24, 0x17	; 23
    14d4:	87 60       	ori	r24, 0x07	; 7
    14d6:	87 bb       	out	0x17, r24	; 23
		
		
			 /* Set LCD to Use 4 bits Op */
			 Send_instruction(RETURN_HOME);
    14d8:	82 e0       	ldi	r24, 0x02	; 2
    14da:	0e 94 25 0a 	call	0x144a	; 0x144a <Send_instruction>
	   #endif
	   Send_instruction(FUNCTION_SET);
    14de:	88 e2       	ldi	r24, 0x28	; 40
    14e0:	0e 94 25 0a 	call	0x144a	; 0x144a <Send_instruction>
	   Send_instruction(DISPLAY_ON);
    14e4:	8c e0       	ldi	r24, 0x0C	; 12
    14e6:	0e 94 25 0a 	call	0x144a	; 0x144a <Send_instruction>
	   Send_instruction(CLEAR_DISPALY);
    14ea:	81 e0       	ldi	r24, 0x01	; 1
    14ec:	0e 94 25 0a 	call	0x144a	; 0x144a <Send_instruction>
		
	}
    14f0:	08 95       	ret

000014f2 <LCD_Clear>:
	
			
    void LCD_Clear(void)
	{
		/* Clear Instruction */
		Send_instruction(CLEAR_DISPALY);
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	0e 94 25 0a 	call	0x144a	; 0x144a <Send_instruction>
	}	
    14f8:	08 95       	ret

000014fa <LCD_DisplayChar>:
	
		
    void LCD_DisplayChar(unsigned char Data)
	{
		/* The RS  Must Be RESET and The RW must be SET When Send Data To The LCD */
		SET_Bit(LCD_CONTROL_REG_OP, RS);
    14fa:	c0 9a       	sbi	0x18, 0	; 24
		RESET_Bit(LCD_CONTROL_REG_OP, RW);
    14fc:	c1 98       	cbi	0x18, 1	; 24
    14fe:	ef e9       	ldi	r30, 0x9F	; 159
    1500:	ff e0       	ldi	r31, 0x0F	; 15
    1502:	31 97       	sbiw	r30, 0x01	; 1
    1504:	f1 f7       	brne	.-4      	; 0x1502 <LCD_DisplayChar+0x8>
    1506:	00 c0       	rjmp	.+0      	; 0x1508 <LCD_DisplayChar+0xe>
    1508:	00 00       	nop
		/* Delay of Address Set 60ns minimum This In The Ideal State */
		_delay_ms(1);
		/* We WriteTo the LCD InThe Falling Of The Enable Pin */
		/* Set The Enable Pin */
		SET_Bit(LCD_CONTROL_REG_OP, E);
    150a:	c2 9a       	sbi	0x18, 2	; 24
    150c:	ef e9       	ldi	r30, 0x9F	; 159
    150e:	ff e0       	ldi	r31, 0x0F	; 15
    1510:	31 97       	sbiw	r30, 0x01	; 1
    1512:	f1 f7       	brne	.-4      	; 0x1510 <LCD_DisplayChar+0x16>
    1514:	00 c0       	rjmp	.+0      	; 0x1516 <LCD_DisplayChar+0x1c>
    1516:	00 00       	nop
		
		#else
		/* At The First We Send The MSB 4-bit Of The Instruction So We handle If The User Connect LCD in The Upper Or Lower Pin Of The Port */
		#ifdef LCD_UPPER_DATA_PORT
		/* Setup The Data Port To hold The Data By Reset the Upper Pin */
		LCD_DATA_REG_OP &= 0x0F ;
    1518:	9b b3       	in	r25, 0x1b	; 27
    151a:	9f 70       	andi	r25, 0x0F	; 15
    151c:	9b bb       	out	0x1b, r25	; 27
		LCD_DATA_REG_OP |= (Data & 0xF0);
    151e:	9b b3       	in	r25, 0x1b	; 27
    1520:	28 2f       	mov	r18, r24
    1522:	20 7f       	andi	r18, 0xF0	; 240
    1524:	92 2b       	or	r25, r18
    1526:	9b bb       	out	0x1b, r25	; 27
    1528:	ef e9       	ldi	r30, 0x9F	; 159
    152a:	ff e0       	ldi	r31, 0x0F	; 15
    152c:	31 97       	sbiw	r30, 0x01	; 1
    152e:	f1 f7       	brne	.-4      	; 0x152c <LCD_DisplayChar+0x32>
    1530:	00 c0       	rjmp	.+0      	; 0x1532 <LCD_DisplayChar+0x38>
    1532:	00 00       	nop
		
		/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
		_delay_ms(1);
		
		/* disable LCD E=0 */
		RESET_Bit(LCD_CONTROL_REG_OP,E);
    1534:	c2 98       	cbi	0x18, 2	; 24
    1536:	ef e9       	ldi	r30, 0x9F	; 159
    1538:	ff e0       	ldi	r31, 0x0F	; 15
    153a:	31 97       	sbiw	r30, 0x01	; 1
    153c:	f1 f7       	brne	.-4      	; 0x153a <LCD_DisplayChar+0x40>
    153e:	00 c0       	rjmp	.+0      	; 0x1540 <LCD_DisplayChar+0x46>
    1540:	00 00       	nop
		/* Data Hold delay Th = 10ns */
		_delay_ms(1);
		
		/* Reconfigure The E Pin To Prepare To Send The Next 4-bit LSB */
		SET_Bit(LCD_CONTROL_REG_OP, E);
    1542:	c2 9a       	sbi	0x18, 2	; 24
    1544:	ef e9       	ldi	r30, 0x9F	; 159
    1546:	ff e0       	ldi	r31, 0x0F	; 15
    1548:	31 97       	sbiw	r30, 0x01	; 1
    154a:	f1 f7       	brne	.-4      	; 0x1548 <LCD_DisplayChar+0x4e>
    154c:	00 c0       	rjmp	.+0      	; 0x154e <LCD_DisplayChar+0x54>
    154e:	00 00       	nop
		/* delay for processing PW min 450ns This In The Ideal State */
		_delay_ms(1);
		
		#ifdef LCD_UPPER_DATA_PORT
		/* Setup The Data Port To hold The Data By Reset the Upper Pin */
		LCD_DATA_REG_OP &= 0x0F ;
    1550:	9b b3       	in	r25, 0x1b	; 27
    1552:	9f 70       	andi	r25, 0x0F	; 15
    1554:	9b bb       	out	0x1b, r25	; 27
		LCD_DATA_REG_OP |= ((Data << 4) & 0xF0);
    1556:	9b b3       	in	r25, 0x1b	; 27
    1558:	82 95       	swap	r24
    155a:	80 7f       	andi	r24, 0xF0	; 240
    155c:	89 2b       	or	r24, r25
    155e:	8b bb       	out	0x1b, r24	; 27
    1560:	8f e9       	ldi	r24, 0x9F	; 159
    1562:	9f e0       	ldi	r25, 0x0F	; 15
    1564:	01 97       	sbiw	r24, 0x01	; 1
    1566:	f1 f7       	brne	.-4      	; 0x1564 <LCD_DisplayChar+0x6a>
    1568:	00 c0       	rjmp	.+0      	; 0x156a <LCD_DisplayChar+0x70>
    156a:	00 00       	nop
		LCD_DATA_REG_OP |= (Data & 0x0F);
		#endif
		/* Data set-up time delay  Tdsw = 195 ns This In The Ideal State */
		_delay_ms(1);
		/* disable LCD E=0 */
		RESET_Bit(LCD_CONTROL_REG_OP,E);
    156c:	c2 98       	cbi	0x18, 2	; 24
    156e:	ef e9       	ldi	r30, 0x9F	; 159
    1570:	ff e0       	ldi	r31, 0x0F	; 15
    1572:	31 97       	sbiw	r30, 0x01	; 1
    1574:	f1 f7       	brne	.-4      	; 0x1572 <LCD_DisplayChar+0x78>
    1576:	00 c0       	rjmp	.+0      	; 0x1578 <LCD_DisplayChar+0x7e>
    1578:	00 00       	nop
		/* Data Hold delay Th = 10ns This In The Ideal State*/
		_delay_ms(1);
		#endif
	}	
    157a:	08 95       	ret

0000157c <LCD_DisplayString>:
	
	
		
    void LCD_DisplayString(char * ptr)
	{
    157c:	cf 93       	push	r28
    157e:	df 93       	push	r29
    1580:	ec 01       	movw	r28, r24
		while(*ptr != '\0')
    1582:	88 81       	ld	r24, Y
    1584:	88 23       	and	r24, r24
    1586:	31 f0       	breq	.+12     	; 0x1594 <LCD_DisplayString+0x18>
		#endif
	}	
	
	
		
    void LCD_DisplayString(char * ptr)
    1588:	21 96       	adiw	r28, 0x01	; 1
	{
		while(*ptr != '\0')
		{
			LCD_DisplayChar(*ptr);
    158a:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <LCD_DisplayChar>
	
	
		
    void LCD_DisplayString(char * ptr)
	{
		while(*ptr != '\0')
    158e:	89 91       	ld	r24, Y+
    1590:	88 23       	and	r24, r24
    1592:	d9 f7       	brne	.-10     	; 0x158a <LCD_DisplayString+0xe>
		{
			LCD_DisplayChar(*ptr);
			ptr++;
		}
	}
    1594:	df 91       	pop	r29
    1596:	cf 91       	pop	r28
    1598:	08 95       	ret

0000159a <LCD_Select_RowCol>:
	
			
    void LCD_Select_RowCol(unsigned char Row , unsigned char col)
	{
		char ADDRESS = 0x00;
		switch(Row)
    159a:	81 30       	cpi	r24, 0x01	; 1
    159c:	41 f0       	breq	.+16     	; 0x15ae <LCD_Select_RowCol+0x14>
    159e:	81 30       	cpi	r24, 0x01	; 1
    15a0:	78 f0       	brcs	.+30     	; 0x15c0 <LCD_Select_RowCol+0x26>
    15a2:	82 30       	cpi	r24, 0x02	; 2
    15a4:	39 f0       	breq	.+14     	; 0x15b4 <LCD_Select_RowCol+0x1a>
    15a6:	83 30       	cpi	r24, 0x03	; 3
    15a8:	41 f0       	breq	.+16     	; 0x15ba <LCD_Select_RowCol+0x20>
	
	
			
    void LCD_Select_RowCol(unsigned char Row , unsigned char col)
	{
		char ADDRESS = 0x00;
    15aa:	80 e0       	ldi	r24, 0x00	; 0
    15ac:	0a c0       	rjmp	.+20     	; 0x15c2 <LCD_Select_RowCol+0x28>
			       /* When Writing To LCD 1st Col The Base Address is 0x00 */
			       ADDRESS= col | LCD_1ST_ROW;
			       break;
			case 1:
			      /* When Writing To LCD 1st Col The Base Address is 0x40 */
			      ADDRESS= col | LCD_2ND_ROW;
    15ae:	86 2f       	mov	r24, r22
    15b0:	80 64       	ori	r24, 0x40	; 64
			      break;
    15b2:	07 c0       	rjmp	.+14     	; 0x15c2 <LCD_Select_RowCol+0x28>
			case 2:
			       /* When Writing To LCD 1st Col The Base Address is 0x10 */
			       ADDRESS= col | LCD_3RD_ROW;
    15b4:	86 2f       	mov	r24, r22
    15b6:	80 61       	ori	r24, 0x10	; 16
			       break;
    15b8:	04 c0       	rjmp	.+8      	; 0x15c2 <LCD_Select_RowCol+0x28>
			case 3:
			       /* When Writing To LCD 1st Col The Base Address is 0x50 */
			       ADDRESS= col | LCD_4TH_ROW;
    15ba:	86 2f       	mov	r24, r22
    15bc:	80 65       	ori	r24, 0x50	; 80
			       break;
    15be:	01 c0       	rjmp	.+2      	; 0x15c2 <LCD_Select_RowCol+0x28>
		char ADDRESS = 0x00;
		switch(Row)
		{
			case 0: 
			       /* When Writing To LCD 1st Col The Base Address is 0x00 */
			       ADDRESS= col | LCD_1ST_ROW;
    15c0:	86 2f       	mov	r24, r22
			       ADDRESS= col | LCD_4TH_ROW;
			       break;
		}
		/* Form The Data Sheet it must Set The Bit 7 Before Send The Address */
		(ADDRESS) |= (1<<7);
		Send_instruction(ADDRESS);
    15c2:	80 68       	ori	r24, 0x80	; 128
    15c4:	0e 94 25 0a 	call	0x144a	; 0x144a <Send_instruction>
	}
    15c8:	08 95       	ret

000015ca <LCD_DisplayInt>:
			
    void LCD_DisplayInt(long int data)
	{
    15ca:	cf 93       	push	r28
    15cc:	df 93       	push	r29
    15ce:	cd b7       	in	r28, 0x3d	; 61
    15d0:	de b7       	in	r29, 0x3e	; 62
    15d2:	65 97       	sbiw	r28, 0x15	; 21
    15d4:	0f b6       	in	r0, 0x3f	; 63
    15d6:	f8 94       	cli
    15d8:	de bf       	out	0x3e, r29	; 62
    15da:	0f be       	out	0x3f, r0	; 63
    15dc:	cd bf       	out	0x3d, r28	; 61
    15de:	dc 01       	movw	r26, r24
    15e0:	cb 01       	movw	r24, r22
		/* String to hold the ASCI result */
		char Result[21];
		/* 10 for decimal */
		utoa(data,Result,10);
    15e2:	be 01       	movw	r22, r28
    15e4:	6f 5f       	subi	r22, 0xFF	; 255
    15e6:	7f 4f       	sbci	r23, 0xFF	; 255
    15e8:	4a e0       	ldi	r20, 0x0A	; 10
    15ea:	50 e0       	ldi	r21, 0x00	; 0
    15ec:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <utoa>
		/* Display The Result */
		LCD_DisplayString(Result);
    15f0:	ce 01       	movw	r24, r28
    15f2:	01 96       	adiw	r24, 0x01	; 1
    15f4:	0e 94 be 0a 	call	0x157c	; 0x157c <LCD_DisplayString>
	} 
    15f8:	65 96       	adiw	r28, 0x15	; 21
    15fa:	0f b6       	in	r0, 0x3f	; 63
    15fc:	f8 94       	cli
    15fe:	de bf       	out	0x3e, r29	; 62
    1600:	0f be       	out	0x3f, r0	; 63
    1602:	cd bf       	out	0x3d, r28	; 61
    1604:	df 91       	pop	r29
    1606:	cf 91       	pop	r28
    1608:	08 95       	ret

0000160a <LCD_StoreCustomchar>:
	
	void LCD_StoreCustomchar(unsigned char*pattern,unsigned char CGRAM_index)
	{
    160a:	0f 93       	push	r16
    160c:	1f 93       	push	r17
    160e:	cf 93       	push	r28
    1610:	df 93       	push	r29
    1612:	08 2f       	mov	r16, r24
    1614:	19 2f       	mov	r17, r25
		char ADDRESS = 0x00;
		char index;
		if (CGRAM_index < MAX_NWCHAR)
    1616:	68 30       	cpi	r22, 0x08	; 8
    1618:	80 f4       	brcc	.+32     	; 0x163a <LCD_StoreCustomchar+0x30>
		{
			/* We Need To Move AC To Make it Point To The CGRAM at The Address Config By The User */
			ADDRESS = CGRAM_index;
			ADDRESS |= CGRAM_CONST; /* To Set The Bit Number 6 To point On The CGRAM Address Get From Datasheet */
			Send_instruction(ADDRESS);
    161a:	86 2f       	mov	r24, r22
    161c:	80 64       	ori	r24, 0x40	; 64
    161e:	0e 94 25 0a 	call	0x144a	; 0x144a <Send_instruction>
    1622:	c0 2f       	mov	r28, r16
    1624:	d1 2f       	mov	r29, r17
			/* Note That The AC increase Automatically After Write On The Address It Point To */
			for (index = 0; index < 8; index++)
    1626:	10 e0       	ldi	r17, 0x00	; 0
			{
				LCD_DisplayChar(pattern[index]);
    1628:	89 91       	ld	r24, Y+
    162a:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <LCD_DisplayChar>
			/* We Need To Move AC To Make it Point To The CGRAM at The Address Config By The User */
			ADDRESS = CGRAM_index;
			ADDRESS |= CGRAM_CONST; /* To Set The Bit Number 6 To point On The CGRAM Address Get From Datasheet */
			Send_instruction(ADDRESS);
			/* Note That The AC increase Automatically After Write On The Address It Point To */
			for (index = 0; index < 8; index++)
    162e:	1f 5f       	subi	r17, 0xFF	; 255
    1630:	18 30       	cpi	r17, 0x08	; 8
    1632:	d1 f7       	brne	.-12     	; 0x1628 <LCD_StoreCustomchar+0x1e>
			{
				LCD_DisplayChar(pattern[index]);
			}
			/* We Need To Return The AC to point To The DDRAM */
			Send_instruction(RETURN_HOME);
    1634:	82 e0       	ldi	r24, 0x02	; 2
    1636:	0e 94 25 0a 	call	0x144a	; 0x144a <Send_instruction>
		}
	}   
    163a:	df 91       	pop	r29
    163c:	cf 91       	pop	r28
    163e:	1f 91       	pop	r17
    1640:	0f 91       	pop	r16
    1642:	08 95       	ret

00001644 <Led_Setup>:
  }
  
  
  
  void Led_Setup (Led_dataType Led)
  {
    1644:	0f 93       	push	r16
    1646:	1f 93       	push	r17
    1648:	cf 93       	push	r28
    164a:	df 93       	push	r29
    164c:	18 2f       	mov	r17, r24
    164e:	09 2f       	mov	r16, r25
    1650:	d6 2f       	mov	r29, r22
    1652:	c7 2f       	mov	r28, r23
	  /* configure The LED pin As An Output Pin */
	  DIO_pinConfiguration(Led.ledPort, Led.ledPin, Output);
    1654:	86 2f       	mov	r24, r22
    1656:	97 2f       	mov	r25, r23
    1658:	61 2f       	mov	r22, r17
    165a:	42 e0       	ldi	r20, 0x02	; 2
    165c:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  /* represent The Initial State Of The LED to Make Portability If The User Connect It Fw / Rv */ 
	  DIO_pinWrite(Led.ledPort, Led.ledPin, Led.ledIntialValue);
    1660:	8d 2f       	mov	r24, r29
    1662:	9c 2f       	mov	r25, r28
    1664:	61 2f       	mov	r22, r17
    1666:	40 2f       	mov	r20, r16
    1668:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
  }
    166c:	df 91       	pop	r29
    166e:	cf 91       	pop	r28
    1670:	1f 91       	pop	r17
    1672:	0f 91       	pop	r16
    1674:	08 95       	ret

00001676 <Led_operation>:
  void Led_operation(Led_dataType led, Led_StateType State)
  {
    1676:	1f 93       	push	r17
    1678:	cf 93       	push	r28
    167a:	df 93       	push	r29
    167c:	c8 2f       	mov	r28, r24
    167e:	86 2f       	mov	r24, r22
    1680:	97 2f       	mov	r25, r23
    1682:	16 2f       	mov	r17, r22
    1684:	d7 2f       	mov	r29, r23
	  *case <FW_ON, Rev_OFF>     <in this two case is the different in the connection of the LED with the Mc but it the same in the Mc deal with in the 2 case it output HIGH>
	  *case <Led_TOGGLE>         < in this case the led is toggling it is state so it read it intial state and toggle it >
	  *case <invalidArrgument>  < in this case the Mc can not define the state send to him so it print an error massege >
	  *
	  */
	  switch(State)
    1686:	42 30       	cpi	r20, 0x02	; 2
    1688:	18 f0       	brcs	.+6      	; 0x1690 <Led_operation+0x1a>
    168a:	43 30       	cpi	r20, 0x03	; 3
    168c:	91 f4       	brne	.+36     	; 0x16b2 <Led_operation+0x3c>
    168e:	04 c0       	rjmp	.+8      	; 0x1698 <Led_operation+0x22>
		  
	  
	     case HIGH :
	     case LOW  :
	   
	          DIO_pinWrite(led.ledPort, led.ledPin, State);
    1690:	6c 2f       	mov	r22, r28
    1692:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
	          break;
    1696:	0d c0       	rjmp	.+26     	; 0x16b2 <Led_operation+0x3c>
	     case Led_TOGGLE :
		 /* Here We Toggle The State Of The Pin */
	          DIO_pinWrite(led.ledPort, led.ledPin, !DIO_pinRead(led.ledPort, led.ledPin));
    1698:	86 2f       	mov	r24, r22
    169a:	97 2f       	mov	r25, r23
    169c:	6c 2f       	mov	r22, r28
    169e:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    16a2:	41 e0       	ldi	r20, 0x01	; 1
    16a4:	81 11       	cpse	r24, r1
    16a6:	40 e0       	ldi	r20, 0x00	; 0
    16a8:	81 2f       	mov	r24, r17
    16aa:	9d 2f       	mov	r25, r29
    16ac:	6c 2f       	mov	r22, r28
    16ae:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
	     default : Led_ErrorIndicatio(invalidArgument);
		       break;
	  }	
    16b2:	df 91       	pop	r29
    16b4:	cf 91       	pop	r28
    16b6:	1f 91       	pop	r17
    16b8:	08 95       	ret

000016ba <ErrorIndication>:
		 case invalidArgument:
		      break;
		default:
		       break;
	 }
 }
    16ba:	08 95       	ret

000016bc <PIR_setup>:
 
 
 
 void PIR_setup(PIR_dataType PIR)
 {
    16bc:	cf 93       	push	r28
    16be:	df 93       	push	r29
    16c0:	00 d0       	rcall	.+0      	; 0x16c2 <PIR_setup+0x6>
    16c2:	0f 92       	push	r0
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
    16c8:	69 83       	std	Y+1, r22	; 0x01
    16ca:	7a 83       	std	Y+2, r23	; 0x02
    16cc:	68 2f       	mov	r22, r24
    16ce:	8b 83       	std	Y+3, r24	; 0x03
	 /* Configuration The Pin Of The Sensor As an Input Float  Pin So It default Is LOW */
	 DIO_pinConfiguration(PIR.PIRport, PIR.PIRpin, InputFloat);
    16d0:	89 81       	ldd	r24, Y+1	; 0x01
    16d2:	9a 81       	ldd	r25, Y+2	; 0x02
    16d4:	40 e0       	ldi	r20, 0x00	; 0
    16d6:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
 }
    16da:	0f 90       	pop	r0
    16dc:	0f 90       	pop	r0
    16de:	0f 90       	pop	r0
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	08 95       	ret

000016e6 <PIR_operate>:
 
 
 
 DigitalValue PIR_operate (PIR_dataType PIR)
 {
    16e6:	cf 93       	push	r28
    16e8:	df 93       	push	r29
    16ea:	00 d0       	rcall	.+0      	; 0x16ec <PIR_operate+0x6>
    16ec:	0f 92       	push	r0
    16ee:	cd b7       	in	r28, 0x3d	; 61
    16f0:	de b7       	in	r29, 0x3e	; 62
    16f2:	69 83       	std	Y+1, r22	; 0x01
    16f4:	7a 83       	std	Y+2, r23	; 0x02
    16f6:	68 2f       	mov	r22, r24
    16f8:	8b 83       	std	Y+3, r24	; 0x03
	 /* read The Pin State Refer To The Condition Of The sensor If It Indicate Will return High Else Will Return Low */
	 return ( DIO_pinRead(PIR.PIRport, PIR.PIRpin) );	
    16fa:	89 81       	ldd	r24, Y+1	; 0x01
    16fc:	9a 81       	ldd	r25, Y+2	; 0x02
    16fe:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
 }
    1702:	0f 90       	pop	r0
    1704:	0f 90       	pop	r0
    1706:	0f 90       	pop	r0
    1708:	df 91       	pop	r29
    170a:	cf 91       	pop	r28
    170c:	08 95       	ret

0000170e <PushButton_setup>:
   static DigitalValue Push_default_State;



  void PushButton_setup(PushButton_datatype *Pswitch)
  {
    170e:	cf 93       	push	r28
    1710:	df 93       	push	r29
    1712:	ec 01       	movw	r28, r24
	  /* Configuration The Pin Of The Push Button As User State Set  */
	  DIO_pinConfiguration(Pswitch->IO_PORT, Pswitch->IO_PIN, Pswitch->InputMode);
    1714:	88 81       	ld	r24, Y
    1716:	99 81       	ldd	r25, Y+1	; 0x01
    1718:	6a 81       	ldd	r22, Y+2	; 0x02
    171a:	4b 81       	ldd	r20, Y+3	; 0x03
    171c:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  /* Setup The TH Previous State Of The Push Button As A Current State When It Just Configure */
	  Pswitch->PREV_Level = DIO_pinRead(Pswitch->IO_PORT,Pswitch->IO_PIN);
    1720:	88 81       	ld	r24, Y
    1722:	99 81       	ldd	r25, Y+1	; 0x01
    1724:	6a 81       	ldd	r22, Y+2	; 0x02
    1726:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    172a:	8c 83       	std	Y+4, r24	; 0x04
	  //setup the default state of the button to know when it pressed or released 
	  Push_default_State = Pswitch->PREV_Level;  
    172c:	80 93 a3 00 	sts	0x00A3, r24
  }
    1730:	df 91       	pop	r29
    1732:	cf 91       	pop	r28
    1734:	08 95       	ret

00001736 <PushButton_read>:
  
  
  
  
  PUSH_States PushButton_read(PushButton_datatype *Pswitch)
  {
    1736:	1f 93       	push	r17
    1738:	cf 93       	push	r28
    173a:	df 93       	push	r29
    173c:	ec 01       	movw	r28, r24
	  /* If The User do Not Change The PREV_Level that Mean It Do not press The PushButton Yet So It Will Return It Not Pressed State*/ 
	  PUSH_States returnState = PUSH_NOT_PRESSED;
	  if (Pswitch->PREV_Level != DIO_pinRead(Pswitch->IO_PORT,Pswitch->IO_PIN))
    173e:	1c 81       	ldd	r17, Y+4	; 0x04
    1740:	88 81       	ld	r24, Y
    1742:	99 81       	ldd	r25, Y+1	; 0x01
    1744:	6a 81       	ldd	r22, Y+2	; 0x02
    1746:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    174a:	18 17       	cp	r17, r24
    174c:	e9 f0       	breq	.+58     	; 0x1788 <PushButton_read+0x52>
    174e:	8f ef       	ldi	r24, 0xFF	; 255
    1750:	90 e7       	ldi	r25, 0x70	; 112
    1752:	a2 e0       	ldi	r26, 0x02	; 2
    1754:	81 50       	subi	r24, 0x01	; 1
    1756:	90 40       	sbci	r25, 0x00	; 0
    1758:	a0 40       	sbci	r26, 0x00	; 0
    175a:	e1 f7       	brne	.-8      	; 0x1754 <PushButton_read+0x1e>
    175c:	00 c0       	rjmp	.+0      	; 0x175e <PushButton_read+0x28>
    175e:	00 00       	nop
	  {
		  // the average pressed of the human is 500 ms to make sure it not ripple 
		  _delay_ms(Push_Bouncing_Periode_mS);       
		  // to make sure that is not a mess signal
		   if (Pswitch->PREV_Level != DIO_pinRead(Pswitch->IO_PORT,Pswitch->IO_PIN)) 
    1760:	1c 81       	ldd	r17, Y+4	; 0x04
    1762:	88 81       	ld	r24, Y
    1764:	99 81       	ldd	r25, Y+1	; 0x01
    1766:	6a 81       	ldd	r22, Y+2	; 0x02
    1768:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    176c:	18 17       	cp	r17, r24
    176e:	71 f0       	breq	.+28     	; 0x178c <PushButton_read+0x56>
		   {
			   Pswitch->PREV_Level = DIO_pinRead(Pswitch->IO_PORT,Pswitch->IO_PIN);
    1770:	88 81       	ld	r24, Y
    1772:	99 81       	ldd	r25, Y+1	; 0x01
    1774:	6a 81       	ldd	r22, Y+2	; 0x02
    1776:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    177a:	8c 83       	std	Y+4, r24	; 0x04
			   if (Pswitch->PREV_Level != Push_default_State)
    177c:	90 91 a3 00 	lds	r25, 0x00A3
    1780:	89 17       	cp	r24, r25
    1782:	31 f0       	breq	.+12     	; 0x1790 <PushButton_read+0x5a>
			   {
				   returnState = PUSH_PRESSED;
    1784:	81 e0       	ldi	r24, 0x01	; 1
    1786:	05 c0       	rjmp	.+10     	; 0x1792 <PushButton_read+0x5c>
  
  
  PUSH_States PushButton_read(PushButton_datatype *Pswitch)
  {
	  /* If The User do Not Change The PREV_Level that Mean It Do not press The PushButton Yet So It Will Return It Not Pressed State*/ 
	  PUSH_States returnState = PUSH_NOT_PRESSED;
    1788:	80 e0       	ldi	r24, 0x00	; 0
    178a:	03 c0       	rjmp	.+6      	; 0x1792 <PushButton_read+0x5c>
    178c:	80 e0       	ldi	r24, 0x00	; 0
    178e:	01 c0       	rjmp	.+2      	; 0x1792 <PushButton_read+0x5c>
				   returnState = PUSH_PRESSED;
			   }
			   else
			   {
				   /* If The PREV_Leve(Pin Current Read ) equal The Default State That Mean That The Push ButtonWas Pressed And Released */
				   returnState = PUSH_RELEASED;
    1790:	82 e0       	ldi	r24, 0x02	; 2
			   }				   
		   }
	  }
	  return returnState;
    1792:	df 91       	pop	r29
    1794:	cf 91       	pop	r28
    1796:	1f 91       	pop	r17
    1798:	08 95       	ret

0000179a <Relay_SETUP>:
   
   
   
   
  void Relay_SETUP (Relay_dataType relay)
  {
    179a:	0f 93       	push	r16
    179c:	1f 93       	push	r17
    179e:	cf 93       	push	r28
    17a0:	df 93       	push	r29
    17a2:	18 2f       	mov	r17, r24
    17a4:	09 2f       	mov	r16, r25
    17a6:	d6 2f       	mov	r29, r22
    17a8:	c7 2f       	mov	r28, r23
	  // if the relay is reversed NO and NC that mean it operate a micro sec then stop because the initial condition of Output is 0 
	  DIO_pinConfiguration(relay.signalPort, relay.signalPin, Output); 
    17aa:	86 2f       	mov	r24, r22
    17ac:	97 2f       	mov	r25, r23
    17ae:	61 2f       	mov	r22, r17
    17b0:	42 e0       	ldi	r20, 0x02	; 2
    17b2:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	  /* represent The Relay Intial Value */ 
	  DIO_pinWrite(relay.signalPort, relay.signalPin, relay.intialeValue);
    17b6:	8d 2f       	mov	r24, r29
    17b8:	9c 2f       	mov	r25, r28
    17ba:	61 2f       	mov	r22, r17
    17bc:	40 2f       	mov	r20, r16
    17be:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
  }
    17c2:	df 91       	pop	r29
    17c4:	cf 91       	pop	r28
    17c6:	1f 91       	pop	r17
    17c8:	0f 91       	pop	r16
    17ca:	08 95       	ret

000017cc <Relay_Operate>:
  
  
  
  
  void Relay_Operate(Relay_dataType relay, RELAY_STATE signal)
  {
    17cc:	28 2f       	mov	r18, r24
	  *case <standardNO, RevNC>     <in this two case is the different in the connection of the Relay with the Mc but it the same in the Mc deal with in the 2 case it output LOW>
	  *case <standardNC, RevNO>     <in this two case is the different in the connection of the Relay with the Mc but it the same in the Mc deal with in the 2 case it output HIGH>
	  *case <invalidArrgument>      <in this case the Mc can not define the state send to him so it print an error massege >
	  *
	  */
	  switch (signal)
    17ce:	42 30       	cpi	r20, 0x02	; 2
    17d0:	28 f4       	brcc	.+10     	; 0x17dc <Relay_Operate+0x10>
	  {
		  case HIGH :
		  case LOW  :
		       DIO_pinWrite(relay.signalPort, relay.signalPin, signal);
    17d2:	86 2f       	mov	r24, r22
    17d4:	97 2f       	mov	r25, r23
    17d6:	62 2f       	mov	r22, r18
    17d8:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
    17dc:	08 95       	ret

000017de <SERVO_WRITE>:
     void SERVO_WRITE(double t, unsigned char servo_name)
	 {
		 
		 
		 /* Select the mode fast PWM as ICR1 top decimal 14*/
		 SET_Bit(TCCR1A,WGM11);
    17de:	2f b5       	in	r18, 0x2f	; 47
    17e0:	22 60       	ori	r18, 0x02	; 2
    17e2:	2f bd       	out	0x2f, r18	; 47
		 SET_Bit(TCCR1B,WGM12);
    17e4:	2e b5       	in	r18, 0x2e	; 46
    17e6:	28 60       	ori	r18, 0x08	; 8
    17e8:	2e bd       	out	0x2e, r18	; 46
		 SET_Bit(TCCR1B,WGM13);
    17ea:	2e b5       	in	r18, 0x2e	; 46
    17ec:	20 61       	ori	r18, 0x10	; 16
    17ee:	2e bd       	out	0x2e, r18	; 46
		 
		 /* LOAD The Value of the ICR1  */
		 
		 /* Store this value on the ICR1 that we make it the timer Top value so when it reach this value that mean that the 20msec is end the timer get overflow */
		 ICR1 = Counts_20msecSignal_Num;
    17f0:	28 e8       	ldi	r18, 0x88	; 136
    17f2:	33 e1       	ldi	r19, 0x13	; 19
    17f4:	37 bd       	out	0x27, r19	; 39
    17f6:	26 bd       	out	0x26, r18	; 38
		 
		 /* Set the timer clock as 64 is a prescaler that to avoid make the value of the number float to take more accuracy value */
		 SET_Bit(TCCR1B,CS10);
    17f8:	2e b5       	in	r18, 0x2e	; 46
    17fa:	21 60       	ori	r18, 0x01	; 1
    17fc:	2e bd       	out	0x2e, r18	; 46
		 SET_Bit(TCCR1B,CS11);
    17fe:	2e b5       	in	r18, 0x2e	; 46
    1800:	22 60       	ori	r18, 0x02	; 2
    1802:	2e bd       	out	0x2e, r18	; 46
		
		 switch(servo_name)
    1804:	41 34       	cpi	r20, 0x41	; 65
    1806:	19 f0       	breq	.+6      	; 0x180e <SERVO_WRITE+0x30>
    1808:	42 34       	cpi	r20, 0x42	; 66
    180a:	a1 f5       	brne	.+104    	; 0x1874 <SERVO_WRITE+0x96>
    180c:	1a c0       	rjmp	.+52     	; 0x1842 <SERVO_WRITE+0x64>
		 {
			 case 'A':
			       /* The value of the 1msec counts to define the ON time of output signal to decide the place of the Servo*/
			       OCR1A = t * Counts_1msec_Num;
    180e:	20 e0       	ldi	r18, 0x00	; 0
    1810:	30 e0       	ldi	r19, 0x00	; 0
    1812:	4a e7       	ldi	r20, 0x7A	; 122
    1814:	53 e4       	ldi	r21, 0x43	; 67
    1816:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
    181a:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <__fixunssfsi>
    181e:	dc 01       	movw	r26, r24
    1820:	cb 01       	movw	r24, r22
    1822:	9b bd       	out	0x2b, r25	; 43
    1824:	8a bd       	out	0x2a, r24	; 42
				   
				    /* Work at the non inverting Mode */
				    SET_Bit(TCCR1A, COM1A1);
    1826:	8f b5       	in	r24, 0x2f	; 47
    1828:	80 68       	ori	r24, 0x80	; 128
    182a:	8f bd       	out	0x2f, r24	; 47
					/* Set The OC1A as an Output */
					DIO_pinConfiguration(GPIOD, PIN5, Output);
    182c:	80 e3       	ldi	r24, 0x30	; 48
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	65 e0       	ldi	r22, 0x05	; 5
    1832:	42 e0       	ldi	r20, 0x02	; 2
    1834:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1838:	85 e3       	ldi	r24, 0x35	; 53
    183a:	8a 95       	dec	r24
    183c:	f1 f7       	brne	.-4      	; 0x183a <SERVO_WRITE+0x5c>
    183e:	00 00       	nop
    1840:	08 95       	ret
					_delay_us(10);
			 break;
			 case 'B':
			       /* The value of the 1msec counts to define the ON time of output signal to decide the place of the Servo*/
			       OCR1B = t * Counts_1msec_Num;
    1842:	20 e0       	ldi	r18, 0x00	; 0
    1844:	30 e0       	ldi	r19, 0x00	; 0
    1846:	4a e7       	ldi	r20, 0x7A	; 122
    1848:	53 e4       	ldi	r21, 0x43	; 67
    184a:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
    184e:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <__fixunssfsi>
    1852:	dc 01       	movw	r26, r24
    1854:	cb 01       	movw	r24, r22
    1856:	99 bd       	out	0x29, r25	; 41
    1858:	88 bd       	out	0x28, r24	; 40
			       
			       /* Work at the non inverting Mode */
			       SET_Bit(TCCR1A, COM1B1);
    185a:	8f b5       	in	r24, 0x2f	; 47
    185c:	80 62       	ori	r24, 0x20	; 32
    185e:	8f bd       	out	0x2f, r24	; 47
				   
				   /* Set The OC1A as an Output */
				   DIO_pinConfiguration(GPIOD, PIN4, Output);
    1860:	80 e3       	ldi	r24, 0x30	; 48
    1862:	90 e0       	ldi	r25, 0x00	; 0
    1864:	64 e0       	ldi	r22, 0x04	; 4
    1866:	42 e0       	ldi	r20, 0x02	; 2
    1868:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
    186c:	85 e3       	ldi	r24, 0x35	; 53
    186e:	8a 95       	dec	r24
    1870:	f1 f7       	brne	.-4      	; 0x186e <SERVO_WRITE+0x90>
    1872:	00 00       	nop
    1874:	08 95       	ret

00001876 <interrupt_Function2>:
	  }
  }
  static void interrupt_Function2(void)
  {
	  unsigned short time_ON;
	  if (flag_2 == 0)
    1876:	80 91 a4 00 	lds	r24, 0x00A4
    187a:	88 23       	and	r24, r24
    187c:	91 f4       	brne	.+36     	; 0x18a2 <interrupt_Function2+0x2c>
	  {
		  TIMER_INTIATE(t_counter2);
    187e:	60 91 60 00 	lds	r22, 0x0060
    1882:	70 91 61 00 	lds	r23, 0x0061
    1886:	80 91 62 00 	lds	r24, 0x0062
    188a:	90 91 63 00 	lds	r25, 0x0063
    188e:	0e 94 16 03 	call	0x62c	; 0x62c <TIMER_INTIATE>
		  EXTINT_InterruptInit(EXINT_INT1, EXINT_FallingEdge);
    1892:	81 e0       	ldi	r24, 0x01	; 1
    1894:	62 e0       	ldi	r22, 0x02	; 2
    1896:	0e 94 ed 01 	call	0x3da	; 0x3da <EXTINT_InterruptInit>
		  flag_2 = 1;
    189a:	81 e0       	ldi	r24, 0x01	; 1
    189c:	80 93 a4 00 	sts	0x00A4, r24
    18a0:	08 95       	ret
	  }
	  else if(flag_2 == 1)
    18a2:	80 91 a4 00 	lds	r24, 0x00A4
    18a6:	81 30       	cpi	r24, 0x01	; 1
    18a8:	d9 f5       	brne	.+118    	; 0x1920 <interrupt_Function2+0xaa>
	  {
		  TCCR2 = 0;
    18aa:	15 bc       	out	0x25, r1	; 37
		  if (READ_Bit(TIFR,TOV2) == 1)
    18ac:	08 b6       	in	r0, 0x38	; 56
    18ae:	06 fe       	sbrs	r0, 6
    18b0:	1c c0       	rjmp	.+56     	; 0x18ea <interrupt_Function2+0x74>
		  {
			  /* To solve the Problem of the Overflow the counter before get the maximum distance */
			  Object_distance2 = (TCNT2 + 255) * 1.1072;
    18b2:	64 b5       	in	r22, 0x24	; 36
    18b4:	70 e0       	ldi	r23, 0x00	; 0
    18b6:	61 50       	subi	r22, 0x01	; 1
    18b8:	7f 4f       	sbci	r23, 0xFF	; 255
    18ba:	88 27       	eor	r24, r24
    18bc:	77 fd       	sbrc	r23, 7
    18be:	80 95       	com	r24
    18c0:	98 2f       	mov	r25, r24
    18c2:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <__floatsisf>
    18c6:	2b eb       	ldi	r18, 0xBB	; 187
    18c8:	38 eb       	ldi	r19, 0xB8	; 184
    18ca:	4d e8       	ldi	r20, 0x8D	; 141
    18cc:	5f e3       	ldi	r21, 0x3F	; 63
    18ce:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
    18d2:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <__fixsfsi>
    18d6:	dc 01       	movw	r26, r24
    18d8:	cb 01       	movw	r24, r22
    18da:	90 93 ae 00 	sts	0x00AE, r25
    18de:	80 93 ad 00 	sts	0x00AD, r24
			  /* CLear the flag Manually by Write a One */
			  SET_Bit(TIFR,TOV2);
    18e2:	88 b7       	in	r24, 0x38	; 56
    18e4:	80 64       	ori	r24, 0x40	; 64
    18e6:	88 bf       	out	0x38, r24	; 56
    18e8:	14 c0       	rjmp	.+40     	; 0x1912 <interrupt_Function2+0x9c>
		  }
		  else
		  {
			  Object_distance2 = TCNT2 * 1.1072;
    18ea:	64 b5       	in	r22, 0x24	; 36
    18ec:	70 e0       	ldi	r23, 0x00	; 0
    18ee:	80 e0       	ldi	r24, 0x00	; 0
    18f0:	90 e0       	ldi	r25, 0x00	; 0
    18f2:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <__floatsisf>
    18f6:	2b eb       	ldi	r18, 0xBB	; 187
    18f8:	38 eb       	ldi	r19, 0xB8	; 184
    18fa:	4d e8       	ldi	r20, 0x8D	; 141
    18fc:	5f e3       	ldi	r21, 0x3F	; 63
    18fe:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
    1902:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <__fixsfsi>
    1906:	dc 01       	movw	r26, r24
    1908:	cb 01       	movw	r24, r22
    190a:	90 93 ae 00 	sts	0x00AE, r25
    190e:	80 93 ad 00 	sts	0x00AD, r24
		  }
		  EXTINT_InterruptInit(EXINT_INT1, EXINT_RisingEdge);
    1912:	81 e0       	ldi	r24, 0x01	; 1
    1914:	63 e0       	ldi	r22, 0x03	; 3
    1916:	0e 94 ed 01 	call	0x3da	; 0x3da <EXTINT_InterruptInit>
		  flag_2 = 0;
    191a:	10 92 a4 00 	sts	0x00A4, r1
		  TCNT2 = 0;
    191e:	14 bc       	out	0x24, r1	; 36
    1920:	08 95       	ret

00001922 <interrupt_Function>:
    short Object_distance2;
  
  static void interrupt_Function(void)
  {
	  unsigned short time_ON;
	  if (flag_1 == 0)
    1922:	80 91 a5 00 	lds	r24, 0x00A5
    1926:	88 23       	and	r24, r24
    1928:	91 f4       	brne	.+36     	; 0x194e <interrupt_Function+0x2c>
	  {
		  TIMER_INTIATE(t_counter1);
    192a:	60 91 64 00 	lds	r22, 0x0064
    192e:	70 91 65 00 	lds	r23, 0x0065
    1932:	80 91 66 00 	lds	r24, 0x0066
    1936:	90 91 67 00 	lds	r25, 0x0067
    193a:	0e 94 16 03 	call	0x62c	; 0x62c <TIMER_INTIATE>
		 EXTINT_InterruptInit(EXINT_INT0, EXINT_FallingEdge);
    193e:	80 e0       	ldi	r24, 0x00	; 0
    1940:	62 e0       	ldi	r22, 0x02	; 2
    1942:	0e 94 ed 01 	call	0x3da	; 0x3da <EXTINT_InterruptInit>
		  flag_1 = 1;
    1946:	81 e0       	ldi	r24, 0x01	; 1
    1948:	80 93 a5 00 	sts	0x00A5, r24
    194c:	08 95       	ret
	  }
	  else if(flag_1 == 1)
    194e:	80 91 a5 00 	lds	r24, 0x00A5
    1952:	81 30       	cpi	r24, 0x01	; 1
    1954:	d9 f5       	brne	.+118    	; 0x19cc <interrupt_Function+0xaa>
	  {
		  TCCR0 = 0; 
    1956:	13 be       	out	0x33, r1	; 51
		  if (READ_Bit(TIFR,TOV0) == 1)
    1958:	08 b6       	in	r0, 0x38	; 56
    195a:	00 fe       	sbrs	r0, 0
    195c:	1c c0       	rjmp	.+56     	; 0x1996 <interrupt_Function+0x74>
		  {
			  /* To solve the Problem of the Overflow the counter before get the maximum distance */
			  Object_distance1 = (TCNT0 + 255) * 1.1072;
    195e:	62 b7       	in	r22, 0x32	; 50
    1960:	70 e0       	ldi	r23, 0x00	; 0
    1962:	61 50       	subi	r22, 0x01	; 1
    1964:	7f 4f       	sbci	r23, 0xFF	; 255
    1966:	88 27       	eor	r24, r24
    1968:	77 fd       	sbrc	r23, 7
    196a:	80 95       	com	r24
    196c:	98 2f       	mov	r25, r24
    196e:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <__floatsisf>
    1972:	2b eb       	ldi	r18, 0xBB	; 187
    1974:	38 eb       	ldi	r19, 0xB8	; 184
    1976:	4d e8       	ldi	r20, 0x8D	; 141
    1978:	5f e3       	ldi	r21, 0x3F	; 63
    197a:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
    197e:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <__fixsfsi>
    1982:	dc 01       	movw	r26, r24
    1984:	cb 01       	movw	r24, r22
    1986:	90 93 ac 00 	sts	0x00AC, r25
    198a:	80 93 ab 00 	sts	0x00AB, r24
			  /* CLear the flag Manually by Write a One */
			  SET_Bit(TIFR,TOV0);
    198e:	88 b7       	in	r24, 0x38	; 56
    1990:	81 60       	ori	r24, 0x01	; 1
    1992:	88 bf       	out	0x38, r24	; 56
    1994:	14 c0       	rjmp	.+40     	; 0x19be <interrupt_Function+0x9c>
		  }
		  else
		  {
			  Object_distance1 = TCNT0 * 1.1072;
    1996:	62 b7       	in	r22, 0x32	; 50
    1998:	70 e0       	ldi	r23, 0x00	; 0
    199a:	80 e0       	ldi	r24, 0x00	; 0
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <__floatsisf>
    19a2:	2b eb       	ldi	r18, 0xBB	; 187
    19a4:	38 eb       	ldi	r19, 0xB8	; 184
    19a6:	4d e8       	ldi	r20, 0x8D	; 141
    19a8:	5f e3       	ldi	r21, 0x3F	; 63
    19aa:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
    19ae:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <__fixsfsi>
    19b2:	dc 01       	movw	r26, r24
    19b4:	cb 01       	movw	r24, r22
    19b6:	90 93 ac 00 	sts	0x00AC, r25
    19ba:	80 93 ab 00 	sts	0x00AB, r24
		  }
		  EXTINT_InterruptInit(EXINT_INT0, EXINT_RisingEdge);	
    19be:	80 e0       	ldi	r24, 0x00	; 0
    19c0:	63 e0       	ldi	r22, 0x03	; 3
    19c2:	0e 94 ed 01 	call	0x3da	; 0x3da <EXTINT_InterruptInit>
		  flag_1 = 0;
    19c6:	10 92 a5 00 	sts	0x00A5, r1
		  TCNT0 = 0;
    19ca:	12 be       	out	0x32, r1	; 50
    19cc:	08 95       	ret

000019ce <ULTRASONIC_Setup>:
		  
	  }
  }
  
     void ULTRASONIC_Setup(ULTRASONIC_DATATYPE U)
	 {
    19ce:	0f 93       	push	r16
    19d0:	1f 93       	push	r17
    19d2:	cf 93       	push	r28
    19d4:	df 93       	push	r29
    19d6:	26 2f       	mov	r18, r22
    19d8:	68 2f       	mov	r22, r24
    19da:	19 2f       	mov	r17, r25
    19dc:	d2 2f       	mov	r29, r18
    19de:	c7 2f       	mov	r28, r23
		 /* Make the trigger pin output  */
		 DIO_pinConfiguration(U.ultrasonic_port, U.ultrasonic_Trig, Output);
    19e0:	82 2f       	mov	r24, r18
    19e2:	97 2f       	mov	r25, r23
    19e4:	42 e0       	ldi	r20, 0x02	; 2
    19e6:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
		 
		 /* Make the Echo Pin input Note that it must be on of the External interrupt Pin PB2, PD2, PD3 */
		 DIO_pinConfiguration(U.ultrasonic_port, U.ultrasonic_Echo, InputFloat);
    19ea:	8d 2f       	mov	r24, r29
    19ec:	9c 2f       	mov	r25, r28
    19ee:	61 2f       	mov	r22, r17
    19f0:	40 e0       	ldi	r20, 0x00	; 0
    19f2:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
    19f6:	8f ec       	ldi	r24, 0xCF	; 207
    19f8:	97 e0       	ldi	r25, 0x07	; 7
    19fa:	01 97       	sbiw	r24, 0x01	; 1
    19fc:	f1 f7       	brne	.-4      	; 0x19fa <ULTRASONIC_Setup+0x2c>
    19fe:	00 c0       	rjmp	.+0      	; 0x1a00 <ULTRASONIC_Setup+0x32>
    1a00:	00 00       	nop
		 
		 _delay_us(500);
		 /* Setup the interrupt pin depend on the user Selection (We Work at INT0, INT1 until handle INT2 ) */
		 switch(U.ultrasonic_Echo)
    1a02:	12 30       	cpi	r17, 0x02	; 2
    1a04:	19 f0       	breq	.+6      	; 0x1a0c <ULTRASONIC_Setup+0x3e>
    1a06:	13 30       	cpi	r17, 0x03	; 3
    1a08:	b1 f4       	brne	.+44     	; 0x1a36 <ULTRASONIC_Setup+0x68>
    1a0a:	0b c0       	rjmp	.+22     	; 0x1a22 <ULTRASONIC_Setup+0x54>
		 {
			 case PIN2 :
			      /* in this case we Setup the External interrupt Source number 0 */
				  EXTINT_InterruptInit(EXINT_INT0, EXINT_RisingEdge);
    1a0c:	80 e0       	ldi	r24, 0x00	; 0
    1a0e:	63 e0       	ldi	r22, 0x03	; 3
    1a10:	0e 94 ed 01 	call	0x3da	; 0x3da <EXTINT_InterruptInit>
				  /* set the ISR Function depend on the user external interrupt choose */
				  EXTINT0_ISR = interrupt_Function;
    1a14:	81 e9       	ldi	r24, 0x91	; 145
    1a16:	9c e0       	ldi	r25, 0x0C	; 12
    1a18:	90 93 77 00 	sts	0x0077, r25
    1a1c:	80 93 76 00 	sts	0x0076, r24
			 break;
    1a20:	0a c0       	rjmp	.+20     	; 0x1a36 <ULTRASONIC_Setup+0x68>
			 case PIN3 :
			      /* in this case we Setup the External interrupt Source number 1 */
			      EXTINT_InterruptInit(EXINT_INT1, EXINT_RisingEdge);
    1a22:	81 e0       	ldi	r24, 0x01	; 1
    1a24:	63 e0       	ldi	r22, 0x03	; 3
    1a26:	0e 94 ed 01 	call	0x3da	; 0x3da <EXTINT_InterruptInit>
				  /* set the ISR Function depend on the user external interrupt choose */
				  EXTINT1_ISR = interrupt_Function2;
    1a2a:	8b e3       	ldi	r24, 0x3B	; 59
    1a2c:	9c e0       	ldi	r25, 0x0C	; 12
    1a2e:	90 93 75 00 	sts	0x0075, r25
    1a32:	80 93 74 00 	sts	0x0074, r24
			 /* Handle the error if the user select an Wrong pin to work as Echo pin */
			 break;
		 }
		 	
		 /* Enable the Global Interrupt */
		 SREG |= (1 << 7);		 
    1a36:	8f b7       	in	r24, 0x3f	; 63
    1a38:	80 68       	ori	r24, 0x80	; 128
    1a3a:	8f bf       	out	0x3f, r24	; 63
	 }		 
    1a3c:	df 91       	pop	r29
    1a3e:	cf 91       	pop	r28
    1a40:	1f 91       	pop	r17
    1a42:	0f 91       	pop	r16
    1a44:	08 95       	ret

00001a46 <ULTRASONIC_OPERATE>:
     unsigned short ULTRASONIC_OPERATE (ULTRASONIC_DATATYPE U)
	 {
    1a46:	0f 93       	push	r16
    1a48:	1f 93       	push	r17
    1a4a:	cf 93       	push	r28
    1a4c:	df 93       	push	r29
    1a4e:	18 2f       	mov	r17, r24
    1a50:	09 2f       	mov	r16, r25
		 unsigned short distance = 0x00;
    1a52:	d6 2f       	mov	r29, r22
    1a54:	c7 2f       	mov	r28, r23
		 /* start with send the trigger signal */
		 DIO_pinWrite(U.ultrasonic_port,U.ultrasonic_Trig, HIGH);
    1a56:	86 2f       	mov	r24, r22
    1a58:	97 2f       	mov	r25, r23
    1a5a:	61 2f       	mov	r22, r17
    1a5c:	41 e0       	ldi	r20, 0x01	; 1
    1a5e:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
    1a62:	80 e5       	ldi	r24, 0x50	; 80
    1a64:	8a 95       	dec	r24
    1a66:	f1 f7       	brne	.-4      	; 0x1a64 <ULTRASONIC_OPERATE+0x1e>
		 /* Make The pulse time ON is 10Usec */
		 _delay_us(15);
		 /* Return it to LOW again to be one pulse */
		  DIO_pinWrite(U.ultrasonic_port,U.ultrasonic_Trig, LOW);
    1a68:	8d 2f       	mov	r24, r29
    1a6a:	9c 2f       	mov	r25, r28
    1a6c:	61 2f       	mov	r22, r17
    1a6e:	40 e0       	ldi	r20, 0x00	; 0
    1a70:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		  switch(U.ultrasonic_Echo)
    1a74:	02 30       	cpi	r16, 0x02	; 2
    1a76:	19 f0       	breq	.+6      	; 0x1a7e <ULTRASONIC_OPERATE+0x38>
    1a78:	03 30       	cpi	r16, 0x03	; 3
    1a7a:	59 f4       	brne	.+22     	; 0x1a92 <ULTRASONIC_OPERATE+0x4c>
    1a7c:	05 c0       	rjmp	.+10     	; 0x1a88 <ULTRASONIC_OPERATE+0x42>
		  {
			  case PIN2:
			  distance = Object_distance1 ;
    1a7e:	80 91 ab 00 	lds	r24, 0x00AB
    1a82:	90 91 ac 00 	lds	r25, 0x00AC
			  break;
    1a86:	07 c0       	rjmp	.+14     	; 0x1a96 <ULTRASONIC_OPERATE+0x50>
			  case PIN3:
			  distance = Object_distance2;
    1a88:	80 91 ad 00 	lds	r24, 0x00AD
    1a8c:	90 91 ae 00 	lds	r25, 0x00AE
			  break;
    1a90:	02 c0       	rjmp	.+4      	; 0x1a96 <ULTRASONIC_OPERATE+0x50>
		 /* Enable the Global Interrupt */
		 SREG |= (1 << 7);		 
	 }		 
     unsigned short ULTRASONIC_OPERATE (ULTRASONIC_DATATYPE U)
	 {
		 unsigned short distance = 0x00;
    1a92:	80 e0       	ldi	r24, 0x00	; 0
    1a94:	90 e0       	ldi	r25, 0x00	; 0
			  break;
			  default:
			  break;
		  }
		  return distance;
	 }
    1a96:	df 91       	pop	r29
    1a98:	cf 91       	pop	r28
    1a9a:	1f 91       	pop	r17
    1a9c:	0f 91       	pop	r16
    1a9e:	08 95       	ret

00001aa0 <HomeSlave_INT>:

void HomeSlave_INT(void)
{
		
	/* Temperature sensor setup */
	ADC_INTIATE(analog_signal);
    1aa0:	40 91 6c 00 	lds	r20, 0x006C
    1aa4:	50 91 6d 00 	lds	r21, 0x006D
    1aa8:	60 91 6e 00 	lds	r22, 0x006E
    1aac:	70 91 6f 00 	lds	r23, 0x006F
    1ab0:	80 91 70 00 	lds	r24, 0x0070
    1ab4:	90 91 71 00 	lds	r25, 0x0071
    1ab8:	0e 94 7c 00 	call	0xf8	; 0xf8 <ADC_INTIATE>
	
	/* set up the SPI communication to send and receive the data from the Slave */
	SPI_communcation.EnableControl = SPI_Enable;
    1abc:	81 e0       	ldi	r24, 0x01	; 1
    1abe:	80 93 78 00 	sts	0x0078, r24
	SPI_communcation.DataOreder = SPI_MSB;
    1ac2:	10 92 7b 00 	sts	0x007B, r1
	SPI_communcation.ModeSelect = SPI_SLAVE;
    1ac6:	10 92 79 00 	sts	0x0079, r1
	SPI_communcation.ClkMode = SPI_ClkMode0;
    1aca:	10 92 7c 00 	sts	0x007C, r1
	//SPI_communcation.InterruptState = SPI_InterruptDisable;
	//SPI_communcation.SCKFreq = SPI_FCPU_By_2;
	SPI_Intiat();
    1ace:	0e 94 7e 02 	call	0x4fc	; 0x4fc <SPI_Intiat>
	
	/* operate the count of the Timer */
	TIMER_INTIATE(counter);
    1ad2:	60 91 68 00 	lds	r22, 0x0068
    1ad6:	70 91 69 00 	lds	r23, 0x0069
    1ada:	80 91 6a 00 	lds	r24, 0x006A
    1ade:	90 91 6b 00 	lds	r25, 0x006B
    1ae2:	0e 94 16 03 	call	0x62c	; 0x62c <TIMER_INTIATE>
	/* set up the CTC top value on it is register */
	TIMER_DELAY(counter, TOP_CTC_VALUE);
    1ae6:	60 91 68 00 	lds	r22, 0x0068
    1aea:	70 91 69 00 	lds	r23, 0x0069
    1aee:	80 91 6a 00 	lds	r24, 0x006A
    1af2:	90 91 6b 00 	lds	r25, 0x006B
    1af6:	4c e9       	ldi	r20, 0x9C	; 156
    1af8:	0e 94 a6 03 	call	0x74c	; 0x74c <TIMER_DELAY>
	
	/* Rooms 1,2,3,4 LED's setup on the pin 4,5,6,7 port D */
	DIO_pinConfiguration(ROOMs_PORT, ROOM1_PIN, Output);
    1afc:	80 e3       	ldi	r24, 0x30	; 48
    1afe:	90 e0       	ldi	r25, 0x00	; 0
    1b00:	64 e0       	ldi	r22, 0x04	; 4
    1b02:	42 e0       	ldi	r20, 0x02	; 2
    1b04:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	DIO_pinConfiguration(ROOMs_PORT, ROOM2_PIN, Output);
    1b08:	80 e3       	ldi	r24, 0x30	; 48
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	65 e0       	ldi	r22, 0x05	; 5
    1b0e:	42 e0       	ldi	r20, 0x02	; 2
    1b10:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	DIO_pinConfiguration(ROOMs_PORT, ROOM3_PIN, Output);
    1b14:	80 e3       	ldi	r24, 0x30	; 48
    1b16:	90 e0       	ldi	r25, 0x00	; 0
    1b18:	66 e0       	ldi	r22, 0x06	; 6
    1b1a:	42 e0       	ldi	r20, 0x02	; 2
    1b1c:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	DIO_pinConfiguration(ROOMs_PORT, ROOM4_PIN, Output);
    1b20:	80 e3       	ldi	r24, 0x30	; 48
    1b22:	90 e0       	ldi	r25, 0x00	; 0
    1b24:	67 e0       	ldi	r22, 0x07	; 7
    1b26:	42 e0       	ldi	r20, 0x02	; 2
    1b28:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	
	/* TV setup */
	DIO_pinConfiguration(TV_PORT, TV_PIN, Output);
    1b2c:	83 e3       	ldi	r24, 0x33	; 51
    1b2e:	90 e0       	ldi	r25, 0x00	; 0
    1b30:	60 e0       	ldi	r22, 0x00	; 0
    1b32:	42 e0       	ldi	r20, 0x02	; 2
    1b34:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	
	/* Air condition setup */
	DIO_pinConfiguration(AIRCOND_PORT, AIRCOND_PIN, Output);
    1b38:	83 e3       	ldi	r24, 0x33	; 51
    1b3a:	90 e0       	ldi	r25, 0x00	; 0
    1b3c:	61 e0       	ldi	r22, 0x01	; 1
    1b3e:	42 e0       	ldi	r20, 0x02	; 2
    1b40:	0e 94 0d 01 	call	0x21a	; 0x21a <DIO_pinConfiguration>
	
	
	
	/* the initial state is the air condition off so we reset the global interrupt to stop the temperature check */
	GLOBAL_INT_DISABLE();
    1b44:	8f b7       	in	r24, 0x3f	; 63
    1b46:	8f 77       	andi	r24, 0x7F	; 127
    1b48:	8f bf       	out	0x3f, r24	; 63
}
    1b4a:	08 95       	ret

00001b4c <HomeSlave_OPR>:
void HomeSlave_OPR(void)
{
	SPI_DataRx = Exchange_Byte_Blocking(Dummy);
    1b4c:	80 e0       	ldi	r24, 0x00	; 0
    1b4e:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1b52:	80 93 a8 00 	sts	0x00A8, r24
	switch(SPI_DataRx)
    1b56:	90 e0       	ldi	r25, 0x00	; 0
    1b58:	01 97       	sbiw	r24, 0x01	; 1
    1b5a:	83 33       	cpi	r24, 0x33	; 51
    1b5c:	91 05       	cpc	r25, r1
    1b5e:	08 f0       	brcs	.+2      	; 0x1b62 <HomeSlave_OPR+0x16>
    1b60:	c5 c0       	rjmp	.+394    	; 0x1cec <HomeSlave_OPR+0x1a0>
    1b62:	86 5d       	subi	r24, 0xD6	; 214
    1b64:	9f 4f       	sbci	r25, 0xFF	; 255
    1b66:	fc 01       	movw	r30, r24
    1b68:	ee 0f       	add	r30, r30
    1b6a:	ff 1f       	adc	r31, r31
    1b6c:	05 90       	lpm	r0, Z+
    1b6e:	f4 91       	lpm	r31, Z
    1b70:	e0 2d       	mov	r30, r0
    1b72:	09 94       	ijmp
	{
		case ROOM1:
		if (DIO_pinRead(ROOMs_PORT,ROOM1_PIN) == HIGH)
    1b74:	80 e3       	ldi	r24, 0x30	; 48
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	64 e0       	ldi	r22, 0x04	; 4
    1b7a:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    1b7e:	81 30       	cpi	r24, 0x01	; 1
    1b80:	21 f4       	brne	.+8      	; 0x1b8a <HomeSlave_OPR+0x3e>
		{
			Exchange_Byte_Blocking(ON);
    1b82:	85 e0       	ldi	r24, 0x05	; 5
    1b84:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1b88:	08 95       	ret
		}
		else
		{
			Exchange_Byte_Blocking(OFF);
    1b8a:	86 e0       	ldi	r24, 0x06	; 6
    1b8c:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1b90:	08 95       	ret
		}
		break;
		case ROOM2:
		if (DIO_pinRead(ROOMs_PORT,ROOM2_PIN) == HIGH)
    1b92:	80 e3       	ldi	r24, 0x30	; 48
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	65 e0       	ldi	r22, 0x05	; 5
    1b98:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    1b9c:	81 30       	cpi	r24, 0x01	; 1
    1b9e:	21 f4       	brne	.+8      	; 0x1ba8 <HomeSlave_OPR+0x5c>
		{
			Exchange_Byte_Blocking(ON);
    1ba0:	85 e0       	ldi	r24, 0x05	; 5
    1ba2:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1ba6:	08 95       	ret
		}
		else
		{
			Exchange_Byte_Blocking(OFF);
    1ba8:	86 e0       	ldi	r24, 0x06	; 6
    1baa:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1bae:	08 95       	ret
		}
		break;
		case ROOM3:
		if (DIO_pinRead(ROOMs_PORT,ROOM3_PIN) == HIGH)
    1bb0:	80 e3       	ldi	r24, 0x30	; 48
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	66 e0       	ldi	r22, 0x06	; 6
    1bb6:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    1bba:	81 30       	cpi	r24, 0x01	; 1
    1bbc:	21 f4       	brne	.+8      	; 0x1bc6 <HomeSlave_OPR+0x7a>
		{
			Exchange_Byte_Blocking(ON);
    1bbe:	85 e0       	ldi	r24, 0x05	; 5
    1bc0:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1bc4:	08 95       	ret
		}
		else
		{
			Exchange_Byte_Blocking(OFF);
    1bc6:	86 e0       	ldi	r24, 0x06	; 6
    1bc8:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1bcc:	08 95       	ret
		}
		break;
		case ROOM4:
		if (DIO_pinRead(ROOMs_PORT,ROOM4_PIN) == HIGH)
    1bce:	80 e3       	ldi	r24, 0x30	; 48
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	67 e0       	ldi	r22, 0x07	; 7
    1bd4:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    1bd8:	81 30       	cpi	r24, 0x01	; 1
    1bda:	21 f4       	brne	.+8      	; 0x1be4 <HomeSlave_OPR+0x98>
		{
			Exchange_Byte_Blocking(ON);
    1bdc:	85 e0       	ldi	r24, 0x05	; 5
    1bde:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1be2:	08 95       	ret
		}
		else
		{
			Exchange_Byte_Blocking(OFF);
    1be4:	86 e0       	ldi	r24, 0x06	; 6
    1be6:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1bea:	08 95       	ret
		}
		break;
		case TV:
		if (DIO_pinRead(TV_PORT,TV_PIN) == HIGH)
    1bec:	83 e3       	ldi	r24, 0x33	; 51
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	60 e0       	ldi	r22, 0x00	; 0
    1bf2:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    1bf6:	81 30       	cpi	r24, 0x01	; 1
    1bf8:	21 f4       	brne	.+8      	; 0x1c02 <HomeSlave_OPR+0xb6>
		{
			Exchange_Byte_Blocking(ON);
    1bfa:	85 e0       	ldi	r24, 0x05	; 5
    1bfc:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1c00:	08 95       	ret
		}
		else
		{
			Exchange_Byte_Blocking(OFF);
    1c02:	86 e0       	ldi	r24, 0x06	; 6
    1c04:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1c08:	08 95       	ret
		}
		break;
		case AirCondition:
		if (DIO_pinRead(AIRCOND_PORT,AIRCOND_PIN) == HIGH)
    1c0a:	83 e3       	ldi	r24, 0x33	; 51
    1c0c:	90 e0       	ldi	r25, 0x00	; 0
    1c0e:	61 e0       	ldi	r22, 0x01	; 1
    1c10:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <DIO_pinRead>
    1c14:	81 30       	cpi	r24, 0x01	; 1
    1c16:	21 f4       	brne	.+8      	; 0x1c20 <HomeSlave_OPR+0xd4>
		{
			Exchange_Byte_Blocking(ON);
    1c18:	85 e0       	ldi	r24, 0x05	; 5
    1c1a:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1c1e:	08 95       	ret
		}
		else
		{
			Exchange_Byte_Blocking(OFF);
    1c20:	86 e0       	ldi	r24, 0x06	; 6
    1c22:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1c26:	08 95       	ret
		}
		break;
		case Temp_Mode:
		TEMP_LEVEL = Exchange_Byte_Blocking(Dummy);
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
    1c2e:	80 93 a7 00 	sts	0x00A7, r24
		Exchange_Byte_Blocking(Temp_Mode);
    1c32:	83 e3       	ldi	r24, 0x33	; 51
    1c34:	0e 94 04 03 	call	0x608	; 0x608 <Exchange_Byte_Blocking>
		break;
    1c38:	08 95       	ret
		/*********************************** Turn ON & OFF Command ********************************************/
		case ROOM1_ON:
		     DIO_pinWrite(ROOMs_PORT, ROOM1_PIN, HIGH);
    1c3a:	80 e3       	ldi	r24, 0x30	; 48
    1c3c:	90 e0       	ldi	r25, 0x00	; 0
    1c3e:	64 e0       	ldi	r22, 0x04	; 4
    1c40:	41 e0       	ldi	r20, 0x01	; 1
    1c42:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
			 break;
    1c46:	08 95       	ret
		case ROOM1_OFF:
		DIO_pinWrite(ROOMs_PORT, ROOM1_PIN, LOW);
    1c48:	80 e3       	ldi	r24, 0x30	; 48
    1c4a:	90 e0       	ldi	r25, 0x00	; 0
    1c4c:	64 e0       	ldi	r22, 0x04	; 4
    1c4e:	40 e0       	ldi	r20, 0x00	; 0
    1c50:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1c54:	08 95       	ret
		case ROOM2_ON:
		DIO_pinWrite(ROOMs_PORT, ROOM2_PIN, HIGH);
    1c56:	80 e3       	ldi	r24, 0x30	; 48
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	65 e0       	ldi	r22, 0x05	; 5
    1c5c:	41 e0       	ldi	r20, 0x01	; 1
    1c5e:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1c62:	08 95       	ret
		case ROOM2_OFF:
		DIO_pinWrite(ROOMs_PORT, ROOM2_PIN, LOW);
    1c64:	80 e3       	ldi	r24, 0x30	; 48
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	65 e0       	ldi	r22, 0x05	; 5
    1c6a:	40 e0       	ldi	r20, 0x00	; 0
    1c6c:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1c70:	08 95       	ret
		case ROOM3_ON:
		DIO_pinWrite(ROOMs_PORT, ROOM3_PIN, HIGH);
    1c72:	80 e3       	ldi	r24, 0x30	; 48
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	66 e0       	ldi	r22, 0x06	; 6
    1c78:	41 e0       	ldi	r20, 0x01	; 1
    1c7a:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1c7e:	08 95       	ret
		case ROOM3_OFF:
		DIO_pinWrite(ROOMs_PORT, ROOM3_PIN, LOW);
    1c80:	80 e3       	ldi	r24, 0x30	; 48
    1c82:	90 e0       	ldi	r25, 0x00	; 0
    1c84:	66 e0       	ldi	r22, 0x06	; 6
    1c86:	40 e0       	ldi	r20, 0x00	; 0
    1c88:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1c8c:	08 95       	ret
		case ROOM4_ON:
		DIO_pinWrite(ROOMs_PORT, ROOM4_PIN, HIGH);
    1c8e:	80 e3       	ldi	r24, 0x30	; 48
    1c90:	90 e0       	ldi	r25, 0x00	; 0
    1c92:	67 e0       	ldi	r22, 0x07	; 7
    1c94:	41 e0       	ldi	r20, 0x01	; 1
    1c96:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1c9a:	08 95       	ret
		case ROOM4_OFF:
		DIO_pinWrite(ROOMs_PORT, ROOM4_PIN, LOW);
    1c9c:	80 e3       	ldi	r24, 0x30	; 48
    1c9e:	90 e0       	ldi	r25, 0x00	; 0
    1ca0:	67 e0       	ldi	r22, 0x07	; 7
    1ca2:	40 e0       	ldi	r20, 0x00	; 0
    1ca4:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1ca8:	08 95       	ret
		case TV_ON:
		DIO_pinWrite(TV_PORT, TV_PIN, HIGH);
    1caa:	83 e3       	ldi	r24, 0x33	; 51
    1cac:	90 e0       	ldi	r25, 0x00	; 0
    1cae:	60 e0       	ldi	r22, 0x00	; 0
    1cb0:	41 e0       	ldi	r20, 0x01	; 1
    1cb2:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1cb6:	08 95       	ret
		case TV_OFF:
		DIO_pinWrite(TV_PORT, TV_PIN, LOW);
    1cb8:	83 e3       	ldi	r24, 0x33	; 51
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	60 e0       	ldi	r22, 0x00	; 0
    1cbe:	40 e0       	ldi	r20, 0x00	; 0
    1cc0:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1cc4:	08 95       	ret
		case AirCond_ON:
		/* enable the temperature check value */
		GLOBAL_INT_ENABLE();
    1cc6:	8f b7       	in	r24, 0x3f	; 63
    1cc8:	80 68       	ori	r24, 0x80	; 128
    1cca:	8f bf       	out	0x3f, r24	; 63
		DIO_pinWrite(AIRCOND_PORT, AIRCOND_PIN, HIGH);
    1ccc:	83 e3       	ldi	r24, 0x33	; 51
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	61 e0       	ldi	r22, 0x01	; 1
    1cd2:	41 e0       	ldi	r20, 0x01	; 1
    1cd4:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		break;
    1cd8:	08 95       	ret
		case AirCond_OFF:
		GLOBAL_INT_DISABLE();
    1cda:	8f b7       	in	r24, 0x3f	; 63
    1cdc:	8f 77       	andi	r24, 0x7F	; 127
    1cde:	8f bf       	out	0x3f, r24	; 63
		DIO_pinWrite(AIRCOND_PORT, AIRCOND_PIN, LOW);
    1ce0:	83 e3       	ldi	r24, 0x33	; 51
    1ce2:	90 e0       	ldi	r25, 0x00	; 0
    1ce4:	61 e0       	ldi	r22, 0x01	; 1
    1ce6:	40 e0       	ldi	r20, 0x00	; 0
    1ce8:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
    1cec:	08 95       	ret

00001cee <TIMER0_COMP_vect>:
}


/* this definition we get from the ATmega32A_intrrupt Library we implement */
ISR (TIMER0_COMP_vect)
{
    1cee:	1f 92       	push	r1
    1cf0:	0f 92       	push	r0
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	0f 92       	push	r0
    1cf6:	11 24       	eor	r1, r1
    1cf8:	2f 93       	push	r18
    1cfa:	3f 93       	push	r19
    1cfc:	4f 93       	push	r20
    1cfe:	5f 93       	push	r21
    1d00:	6f 93       	push	r22
    1d02:	7f 93       	push	r23
    1d04:	8f 93       	push	r24
    1d06:	9f 93       	push	r25
    1d08:	af 93       	push	r26
    1d0a:	bf 93       	push	r27
    1d0c:	ef 93       	push	r30
    1d0e:	ff 93       	push	r31
	count++;
    1d10:	80 91 a6 00 	lds	r24, 0x00A6
    1d14:	8f 5f       	subi	r24, 0xFF	; 255
    1d16:	80 93 a6 00 	sts	0x00A6, r24
	if (count >= 10)
    1d1a:	80 91 a6 00 	lds	r24, 0x00A6
    1d1e:	8a 30       	cpi	r24, 0x0A	; 10
    1d20:	e8 f1       	brcs	.+122    	; 0x1d9c <TIMER0_COMP_vect+0xae>
	{
		/* Reset the count value */
		count = 0;
    1d22:	10 92 a6 00 	sts	0x00A6, r1
	 * So Equ Volt = Step * READ_VALUE
	 * In This Case 
	 *  value 1C for 10mV
	 * 2.56 /1024 * 1000 (convert to mV) /10(because 1C for 10mV) = 0.25
	 */
	temperture = analogRead(analog_signal) * 0.25 ; 
    1d26:	40 91 6c 00 	lds	r20, 0x006C
    1d2a:	50 91 6d 00 	lds	r21, 0x006D
    1d2e:	60 91 6e 00 	lds	r22, 0x006E
    1d32:	70 91 6f 00 	lds	r23, 0x006F
    1d36:	80 91 70 00 	lds	r24, 0x0070
    1d3a:	90 91 71 00 	lds	r25, 0x0071
    1d3e:	0e 94 ed 00 	call	0x1da	; 0x1da <analogRead>
    1d42:	9c 01       	movw	r18, r24
    1d44:	b9 01       	movw	r22, r18
    1d46:	88 27       	eor	r24, r24
    1d48:	77 fd       	sbrc	r23, 7
    1d4a:	80 95       	com	r24
    1d4c:	98 2f       	mov	r25, r24
    1d4e:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <__floatsisf>
    1d52:	20 e0       	ldi	r18, 0x00	; 0
    1d54:	30 e0       	ldi	r19, 0x00	; 0
    1d56:	40 e8       	ldi	r20, 0x80	; 128
    1d58:	5e e3       	ldi	r21, 0x3E	; 62
    1d5a:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__mulsf3>
    1d5e:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <__fixunssfsi>
    1d62:	dc 01       	movw	r26, r24
    1d64:	cb 01       	movw	r24, r22
    1d66:	90 93 aa 00 	sts	0x00AA, r25
    1d6a:	80 93 a9 00 	sts	0x00A9, r24
		if (temperture > TEMP_LEVEL)
    1d6e:	20 91 a7 00 	lds	r18, 0x00A7
    1d72:	80 91 a9 00 	lds	r24, 0x00A9
    1d76:	90 91 aa 00 	lds	r25, 0x00AA
    1d7a:	30 e0       	ldi	r19, 0x00	; 0
    1d7c:	28 17       	cp	r18, r24
    1d7e:	39 07       	cpc	r19, r25
    1d80:	38 f4       	brcc	.+14     	; 0x1d90 <TIMER0_COMP_vect+0xa2>
		{
			DIO_pinWrite(AIRCOND_PORT,AIRCOND_PIN,HIGH);
    1d82:	83 e3       	ldi	r24, 0x33	; 51
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	61 e0       	ldi	r22, 0x01	; 1
    1d88:	41 e0       	ldi	r20, 0x01	; 1
    1d8a:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
    1d8e:	06 c0       	rjmp	.+12     	; 0x1d9c <TIMER0_COMP_vect+0xae>
		}
		else
		{
			DIO_pinWrite(AIRCOND_PORT,AIRCOND_PIN,HIGH);
    1d90:	83 e3       	ldi	r24, 0x33	; 51
    1d92:	90 e0       	ldi	r25, 0x00	; 0
    1d94:	61 e0       	ldi	r22, 0x01	; 1
    1d96:	41 e0       	ldi	r20, 0x01	; 1
    1d98:	0e 94 4b 01 	call	0x296	; 0x296 <DIO_pinWrite>
		}
	}
}
    1d9c:	ff 91       	pop	r31
    1d9e:	ef 91       	pop	r30
    1da0:	bf 91       	pop	r27
    1da2:	af 91       	pop	r26
    1da4:	9f 91       	pop	r25
    1da6:	8f 91       	pop	r24
    1da8:	7f 91       	pop	r23
    1daa:	6f 91       	pop	r22
    1dac:	5f 91       	pop	r21
    1dae:	4f 91       	pop	r20
    1db0:	3f 91       	pop	r19
    1db2:	2f 91       	pop	r18
    1db4:	0f 90       	pop	r0
    1db6:	0f be       	out	0x3f, r0	; 63
    1db8:	0f 90       	pop	r0
    1dba:	1f 90       	pop	r1
    1dbc:	18 95       	reti

00001dbe <main>:

#include "SmartHome_Slave.h"

int main(void)
{
	HomeSlave_INT();
    1dbe:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <HomeSlave_INT>
    while(1)
    {
        HomeSlave_OPR();
    1dc2:	0e 94 a6 0d 	call	0x1b4c	; 0x1b4c <HomeSlave_OPR>
    1dc6:	fd cf       	rjmp	.-6      	; 0x1dc2 <main+0x4>

00001dc8 <__subsf3>:
    1dc8:	50 58       	subi	r21, 0x80	; 128

00001dca <__addsf3>:
    1dca:	bb 27       	eor	r27, r27
    1dcc:	aa 27       	eor	r26, r26
    1dce:	0e d0       	rcall	.+28     	; 0x1dec <__addsf3x>
    1dd0:	4d c1       	rjmp	.+666    	; 0x206c <__fp_round>
    1dd2:	3e d1       	rcall	.+636    	; 0x2050 <__fp_pscA>
    1dd4:	30 f0       	brcs	.+12     	; 0x1de2 <__addsf3+0x18>
    1dd6:	43 d1       	rcall	.+646    	; 0x205e <__fp_pscB>
    1dd8:	20 f0       	brcs	.+8      	; 0x1de2 <__addsf3+0x18>
    1dda:	31 f4       	brne	.+12     	; 0x1de8 <__addsf3+0x1e>
    1ddc:	9f 3f       	cpi	r25, 0xFF	; 255
    1dde:	11 f4       	brne	.+4      	; 0x1de4 <__addsf3+0x1a>
    1de0:	1e f4       	brtc	.+6      	; 0x1de8 <__addsf3+0x1e>
    1de2:	33 c1       	rjmp	.+614    	; 0x204a <__fp_nan>
    1de4:	0e f4       	brtc	.+2      	; 0x1de8 <__addsf3+0x1e>
    1de6:	e0 95       	com	r30
    1de8:	e7 fb       	bst	r30, 7
    1dea:	29 c1       	rjmp	.+594    	; 0x203e <__fp_inf>

00001dec <__addsf3x>:
    1dec:	e9 2f       	mov	r30, r25
    1dee:	4f d1       	rcall	.+670    	; 0x208e <__fp_split3>
    1df0:	80 f3       	brcs	.-32     	; 0x1dd2 <__addsf3+0x8>
    1df2:	ba 17       	cp	r27, r26
    1df4:	62 07       	cpc	r22, r18
    1df6:	73 07       	cpc	r23, r19
    1df8:	84 07       	cpc	r24, r20
    1dfa:	95 07       	cpc	r25, r21
    1dfc:	18 f0       	brcs	.+6      	; 0x1e04 <__addsf3x+0x18>
    1dfe:	71 f4       	brne	.+28     	; 0x1e1c <__addsf3x+0x30>
    1e00:	9e f5       	brtc	.+102    	; 0x1e68 <__addsf3x+0x7c>
    1e02:	67 c1       	rjmp	.+718    	; 0x20d2 <__fp_zero>
    1e04:	0e f4       	brtc	.+2      	; 0x1e08 <__addsf3x+0x1c>
    1e06:	e0 95       	com	r30
    1e08:	0b 2e       	mov	r0, r27
    1e0a:	ba 2f       	mov	r27, r26
    1e0c:	a0 2d       	mov	r26, r0
    1e0e:	0b 01       	movw	r0, r22
    1e10:	b9 01       	movw	r22, r18
    1e12:	90 01       	movw	r18, r0
    1e14:	0c 01       	movw	r0, r24
    1e16:	ca 01       	movw	r24, r20
    1e18:	a0 01       	movw	r20, r0
    1e1a:	11 24       	eor	r1, r1
    1e1c:	ff 27       	eor	r31, r31
    1e1e:	59 1b       	sub	r21, r25
    1e20:	99 f0       	breq	.+38     	; 0x1e48 <__addsf3x+0x5c>
    1e22:	59 3f       	cpi	r21, 0xF9	; 249
    1e24:	50 f4       	brcc	.+20     	; 0x1e3a <__addsf3x+0x4e>
    1e26:	50 3e       	cpi	r21, 0xE0	; 224
    1e28:	68 f1       	brcs	.+90     	; 0x1e84 <__addsf3x+0x98>
    1e2a:	1a 16       	cp	r1, r26
    1e2c:	f0 40       	sbci	r31, 0x00	; 0
    1e2e:	a2 2f       	mov	r26, r18
    1e30:	23 2f       	mov	r18, r19
    1e32:	34 2f       	mov	r19, r20
    1e34:	44 27       	eor	r20, r20
    1e36:	58 5f       	subi	r21, 0xF8	; 248
    1e38:	f3 cf       	rjmp	.-26     	; 0x1e20 <__addsf3x+0x34>
    1e3a:	46 95       	lsr	r20
    1e3c:	37 95       	ror	r19
    1e3e:	27 95       	ror	r18
    1e40:	a7 95       	ror	r26
    1e42:	f0 40       	sbci	r31, 0x00	; 0
    1e44:	53 95       	inc	r21
    1e46:	c9 f7       	brne	.-14     	; 0x1e3a <__addsf3x+0x4e>
    1e48:	7e f4       	brtc	.+30     	; 0x1e68 <__addsf3x+0x7c>
    1e4a:	1f 16       	cp	r1, r31
    1e4c:	ba 0b       	sbc	r27, r26
    1e4e:	62 0b       	sbc	r22, r18
    1e50:	73 0b       	sbc	r23, r19
    1e52:	84 0b       	sbc	r24, r20
    1e54:	ba f0       	brmi	.+46     	; 0x1e84 <__addsf3x+0x98>
    1e56:	91 50       	subi	r25, 0x01	; 1
    1e58:	a1 f0       	breq	.+40     	; 0x1e82 <__addsf3x+0x96>
    1e5a:	ff 0f       	add	r31, r31
    1e5c:	bb 1f       	adc	r27, r27
    1e5e:	66 1f       	adc	r22, r22
    1e60:	77 1f       	adc	r23, r23
    1e62:	88 1f       	adc	r24, r24
    1e64:	c2 f7       	brpl	.-16     	; 0x1e56 <__addsf3x+0x6a>
    1e66:	0e c0       	rjmp	.+28     	; 0x1e84 <__addsf3x+0x98>
    1e68:	ba 0f       	add	r27, r26
    1e6a:	62 1f       	adc	r22, r18
    1e6c:	73 1f       	adc	r23, r19
    1e6e:	84 1f       	adc	r24, r20
    1e70:	48 f4       	brcc	.+18     	; 0x1e84 <__addsf3x+0x98>
    1e72:	87 95       	ror	r24
    1e74:	77 95       	ror	r23
    1e76:	67 95       	ror	r22
    1e78:	b7 95       	ror	r27
    1e7a:	f7 95       	ror	r31
    1e7c:	9e 3f       	cpi	r25, 0xFE	; 254
    1e7e:	08 f0       	brcs	.+2      	; 0x1e82 <__addsf3x+0x96>
    1e80:	b3 cf       	rjmp	.-154    	; 0x1de8 <__addsf3+0x1e>
    1e82:	93 95       	inc	r25
    1e84:	88 0f       	add	r24, r24
    1e86:	08 f0       	brcs	.+2      	; 0x1e8a <__addsf3x+0x9e>
    1e88:	99 27       	eor	r25, r25
    1e8a:	ee 0f       	add	r30, r30
    1e8c:	97 95       	ror	r25
    1e8e:	87 95       	ror	r24
    1e90:	08 95       	ret

00001e92 <__divsf3>:
    1e92:	0c d0       	rcall	.+24     	; 0x1eac <__divsf3x>
    1e94:	eb c0       	rjmp	.+470    	; 0x206c <__fp_round>
    1e96:	e3 d0       	rcall	.+454    	; 0x205e <__fp_pscB>
    1e98:	40 f0       	brcs	.+16     	; 0x1eaa <__divsf3+0x18>
    1e9a:	da d0       	rcall	.+436    	; 0x2050 <__fp_pscA>
    1e9c:	30 f0       	brcs	.+12     	; 0x1eaa <__divsf3+0x18>
    1e9e:	21 f4       	brne	.+8      	; 0x1ea8 <__divsf3+0x16>
    1ea0:	5f 3f       	cpi	r21, 0xFF	; 255
    1ea2:	19 f0       	breq	.+6      	; 0x1eaa <__divsf3+0x18>
    1ea4:	cc c0       	rjmp	.+408    	; 0x203e <__fp_inf>
    1ea6:	51 11       	cpse	r21, r1
    1ea8:	15 c1       	rjmp	.+554    	; 0x20d4 <__fp_szero>
    1eaa:	cf c0       	rjmp	.+414    	; 0x204a <__fp_nan>

00001eac <__divsf3x>:
    1eac:	f0 d0       	rcall	.+480    	; 0x208e <__fp_split3>
    1eae:	98 f3       	brcs	.-26     	; 0x1e96 <__divsf3+0x4>

00001eb0 <__divsf3_pse>:
    1eb0:	99 23       	and	r25, r25
    1eb2:	c9 f3       	breq	.-14     	; 0x1ea6 <__divsf3+0x14>
    1eb4:	55 23       	and	r21, r21
    1eb6:	b1 f3       	breq	.-20     	; 0x1ea4 <__divsf3+0x12>
    1eb8:	95 1b       	sub	r25, r21
    1eba:	55 0b       	sbc	r21, r21
    1ebc:	bb 27       	eor	r27, r27
    1ebe:	aa 27       	eor	r26, r26
    1ec0:	62 17       	cp	r22, r18
    1ec2:	73 07       	cpc	r23, r19
    1ec4:	84 07       	cpc	r24, r20
    1ec6:	38 f0       	brcs	.+14     	; 0x1ed6 <__divsf3_pse+0x26>
    1ec8:	9f 5f       	subi	r25, 0xFF	; 255
    1eca:	5f 4f       	sbci	r21, 0xFF	; 255
    1ecc:	22 0f       	add	r18, r18
    1ece:	33 1f       	adc	r19, r19
    1ed0:	44 1f       	adc	r20, r20
    1ed2:	aa 1f       	adc	r26, r26
    1ed4:	a9 f3       	breq	.-22     	; 0x1ec0 <__divsf3_pse+0x10>
    1ed6:	33 d0       	rcall	.+102    	; 0x1f3e <__divsf3_pse+0x8e>
    1ed8:	0e 2e       	mov	r0, r30
    1eda:	3a f0       	brmi	.+14     	; 0x1eea <__divsf3_pse+0x3a>
    1edc:	e0 e8       	ldi	r30, 0x80	; 128
    1ede:	30 d0       	rcall	.+96     	; 0x1f40 <__divsf3_pse+0x90>
    1ee0:	91 50       	subi	r25, 0x01	; 1
    1ee2:	50 40       	sbci	r21, 0x00	; 0
    1ee4:	e6 95       	lsr	r30
    1ee6:	00 1c       	adc	r0, r0
    1ee8:	ca f7       	brpl	.-14     	; 0x1edc <__divsf3_pse+0x2c>
    1eea:	29 d0       	rcall	.+82     	; 0x1f3e <__divsf3_pse+0x8e>
    1eec:	fe 2f       	mov	r31, r30
    1eee:	27 d0       	rcall	.+78     	; 0x1f3e <__divsf3_pse+0x8e>
    1ef0:	66 0f       	add	r22, r22
    1ef2:	77 1f       	adc	r23, r23
    1ef4:	88 1f       	adc	r24, r24
    1ef6:	bb 1f       	adc	r27, r27
    1ef8:	26 17       	cp	r18, r22
    1efa:	37 07       	cpc	r19, r23
    1efc:	48 07       	cpc	r20, r24
    1efe:	ab 07       	cpc	r26, r27
    1f00:	b0 e8       	ldi	r27, 0x80	; 128
    1f02:	09 f0       	breq	.+2      	; 0x1f06 <__divsf3_pse+0x56>
    1f04:	bb 0b       	sbc	r27, r27
    1f06:	80 2d       	mov	r24, r0
    1f08:	bf 01       	movw	r22, r30
    1f0a:	ff 27       	eor	r31, r31
    1f0c:	93 58       	subi	r25, 0x83	; 131
    1f0e:	5f 4f       	sbci	r21, 0xFF	; 255
    1f10:	2a f0       	brmi	.+10     	; 0x1f1c <__divsf3_pse+0x6c>
    1f12:	9e 3f       	cpi	r25, 0xFE	; 254
    1f14:	51 05       	cpc	r21, r1
    1f16:	68 f0       	brcs	.+26     	; 0x1f32 <__divsf3_pse+0x82>
    1f18:	92 c0       	rjmp	.+292    	; 0x203e <__fp_inf>
    1f1a:	dc c0       	rjmp	.+440    	; 0x20d4 <__fp_szero>
    1f1c:	5f 3f       	cpi	r21, 0xFF	; 255
    1f1e:	ec f3       	brlt	.-6      	; 0x1f1a <__divsf3_pse+0x6a>
    1f20:	98 3e       	cpi	r25, 0xE8	; 232
    1f22:	dc f3       	brlt	.-10     	; 0x1f1a <__divsf3_pse+0x6a>
    1f24:	86 95       	lsr	r24
    1f26:	77 95       	ror	r23
    1f28:	67 95       	ror	r22
    1f2a:	b7 95       	ror	r27
    1f2c:	f7 95       	ror	r31
    1f2e:	9f 5f       	subi	r25, 0xFF	; 255
    1f30:	c9 f7       	brne	.-14     	; 0x1f24 <__divsf3_pse+0x74>
    1f32:	88 0f       	add	r24, r24
    1f34:	91 1d       	adc	r25, r1
    1f36:	96 95       	lsr	r25
    1f38:	87 95       	ror	r24
    1f3a:	97 f9       	bld	r25, 7
    1f3c:	08 95       	ret
    1f3e:	e1 e0       	ldi	r30, 0x01	; 1
    1f40:	66 0f       	add	r22, r22
    1f42:	77 1f       	adc	r23, r23
    1f44:	88 1f       	adc	r24, r24
    1f46:	bb 1f       	adc	r27, r27
    1f48:	62 17       	cp	r22, r18
    1f4a:	73 07       	cpc	r23, r19
    1f4c:	84 07       	cpc	r24, r20
    1f4e:	ba 07       	cpc	r27, r26
    1f50:	20 f0       	brcs	.+8      	; 0x1f5a <__divsf3_pse+0xaa>
    1f52:	62 1b       	sub	r22, r18
    1f54:	73 0b       	sbc	r23, r19
    1f56:	84 0b       	sbc	r24, r20
    1f58:	ba 0b       	sbc	r27, r26
    1f5a:	ee 1f       	adc	r30, r30
    1f5c:	88 f7       	brcc	.-30     	; 0x1f40 <__divsf3_pse+0x90>
    1f5e:	e0 95       	com	r30
    1f60:	08 95       	ret

00001f62 <__fixsfsi>:
    1f62:	04 d0       	rcall	.+8      	; 0x1f6c <__fixunssfsi>
    1f64:	68 94       	set
    1f66:	b1 11       	cpse	r27, r1
    1f68:	b5 c0       	rjmp	.+362    	; 0x20d4 <__fp_szero>
    1f6a:	08 95       	ret

00001f6c <__fixunssfsi>:
    1f6c:	98 d0       	rcall	.+304    	; 0x209e <__fp_splitA>
    1f6e:	88 f0       	brcs	.+34     	; 0x1f92 <__fixunssfsi+0x26>
    1f70:	9f 57       	subi	r25, 0x7F	; 127
    1f72:	90 f0       	brcs	.+36     	; 0x1f98 <__fixunssfsi+0x2c>
    1f74:	b9 2f       	mov	r27, r25
    1f76:	99 27       	eor	r25, r25
    1f78:	b7 51       	subi	r27, 0x17	; 23
    1f7a:	a0 f0       	brcs	.+40     	; 0x1fa4 <__fixunssfsi+0x38>
    1f7c:	d1 f0       	breq	.+52     	; 0x1fb2 <__fixunssfsi+0x46>
    1f7e:	66 0f       	add	r22, r22
    1f80:	77 1f       	adc	r23, r23
    1f82:	88 1f       	adc	r24, r24
    1f84:	99 1f       	adc	r25, r25
    1f86:	1a f0       	brmi	.+6      	; 0x1f8e <__fixunssfsi+0x22>
    1f88:	ba 95       	dec	r27
    1f8a:	c9 f7       	brne	.-14     	; 0x1f7e <__fixunssfsi+0x12>
    1f8c:	12 c0       	rjmp	.+36     	; 0x1fb2 <__fixunssfsi+0x46>
    1f8e:	b1 30       	cpi	r27, 0x01	; 1
    1f90:	81 f0       	breq	.+32     	; 0x1fb2 <__fixunssfsi+0x46>
    1f92:	9f d0       	rcall	.+318    	; 0x20d2 <__fp_zero>
    1f94:	b1 e0       	ldi	r27, 0x01	; 1
    1f96:	08 95       	ret
    1f98:	9c c0       	rjmp	.+312    	; 0x20d2 <__fp_zero>
    1f9a:	67 2f       	mov	r22, r23
    1f9c:	78 2f       	mov	r23, r24
    1f9e:	88 27       	eor	r24, r24
    1fa0:	b8 5f       	subi	r27, 0xF8	; 248
    1fa2:	39 f0       	breq	.+14     	; 0x1fb2 <__fixunssfsi+0x46>
    1fa4:	b9 3f       	cpi	r27, 0xF9	; 249
    1fa6:	cc f3       	brlt	.-14     	; 0x1f9a <__fixunssfsi+0x2e>
    1fa8:	86 95       	lsr	r24
    1faa:	77 95       	ror	r23
    1fac:	67 95       	ror	r22
    1fae:	b3 95       	inc	r27
    1fb0:	d9 f7       	brne	.-10     	; 0x1fa8 <__fixunssfsi+0x3c>
    1fb2:	3e f4       	brtc	.+14     	; 0x1fc2 <__fixunssfsi+0x56>
    1fb4:	90 95       	com	r25
    1fb6:	80 95       	com	r24
    1fb8:	70 95       	com	r23
    1fba:	61 95       	neg	r22
    1fbc:	7f 4f       	sbci	r23, 0xFF	; 255
    1fbe:	8f 4f       	sbci	r24, 0xFF	; 255
    1fc0:	9f 4f       	sbci	r25, 0xFF	; 255
    1fc2:	08 95       	ret

00001fc4 <__floatunsisf>:
    1fc4:	e8 94       	clt
    1fc6:	09 c0       	rjmp	.+18     	; 0x1fda <__floatsisf+0x12>

00001fc8 <__floatsisf>:
    1fc8:	97 fb       	bst	r25, 7
    1fca:	3e f4       	brtc	.+14     	; 0x1fda <__floatsisf+0x12>
    1fcc:	90 95       	com	r25
    1fce:	80 95       	com	r24
    1fd0:	70 95       	com	r23
    1fd2:	61 95       	neg	r22
    1fd4:	7f 4f       	sbci	r23, 0xFF	; 255
    1fd6:	8f 4f       	sbci	r24, 0xFF	; 255
    1fd8:	9f 4f       	sbci	r25, 0xFF	; 255
    1fda:	99 23       	and	r25, r25
    1fdc:	a9 f0       	breq	.+42     	; 0x2008 <__floatsisf+0x40>
    1fde:	f9 2f       	mov	r31, r25
    1fe0:	96 e9       	ldi	r25, 0x96	; 150
    1fe2:	bb 27       	eor	r27, r27
    1fe4:	93 95       	inc	r25
    1fe6:	f6 95       	lsr	r31
    1fe8:	87 95       	ror	r24
    1fea:	77 95       	ror	r23
    1fec:	67 95       	ror	r22
    1fee:	b7 95       	ror	r27
    1ff0:	f1 11       	cpse	r31, r1
    1ff2:	f8 cf       	rjmp	.-16     	; 0x1fe4 <__floatsisf+0x1c>
    1ff4:	fa f4       	brpl	.+62     	; 0x2034 <__floatsisf+0x6c>
    1ff6:	bb 0f       	add	r27, r27
    1ff8:	11 f4       	brne	.+4      	; 0x1ffe <__floatsisf+0x36>
    1ffa:	60 ff       	sbrs	r22, 0
    1ffc:	1b c0       	rjmp	.+54     	; 0x2034 <__floatsisf+0x6c>
    1ffe:	6f 5f       	subi	r22, 0xFF	; 255
    2000:	7f 4f       	sbci	r23, 0xFF	; 255
    2002:	8f 4f       	sbci	r24, 0xFF	; 255
    2004:	9f 4f       	sbci	r25, 0xFF	; 255
    2006:	16 c0       	rjmp	.+44     	; 0x2034 <__floatsisf+0x6c>
    2008:	88 23       	and	r24, r24
    200a:	11 f0       	breq	.+4      	; 0x2010 <__floatsisf+0x48>
    200c:	96 e9       	ldi	r25, 0x96	; 150
    200e:	11 c0       	rjmp	.+34     	; 0x2032 <__floatsisf+0x6a>
    2010:	77 23       	and	r23, r23
    2012:	21 f0       	breq	.+8      	; 0x201c <__floatsisf+0x54>
    2014:	9e e8       	ldi	r25, 0x8E	; 142
    2016:	87 2f       	mov	r24, r23
    2018:	76 2f       	mov	r23, r22
    201a:	05 c0       	rjmp	.+10     	; 0x2026 <__floatsisf+0x5e>
    201c:	66 23       	and	r22, r22
    201e:	71 f0       	breq	.+28     	; 0x203c <__floatsisf+0x74>
    2020:	96 e8       	ldi	r25, 0x86	; 134
    2022:	86 2f       	mov	r24, r22
    2024:	70 e0       	ldi	r23, 0x00	; 0
    2026:	60 e0       	ldi	r22, 0x00	; 0
    2028:	2a f0       	brmi	.+10     	; 0x2034 <__floatsisf+0x6c>
    202a:	9a 95       	dec	r25
    202c:	66 0f       	add	r22, r22
    202e:	77 1f       	adc	r23, r23
    2030:	88 1f       	adc	r24, r24
    2032:	da f7       	brpl	.-10     	; 0x202a <__floatsisf+0x62>
    2034:	88 0f       	add	r24, r24
    2036:	96 95       	lsr	r25
    2038:	87 95       	ror	r24
    203a:	97 f9       	bld	r25, 7
    203c:	08 95       	ret

0000203e <__fp_inf>:
    203e:	97 f9       	bld	r25, 7
    2040:	9f 67       	ori	r25, 0x7F	; 127
    2042:	80 e8       	ldi	r24, 0x80	; 128
    2044:	70 e0       	ldi	r23, 0x00	; 0
    2046:	60 e0       	ldi	r22, 0x00	; 0
    2048:	08 95       	ret

0000204a <__fp_nan>:
    204a:	9f ef       	ldi	r25, 0xFF	; 255
    204c:	80 ec       	ldi	r24, 0xC0	; 192
    204e:	08 95       	ret

00002050 <__fp_pscA>:
    2050:	00 24       	eor	r0, r0
    2052:	0a 94       	dec	r0
    2054:	16 16       	cp	r1, r22
    2056:	17 06       	cpc	r1, r23
    2058:	18 06       	cpc	r1, r24
    205a:	09 06       	cpc	r0, r25
    205c:	08 95       	ret

0000205e <__fp_pscB>:
    205e:	00 24       	eor	r0, r0
    2060:	0a 94       	dec	r0
    2062:	12 16       	cp	r1, r18
    2064:	13 06       	cpc	r1, r19
    2066:	14 06       	cpc	r1, r20
    2068:	05 06       	cpc	r0, r21
    206a:	08 95       	ret

0000206c <__fp_round>:
    206c:	09 2e       	mov	r0, r25
    206e:	03 94       	inc	r0
    2070:	00 0c       	add	r0, r0
    2072:	11 f4       	brne	.+4      	; 0x2078 <__fp_round+0xc>
    2074:	88 23       	and	r24, r24
    2076:	52 f0       	brmi	.+20     	; 0x208c <__fp_round+0x20>
    2078:	bb 0f       	add	r27, r27
    207a:	40 f4       	brcc	.+16     	; 0x208c <__fp_round+0x20>
    207c:	bf 2b       	or	r27, r31
    207e:	11 f4       	brne	.+4      	; 0x2084 <__fp_round+0x18>
    2080:	60 ff       	sbrs	r22, 0
    2082:	04 c0       	rjmp	.+8      	; 0x208c <__fp_round+0x20>
    2084:	6f 5f       	subi	r22, 0xFF	; 255
    2086:	7f 4f       	sbci	r23, 0xFF	; 255
    2088:	8f 4f       	sbci	r24, 0xFF	; 255
    208a:	9f 4f       	sbci	r25, 0xFF	; 255
    208c:	08 95       	ret

0000208e <__fp_split3>:
    208e:	57 fd       	sbrc	r21, 7
    2090:	90 58       	subi	r25, 0x80	; 128
    2092:	44 0f       	add	r20, r20
    2094:	55 1f       	adc	r21, r21
    2096:	59 f0       	breq	.+22     	; 0x20ae <__fp_splitA+0x10>
    2098:	5f 3f       	cpi	r21, 0xFF	; 255
    209a:	71 f0       	breq	.+28     	; 0x20b8 <__fp_splitA+0x1a>
    209c:	47 95       	ror	r20

0000209e <__fp_splitA>:
    209e:	88 0f       	add	r24, r24
    20a0:	97 fb       	bst	r25, 7
    20a2:	99 1f       	adc	r25, r25
    20a4:	61 f0       	breq	.+24     	; 0x20be <__fp_splitA+0x20>
    20a6:	9f 3f       	cpi	r25, 0xFF	; 255
    20a8:	79 f0       	breq	.+30     	; 0x20c8 <__fp_splitA+0x2a>
    20aa:	87 95       	ror	r24
    20ac:	08 95       	ret
    20ae:	12 16       	cp	r1, r18
    20b0:	13 06       	cpc	r1, r19
    20b2:	14 06       	cpc	r1, r20
    20b4:	55 1f       	adc	r21, r21
    20b6:	f2 cf       	rjmp	.-28     	; 0x209c <__fp_split3+0xe>
    20b8:	46 95       	lsr	r20
    20ba:	f1 df       	rcall	.-30     	; 0x209e <__fp_splitA>
    20bc:	08 c0       	rjmp	.+16     	; 0x20ce <__fp_splitA+0x30>
    20be:	16 16       	cp	r1, r22
    20c0:	17 06       	cpc	r1, r23
    20c2:	18 06       	cpc	r1, r24
    20c4:	99 1f       	adc	r25, r25
    20c6:	f1 cf       	rjmp	.-30     	; 0x20aa <__fp_splitA+0xc>
    20c8:	86 95       	lsr	r24
    20ca:	71 05       	cpc	r23, r1
    20cc:	61 05       	cpc	r22, r1
    20ce:	08 94       	sec
    20d0:	08 95       	ret

000020d2 <__fp_zero>:
    20d2:	e8 94       	clt

000020d4 <__fp_szero>:
    20d4:	bb 27       	eor	r27, r27
    20d6:	66 27       	eor	r22, r22
    20d8:	77 27       	eor	r23, r23
    20da:	cb 01       	movw	r24, r22
    20dc:	97 f9       	bld	r25, 7
    20de:	08 95       	ret

000020e0 <__mulsf3>:
    20e0:	0b d0       	rcall	.+22     	; 0x20f8 <__mulsf3x>
    20e2:	c4 cf       	rjmp	.-120    	; 0x206c <__fp_round>
    20e4:	b5 df       	rcall	.-150    	; 0x2050 <__fp_pscA>
    20e6:	28 f0       	brcs	.+10     	; 0x20f2 <__mulsf3+0x12>
    20e8:	ba df       	rcall	.-140    	; 0x205e <__fp_pscB>
    20ea:	18 f0       	brcs	.+6      	; 0x20f2 <__mulsf3+0x12>
    20ec:	95 23       	and	r25, r21
    20ee:	09 f0       	breq	.+2      	; 0x20f2 <__mulsf3+0x12>
    20f0:	a6 cf       	rjmp	.-180    	; 0x203e <__fp_inf>
    20f2:	ab cf       	rjmp	.-170    	; 0x204a <__fp_nan>
    20f4:	11 24       	eor	r1, r1
    20f6:	ee cf       	rjmp	.-36     	; 0x20d4 <__fp_szero>

000020f8 <__mulsf3x>:
    20f8:	ca df       	rcall	.-108    	; 0x208e <__fp_split3>
    20fa:	a0 f3       	brcs	.-24     	; 0x20e4 <__mulsf3+0x4>

000020fc <__mulsf3_pse>:
    20fc:	95 9f       	mul	r25, r21
    20fe:	d1 f3       	breq	.-12     	; 0x20f4 <__mulsf3+0x14>
    2100:	95 0f       	add	r25, r21
    2102:	50 e0       	ldi	r21, 0x00	; 0
    2104:	55 1f       	adc	r21, r21
    2106:	62 9f       	mul	r22, r18
    2108:	f0 01       	movw	r30, r0
    210a:	72 9f       	mul	r23, r18
    210c:	bb 27       	eor	r27, r27
    210e:	f0 0d       	add	r31, r0
    2110:	b1 1d       	adc	r27, r1
    2112:	63 9f       	mul	r22, r19
    2114:	aa 27       	eor	r26, r26
    2116:	f0 0d       	add	r31, r0
    2118:	b1 1d       	adc	r27, r1
    211a:	aa 1f       	adc	r26, r26
    211c:	64 9f       	mul	r22, r20
    211e:	66 27       	eor	r22, r22
    2120:	b0 0d       	add	r27, r0
    2122:	a1 1d       	adc	r26, r1
    2124:	66 1f       	adc	r22, r22
    2126:	82 9f       	mul	r24, r18
    2128:	22 27       	eor	r18, r18
    212a:	b0 0d       	add	r27, r0
    212c:	a1 1d       	adc	r26, r1
    212e:	62 1f       	adc	r22, r18
    2130:	73 9f       	mul	r23, r19
    2132:	b0 0d       	add	r27, r0
    2134:	a1 1d       	adc	r26, r1
    2136:	62 1f       	adc	r22, r18
    2138:	83 9f       	mul	r24, r19
    213a:	a0 0d       	add	r26, r0
    213c:	61 1d       	adc	r22, r1
    213e:	22 1f       	adc	r18, r18
    2140:	74 9f       	mul	r23, r20
    2142:	33 27       	eor	r19, r19
    2144:	a0 0d       	add	r26, r0
    2146:	61 1d       	adc	r22, r1
    2148:	23 1f       	adc	r18, r19
    214a:	84 9f       	mul	r24, r20
    214c:	60 0d       	add	r22, r0
    214e:	21 1d       	adc	r18, r1
    2150:	82 2f       	mov	r24, r18
    2152:	76 2f       	mov	r23, r22
    2154:	6a 2f       	mov	r22, r26
    2156:	11 24       	eor	r1, r1
    2158:	9f 57       	subi	r25, 0x7F	; 127
    215a:	50 40       	sbci	r21, 0x00	; 0
    215c:	8a f0       	brmi	.+34     	; 0x2180 <__mulsf3_pse+0x84>
    215e:	e1 f0       	breq	.+56     	; 0x2198 <__mulsf3_pse+0x9c>
    2160:	88 23       	and	r24, r24
    2162:	4a f0       	brmi	.+18     	; 0x2176 <__mulsf3_pse+0x7a>
    2164:	ee 0f       	add	r30, r30
    2166:	ff 1f       	adc	r31, r31
    2168:	bb 1f       	adc	r27, r27
    216a:	66 1f       	adc	r22, r22
    216c:	77 1f       	adc	r23, r23
    216e:	88 1f       	adc	r24, r24
    2170:	91 50       	subi	r25, 0x01	; 1
    2172:	50 40       	sbci	r21, 0x00	; 0
    2174:	a9 f7       	brne	.-22     	; 0x2160 <__mulsf3_pse+0x64>
    2176:	9e 3f       	cpi	r25, 0xFE	; 254
    2178:	51 05       	cpc	r21, r1
    217a:	70 f0       	brcs	.+28     	; 0x2198 <__mulsf3_pse+0x9c>
    217c:	60 cf       	rjmp	.-320    	; 0x203e <__fp_inf>
    217e:	aa cf       	rjmp	.-172    	; 0x20d4 <__fp_szero>
    2180:	5f 3f       	cpi	r21, 0xFF	; 255
    2182:	ec f3       	brlt	.-6      	; 0x217e <__mulsf3_pse+0x82>
    2184:	98 3e       	cpi	r25, 0xE8	; 232
    2186:	dc f3       	brlt	.-10     	; 0x217e <__mulsf3_pse+0x82>
    2188:	86 95       	lsr	r24
    218a:	77 95       	ror	r23
    218c:	67 95       	ror	r22
    218e:	b7 95       	ror	r27
    2190:	f7 95       	ror	r31
    2192:	e7 95       	ror	r30
    2194:	9f 5f       	subi	r25, 0xFF	; 255
    2196:	c1 f7       	brne	.-16     	; 0x2188 <__mulsf3_pse+0x8c>
    2198:	fe 2b       	or	r31, r30
    219a:	88 0f       	add	r24, r24
    219c:	91 1d       	adc	r25, r1
    219e:	96 95       	lsr	r25
    21a0:	87 95       	ror	r24
    21a2:	97 f9       	bld	r25, 7
    21a4:	08 95       	ret

000021a6 <utoa>:
    21a6:	fb 01       	movw	r30, r22
    21a8:	9f 01       	movw	r18, r30
    21aa:	42 30       	cpi	r20, 0x02	; 2
    21ac:	74 f0       	brlt	.+28     	; 0x21ca <utoa+0x24>
    21ae:	45 32       	cpi	r20, 0x25	; 37
    21b0:	64 f4       	brge	.+24     	; 0x21ca <utoa+0x24>
    21b2:	64 2f       	mov	r22, r20
    21b4:	77 27       	eor	r23, r23
    21b6:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <__udivmodhi4>
    21ba:	80 5d       	subi	r24, 0xD0	; 208
    21bc:	8a 33       	cpi	r24, 0x3A	; 58
    21be:	0c f0       	brlt	.+2      	; 0x21c2 <utoa+0x1c>
    21c0:	89 5d       	subi	r24, 0xD9	; 217
    21c2:	81 93       	st	Z+, r24
    21c4:	cb 01       	movw	r24, r22
    21c6:	00 97       	sbiw	r24, 0x00	; 0
    21c8:	a1 f7       	brne	.-24     	; 0x21b2 <utoa+0xc>
    21ca:	10 82       	st	Z, r1
    21cc:	c9 01       	movw	r24, r18
    21ce:	0c 94 e9 10 	jmp	0x21d2	; 0x21d2 <strrev>

000021d2 <strrev>:
    21d2:	dc 01       	movw	r26, r24
    21d4:	fc 01       	movw	r30, r24
    21d6:	67 2f       	mov	r22, r23
    21d8:	71 91       	ld	r23, Z+
    21da:	77 23       	and	r23, r23
    21dc:	e1 f7       	brne	.-8      	; 0x21d6 <strrev+0x4>
    21de:	32 97       	sbiw	r30, 0x02	; 2
    21e0:	04 c0       	rjmp	.+8      	; 0x21ea <strrev+0x18>
    21e2:	7c 91       	ld	r23, X
    21e4:	6d 93       	st	X+, r22
    21e6:	70 83       	st	Z, r23
    21e8:	62 91       	ld	r22, -Z
    21ea:	ae 17       	cp	r26, r30
    21ec:	bf 07       	cpc	r27, r31
    21ee:	c8 f3       	brcs	.-14     	; 0x21e2 <strrev+0x10>
    21f0:	08 95       	ret

000021f2 <__udivmodhi4>:
    21f2:	aa 1b       	sub	r26, r26
    21f4:	bb 1b       	sub	r27, r27
    21f6:	51 e1       	ldi	r21, 0x11	; 17
    21f8:	07 c0       	rjmp	.+14     	; 0x2208 <__udivmodhi4_ep>

000021fa <__udivmodhi4_loop>:
    21fa:	aa 1f       	adc	r26, r26
    21fc:	bb 1f       	adc	r27, r27
    21fe:	a6 17       	cp	r26, r22
    2200:	b7 07       	cpc	r27, r23
    2202:	10 f0       	brcs	.+4      	; 0x2208 <__udivmodhi4_ep>
    2204:	a6 1b       	sub	r26, r22
    2206:	b7 0b       	sbc	r27, r23

00002208 <__udivmodhi4_ep>:
    2208:	88 1f       	adc	r24, r24
    220a:	99 1f       	adc	r25, r25
    220c:	5a 95       	dec	r21
    220e:	a9 f7       	brne	.-22     	; 0x21fa <__udivmodhi4_loop>
    2210:	80 95       	com	r24
    2212:	90 95       	com	r25
    2214:	bc 01       	movw	r22, r24
    2216:	cd 01       	movw	r24, r26
    2218:	08 95       	ret

0000221a <_exit>:
    221a:	f8 94       	cli

0000221c <__stop_program>:
    221c:	ff cf       	rjmp	.-2      	; 0x221c <__stop_program>
